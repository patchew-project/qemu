/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[allow(unsafe_code)]
pub const CONFIG_BINDIR: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/usr/local/bin\0") };
#[allow(unsafe_code)]
pub const CONFIG_HOST_DSOSUF: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b".so\0") };
#[allow(unsafe_code)]
pub const CONFIG_IASL: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/bin/iasl\0") };
#[allow(unsafe_code)]
pub const CONFIG_PREFIX: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/usr/local\0") };
#[allow(unsafe_code)]
pub const CONFIG_QEMU_CONFDIR: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/usr/local/etc/qemu\0") };
#[allow(unsafe_code)]
pub const CONFIG_QEMU_DATADIR: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/usr/local/share/qemu\0") };
#[allow(unsafe_code)]
pub const CONFIG_QEMU_DESKTOPDIR: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/usr/local/share/applications\0") };
#[allow(unsafe_code)]
pub const CONFIG_QEMU_HELPERDIR: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/usr/local/libexec\0") };
#[allow(unsafe_code)]
pub const CONFIG_QEMU_ICONDIR: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/usr/local/share/icons\0") };
#[allow(unsafe_code)]
pub const CONFIG_QEMU_LOCALEDIR: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/usr/local/share/locale\0") };
#[allow(unsafe_code)]
pub const CONFIG_QEMU_LOCALSTATEDIR: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/var/local\0") };
#[allow(unsafe_code)]
pub const CONFIG_QEMU_MODDIR: &::core::ffi::CStr = unsafe {
    ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/usr/local/lib/x86_64-linux-gnu/qemu\0")
};
#[allow(unsafe_code)]
pub const CONFIG_SMBD_COMMAND: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/usr/sbin/smbd\0") };
#[allow(unsafe_code)]
pub const CONFIG_SYSCONFDIR: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/usr/local/etc\0") };
pub const CONFIG_TCG: u32 = 1;
#[allow(unsafe_code)]
pub const CONFIG_TLS_PRIORITY: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"NORMAL\0") };
#[allow(unsafe_code)]
pub const CONFIG_TRACE_FILE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"trace\0") };
pub const CONFIG_XEN_CTRL_INTERFACE_VERSION: u32 = 41700;
pub const HOST_X86_64: u32 = 1;
#[allow(unsafe_code)]
pub const QEMU_VERSION: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"9.0.50\0") };
pub const QEMU_VERSION_MAJOR: u32 = 9;
pub const QEMU_VERSION_MICRO: u32 = 50;
pub const QEMU_VERSION_MINOR: u32 = 0;
pub const CONFIG_I386_DIS: u32 = 1;
pub const CONFIG_SOFTMMU: u32 = 1;
pub const CONFIG_SYSTEM_ONLY: u32 = 1;
pub const CONFIG_TCG_BUILTIN: u32 = 1;
pub const TARGET_AARCH64: u32 = 1;
pub const TARGET_ARM: u32 = 1;
pub const TARGET_BIG_ENDIAN: u32 = 0;
pub const TARGET_KVM_HAVE_GUEST_DEBUG: u32 = 1;
#[allow(unsafe_code)]
pub const TARGET_NAME: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"aarch64\0") };
pub const TARGET_NEED_FDT: u32 = 1;
pub const TARGET_SUPPORTS_MTTCG: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const _DYNAMIC_STACK_SIZE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_FILE_OFFSET64: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_DYNAMIC_STACK_SIZE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_FD_SETSIZE: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_QLIMIT: u32 = 1;
pub const _POSIX_HIWAT: u32 = 512;
pub const _POSIX_UIO_MAXIOV: u32 = 16;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const __SC_THREAD_STACK_MIN_VALUE: u32 = 75;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const IOV_MAX: u32 = 1024;
pub const NL_ARGMAX: u32 = 4096;
pub const NL_LANGMAX: u32 = 2048;
pub const NZERO: u32 = 20;
pub const WORD_BIT: u32 = 32;
pub const LONG_BIT: u32 = 64;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
#[allow(unsafe_code)]
pub const __ILP32_OFF32_CFLAGS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"-m32\0") };
#[allow(unsafe_code)]
pub const __ILP32_OFF32_LDFLAGS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"-m32\0") };
#[allow(unsafe_code)]
pub const __ILP32_OFFBIG_CFLAGS: &::core::ffi::CStr = unsafe {
    ::core::ffi::CStr::from_bytes_with_nul_unchecked(
        b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0",
    )
};
#[allow(unsafe_code)]
pub const __ILP32_OFFBIG_LDFLAGS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"-m32\0") };
#[allow(unsafe_code)]
pub const __LP64_OFF64_CFLAGS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"-m64\0") };
#[allow(unsafe_code)]
pub const __LP64_OFF64_LDFLAGS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"-m64\0") };
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const CLOSE_RANGE_UNSHARE: u32 = 2;
pub const CLOSE_RANGE_CLOEXEC: u32 = 4;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const _BITS_TIMEX_H: u32 = 1;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 32769;
pub const ADJ_OFFSET_SS_READ: u32 = 40961;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_CLKB: u32 = 16384;
pub const MOD_CLKA: u32 = 32769;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const __error_t_defined: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_NDELAY: u32 = 2048;
pub const O_SYNC: u32 = 1052672;
pub const O_FSYNC: u32 = 1052672;
pub const O_ASYNC: u32 = 8192;
pub const __O_DIRECTORY: u32 = 65536;
pub const __O_NOFOLLOW: u32 = 131072;
pub const __O_CLOEXEC: u32 = 524288;
pub const __O_DIRECT: u32 = 16384;
pub const __O_NOATIME: u32 = 262144;
pub const __O_PATH: u32 = 2097152;
pub const __O_DSYNC: u32 = 4096;
pub const __O_TMPFILE: u32 = 4259840;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_OFD_GETLK: u32 = 36;
pub const F_OFD_SETLK: u32 = 37;
pub const F_OFD_SETLKW: u32 = 38;
pub const O_LARGEFILE: u32 = 0;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_CLOEXEC: u32 = 524288;
pub const O_DIRECT: u32 = 16384;
pub const O_NOATIME: u32 = 262144;
pub const O_PATH: u32 = 2097152;
pub const O_TMPFILE: u32 = 4259840;
pub const O_DSYNC: u32 = 4096;
pub const O_RSYNC: u32 = 1052672;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const __F_SETOWN: u32 = 8;
pub const __F_GETOWN: u32 = 9;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const __F_SETSIG: u32 = 10;
pub const __F_GETSIG: u32 = 11;
pub const __F_SETOWN_EX: u32 = 15;
pub const __F_GETOWN_EX: u32 = 16;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_SETLEASE: u32 = 1024;
pub const F_GETLEASE: u32 = 1025;
pub const F_NOTIFY: u32 = 1026;
pub const F_SETPIPE_SZ: u32 = 1031;
pub const F_GETPIPE_SZ: u32 = 1032;
pub const F_ADD_SEALS: u32 = 1033;
pub const F_GET_SEALS: u32 = 1034;
pub const F_GET_RW_HINT: u32 = 1035;
pub const F_SET_RW_HINT: u32 = 1036;
pub const F_GET_FILE_RW_HINT: u32 = 1037;
pub const F_SET_FILE_RW_HINT: u32 = 1038;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const LOCK_MAND: u32 = 32;
pub const LOCK_READ: u32 = 64;
pub const LOCK_WRITE: u32 = 128;
pub const LOCK_RW: u32 = 192;
pub const DN_ACCESS: u32 = 1;
pub const DN_MODIFY: u32 = 2;
pub const DN_CREATE: u32 = 4;
pub const DN_DELETE: u32 = 8;
pub const DN_RENAME: u32 = 16;
pub const DN_ATTRIB: u32 = 32;
pub const DN_MULTISHOT: u32 = 2147483648;
pub const F_SEAL_SEAL: u32 = 1;
pub const F_SEAL_SHRINK: u32 = 2;
pub const F_SEAL_GROW: u32 = 4;
pub const F_SEAL_WRITE: u32 = 8;
pub const F_SEAL_FUTURE_WRITE: u32 = 16;
pub const RWH_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWF_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWH_WRITE_LIFE_NONE: u32 = 1;
pub const RWH_WRITE_LIFE_SHORT: u32 = 2;
pub const RWH_WRITE_LIFE_MEDIUM: u32 = 3;
pub const RWH_WRITE_LIFE_LONG: u32 = 4;
pub const RWH_WRITE_LIFE_EXTREME: u32 = 5;
pub const FAPPEND: u32 = 1024;
pub const FFSYNC: u32 = 1052672;
pub const FASYNC: u32 = 8192;
pub const FNONBLOCK: u32 = 2048;
pub const FNDELAY: u32 = 2048;
pub const __POSIX_FADV_DONTNEED: u32 = 4;
pub const __POSIX_FADV_NOREUSE: u32 = 5;
pub const POSIX_FADV_NORMAL: u32 = 0;
pub const POSIX_FADV_RANDOM: u32 = 1;
pub const POSIX_FADV_SEQUENTIAL: u32 = 2;
pub const POSIX_FADV_WILLNEED: u32 = 3;
pub const POSIX_FADV_DONTNEED: u32 = 4;
pub const POSIX_FADV_NOREUSE: u32 = 5;
pub const SYNC_FILE_RANGE_WAIT_BEFORE: u32 = 1;
pub const SYNC_FILE_RANGE_WRITE: u32 = 2;
pub const SYNC_FILE_RANGE_WAIT_AFTER: u32 = 4;
pub const SYNC_FILE_RANGE_WRITE_AND_WAIT: u32 = 7;
pub const SPLICE_F_MOVE: u32 = 1;
pub const SPLICE_F_NONBLOCK: u32 = 2;
pub const SPLICE_F_MORE: u32 = 4;
pub const SPLICE_F_GIFT: u32 = 8;
pub const FALLOC_FL_KEEP_SIZE: u32 = 1;
pub const FALLOC_FL_PUNCH_HOLE: u32 = 2;
pub const FALLOC_FL_NO_HIDE_STALE: u32 = 4;
pub const FALLOC_FL_COLLAPSE_RANGE: u32 = 8;
pub const FALLOC_FL_ZERO_RANGE: u32 = 16;
pub const FALLOC_FL_INSERT_RANGE: u32 = 32;
pub const FALLOC_FL_UNSHARE_RANGE: u32 = 64;
pub const MAX_HANDLE_SZ: u32 = 128;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_NO_AUTOMOUNT: u32 = 2048;
pub const AT_EMPTY_PATH: u32 = 4096;
pub const AT_STATX_SYNC_TYPE: u32 = 24576;
pub const AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const AT_STATX_FORCE_SYNC: u32 = 8192;
pub const AT_STATX_DONT_SYNC: u32 = 16384;
pub const AT_RECURSIVE: u32 = 32768;
pub const AT_EACCESS: u32 = 512;
pub const _BITS_STAT_H: u32 = 1;
pub const _BITS_STRUCT_STAT_H: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const _GETOPT_EXT_H: u32 = 1;
pub const no_argument: u32 = 0;
pub const required_argument: u32 = 1;
pub const optional_argument: u32 = 2;
pub const _SYS_STAT_H: u32 = 1;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const __BITS_PER_LONG: u32 = 64;
pub const __BITS_PER_LONG_LONG: u32 = 64;
pub const STATX_TYPE: u32 = 1;
pub const STATX_MODE: u32 = 2;
pub const STATX_NLINK: u32 = 4;
pub const STATX_UID: u32 = 8;
pub const STATX_GID: u32 = 16;
pub const STATX_ATIME: u32 = 32;
pub const STATX_MTIME: u32 = 64;
pub const STATX_CTIME: u32 = 128;
pub const STATX_INO: u32 = 256;
pub const STATX_SIZE: u32 = 512;
pub const STATX_BLOCKS: u32 = 1024;
pub const STATX_BASIC_STATS: u32 = 2047;
pub const STATX_BTIME: u32 = 2048;
pub const STATX_MNT_ID: u32 = 4096;
pub const STATX_DIOALIGN: u32 = 8192;
pub const STATX__RESERVED: u32 = 2147483648;
pub const STATX_ALL: u32 = 4095;
pub const STATX_ATTR_COMPRESSED: u32 = 4;
pub const STATX_ATTR_IMMUTABLE: u32 = 16;
pub const STATX_ATTR_APPEND: u32 = 32;
pub const STATX_ATTR_NODUMP: u32 = 64;
pub const STATX_ATTR_ENCRYPTED: u32 = 2048;
pub const STATX_ATTR_AUTOMOUNT: u32 = 4096;
pub const STATX_ATTR_MOUNT_ROOT: u32 = 8192;
pub const STATX_ATTR_VERITY: u32 = 1048576;
pub const STATX_ATTR_DAX: u32 = 2097152;
pub const __statx_timestamp_defined: u32 = 1;
pub const __statx_defined: u32 = 1;
pub const _SYS_TIME_H: u32 = 1;
pub const _SETJMP_H: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_ARCH_H: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const _SYS_UIO_H: u32 = 1;
pub const UIO_MAXIOV: u32 = 1024;
pub const _BITS_UIO_EXT_H: u32 = 1;
pub const RWF_HIPRI: u32 = 1;
pub const RWF_DSYNC: u32 = 2;
pub const RWF_SYNC: u32 = 4;
pub const RWF_NOWAIT: u32 = 8;
pub const RWF_APPEND: u32 = 16;
pub const _SYS_WAIT_H: u32 = 1;
pub const WCOREFLAG: u32 = 128;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
#[allow(unsafe_code)]
pub const G_GINT16_MODIFIER: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"h\0") };
#[allow(unsafe_code)]
pub const G_GINT16_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hi\0") };
#[allow(unsafe_code)]
pub const G_GUINT16_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hu\0") };
#[allow(unsafe_code)]
pub const G_GINT32_MODIFIER: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"\0") };
#[allow(unsafe_code)]
pub const G_GINT32_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"i\0") };
#[allow(unsafe_code)]
pub const G_GUINT32_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"u\0") };
pub const G_HAVE_GINT64: u32 = 1;
#[allow(unsafe_code)]
pub const G_GINT64_MODIFIER: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"l\0") };
#[allow(unsafe_code)]
pub const G_GINT64_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"li\0") };
#[allow(unsafe_code)]
pub const G_GUINT64_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lu\0") };
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 8;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const GLIB_SIZEOF_SSIZE_T: u32 = 8;
#[allow(unsafe_code)]
pub const G_GSIZE_MODIFIER: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"l\0") };
#[allow(unsafe_code)]
pub const G_GSSIZE_MODIFIER: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"l\0") };
#[allow(unsafe_code)]
pub const G_GSIZE_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lu\0") };
#[allow(unsafe_code)]
pub const G_GSSIZE_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"li\0") };
#[allow(unsafe_code)]
pub const G_GOFFSET_MODIFIER: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"l\0") };
#[allow(unsafe_code)]
pub const G_GOFFSET_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"li\0") };
#[allow(unsafe_code)]
pub const G_POLLFD_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"%d\0") };
#[allow(unsafe_code)]
pub const G_GINTPTR_MODIFIER: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"l\0") };
#[allow(unsafe_code)]
pub const G_GINTPTR_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"li\0") };
#[allow(unsafe_code)]
pub const G_GUINTPTR_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lu\0") };
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 74;
pub const GLIB_MICRO_VERSION: u32 = 6;
pub const G_VA_COPY_AS_ARRAY: u32 = 1;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_HAVE_GNUC_VISIBILITY: u32 = 1;
pub const G_HAVE_GNUC_VARARGS: u32 = 1;
#[allow(unsafe_code)]
pub const G_MODULE_SUFFIX: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"so\0") };
#[allow(unsafe_code)]
pub const G_PID_FORMAT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"i\0") };
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 10;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const G_DIR_SEPARATOR: u8 = 47u8;
#[allow(unsafe_code)]
pub const G_DIR_SEPARATOR_S: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/\0") };
pub const G_SEARCHPATH_SEPARATOR: u8 = 58u8;
#[allow(unsafe_code)]
pub const G_SEARCHPATH_SEPARATOR_S: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b":\0") };
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const MAXNAMLEN: u32 = 255;
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_GROUP: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Desktop Entry\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Type\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Version\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Name\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"GenericName\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"NoDisplay\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Comment\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Icon\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Hidden\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"OnlyShowIn\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"NotShowIn\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"TryExec\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Exec\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Path\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Terminal\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"MimeType\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Categories\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"StartupNotify\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"StartupWMClass\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_URL: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"URL\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"DBusActivatable\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Actions\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Application\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Link\0") };
#[allow(unsafe_code)]
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"Directory\0") };
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
#[allow(unsafe_code)]
pub const G_OPTION_REMAINING: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"\0") };
#[allow(unsafe_code)]
pub const G_CSET_A_2_Z: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0") };
#[allow(unsafe_code)]
pub const G_CSET_a_2_z: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"abcdefghijklmnopqrstuvwxyz\0") };
#[allow(unsafe_code)]
pub const G_CSET_DIGITS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"0123456789\0") };
#[allow(unsafe_code)]
pub const G_CSET_LATINC: &::core::ffi::CStr = unsafe {
    :: core :: ffi :: CStr :: from_bytes_with_nul_unchecked (b"\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE\0")
};
#[allow(unsafe_code)]
pub const G_CSET_LATINS: &::core::ffi::CStr = unsafe {
    :: core :: ffi :: CStr :: from_bytes_with_nul_unchecked (b"\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF\0")
};
#[allow(unsafe_code)]
pub const G_STR_DELIMITERS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"_-|> <.\0") };
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
#[allow(unsafe_code)]
pub const G_TEST_OPTION_ISOLATE_DIRS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"isolate_dirs\0") };
pub const G_USEC_PER_SEC: u32 = 1000000;
#[allow(unsafe_code)]
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b":/?#[]@\0") };
#[allow(unsafe_code)]
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"!$&'()*+,;=\0") };
#[allow(unsafe_code)]
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"!$&'()*+,;=:@\0") };
#[allow(unsafe_code)]
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"!$&'()*+,;=:@/\0") };
#[allow(unsafe_code)]
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"!$&'()*+,;=:\0") };
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_ISO: u32 = 4;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const CLONE_NEWTIME: u32 = 128;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const CPU_SETSIZE: u32 = 1024;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const PTHREAD_ATTR_NO_SIGMASK_NP: i32 = -1;
pub const _PWD_H: u32 = 1;
pub const NSS_BUFLEN_PASSWD: u32 = 1024;
pub const _SYS_MMAN_H: u32 = 1;
pub const MAP_32BIT: u32 = 64;
pub const MAP_GROWSDOWN: u32 = 256;
pub const MAP_DENYWRITE: u32 = 2048;
pub const MAP_EXECUTABLE: u32 = 4096;
pub const MAP_LOCKED: u32 = 8192;
pub const MAP_NORESERVE: u32 = 16384;
pub const MAP_POPULATE: u32 = 32768;
pub const MAP_NONBLOCK: u32 = 65536;
pub const MAP_STACK: u32 = 131072;
pub const MAP_HUGETLB: u32 = 262144;
pub const MAP_SYNC: u32 = 524288;
pub const MAP_FIXED_NOREPLACE: u32 = 1048576;
pub const PROT_READ: u32 = 1;
pub const PROT_WRITE: u32 = 2;
pub const PROT_EXEC: u32 = 4;
pub const PROT_NONE: u32 = 0;
pub const PROT_GROWSDOWN: u32 = 16777216;
pub const PROT_GROWSUP: u32 = 33554432;
pub const MAP_SHARED: u32 = 1;
pub const MAP_PRIVATE: u32 = 2;
pub const MAP_SHARED_VALIDATE: u32 = 3;
pub const MAP_TYPE: u32 = 15;
pub const MAP_FIXED: u32 = 16;
pub const MAP_FILE: u32 = 0;
pub const MAP_ANONYMOUS: u32 = 32;
pub const MAP_ANON: u32 = 32;
pub const MAP_HUGE_SHIFT: u32 = 26;
pub const MAP_HUGE_MASK: u32 = 63;
pub const MS_ASYNC: u32 = 1;
pub const MS_SYNC: u32 = 4;
pub const MS_INVALIDATE: u32 = 2;
pub const MADV_NORMAL: u32 = 0;
pub const MADV_RANDOM: u32 = 1;
pub const MADV_SEQUENTIAL: u32 = 2;
pub const MADV_WILLNEED: u32 = 3;
pub const MADV_DONTNEED: u32 = 4;
pub const MADV_FREE: u32 = 8;
pub const MADV_REMOVE: u32 = 9;
pub const MADV_DONTFORK: u32 = 10;
pub const MADV_DOFORK: u32 = 11;
pub const MADV_MERGEABLE: u32 = 12;
pub const MADV_UNMERGEABLE: u32 = 13;
pub const MADV_HUGEPAGE: u32 = 14;
pub const MADV_NOHUGEPAGE: u32 = 15;
pub const MADV_DONTDUMP: u32 = 16;
pub const MADV_DODUMP: u32 = 17;
pub const MADV_WIPEONFORK: u32 = 18;
pub const MADV_KEEPONFORK: u32 = 19;
pub const MADV_COLD: u32 = 20;
pub const MADV_PAGEOUT: u32 = 21;
pub const MADV_POPULATE_READ: u32 = 22;
pub const MADV_POPULATE_WRITE: u32 = 23;
pub const MADV_DONTNEED_LOCKED: u32 = 24;
pub const MADV_HWPOISON: u32 = 100;
pub const POSIX_MADV_NORMAL: u32 = 0;
pub const POSIX_MADV_RANDOM: u32 = 1;
pub const POSIX_MADV_SEQUENTIAL: u32 = 2;
pub const POSIX_MADV_WILLNEED: u32 = 3;
pub const POSIX_MADV_DONTNEED: u32 = 4;
pub const MCL_CURRENT: u32 = 1;
pub const MCL_FUTURE: u32 = 2;
pub const MCL_ONFAULT: u32 = 4;
pub const MREMAP_MAYMOVE: u32 = 1;
pub const MREMAP_FIXED: u32 = 2;
pub const MREMAP_DONTUNMAP: u32 = 4;
pub const MFD_CLOEXEC: u32 = 1;
pub const MFD_ALLOW_SEALING: u32 = 2;
pub const MFD_HUGETLB: u32 = 4;
pub const MLOCK_ONFAULT: u32 = 1;
pub const PKEY_DISABLE_ACCESS: u32 = 1;
pub const PKEY_DISABLE_WRITE: u32 = 2;
pub const _SYS_SOCKET_H: u32 = 1;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOL_MPTCP: u32 = 284;
pub const SOL_MCTP: u32 = 285;
pub const SOL_SMC: u32 = 286;
pub const SOMAXCONN: u32 = 4096;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_RESERVE_MEM: u32 = 73;
pub const SO_TXREHASH: u32 = 74;
pub const SO_RCVMARK: u32 = 75;
pub const SO_TIMESTAMP: u32 = 29;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const __osockaddr_defined: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const __USE_KERNEL_IPV6_DEFS: u32 = 0;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_RECVERR_RFC4884: u32 = 26;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_RECVERR_RFC4884: u32 = 31;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const _NETINET_TCP_H: u32 = 1;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_MAXSEG: u32 = 2;
pub const TCP_CORK: u32 = 3;
pub const TCP_KEEPIDLE: u32 = 4;
pub const TCP_KEEPINTVL: u32 = 5;
pub const TCP_KEEPCNT: u32 = 6;
pub const TCP_SYNCNT: u32 = 7;
pub const TCP_LINGER2: u32 = 8;
pub const TCP_DEFER_ACCEPT: u32 = 9;
pub const TCP_WINDOW_CLAMP: u32 = 10;
pub const TCP_INFO: u32 = 11;
pub const TCP_QUICKACK: u32 = 12;
pub const TCP_CONGESTION: u32 = 13;
pub const TCP_MD5SIG: u32 = 14;
pub const TCP_COOKIE_TRANSACTIONS: u32 = 15;
pub const TCP_THIN_LINEAR_TIMEOUTS: u32 = 16;
pub const TCP_THIN_DUPACK: u32 = 17;
pub const TCP_USER_TIMEOUT: u32 = 18;
pub const TCP_REPAIR: u32 = 19;
pub const TCP_REPAIR_QUEUE: u32 = 20;
pub const TCP_QUEUE_SEQ: u32 = 21;
pub const TCP_REPAIR_OPTIONS: u32 = 22;
pub const TCP_FASTOPEN: u32 = 23;
pub const TCP_TIMESTAMP: u32 = 24;
pub const TCP_NOTSENT_LOWAT: u32 = 25;
pub const TCP_CC_INFO: u32 = 26;
pub const TCP_SAVE_SYN: u32 = 27;
pub const TCP_SAVED_SYN: u32 = 28;
pub const TCP_REPAIR_WINDOW: u32 = 29;
pub const TCP_FASTOPEN_CONNECT: u32 = 30;
pub const TCP_ULP: u32 = 31;
pub const TCP_MD5SIG_EXT: u32 = 32;
pub const TCP_FASTOPEN_KEY: u32 = 33;
pub const TCP_FASTOPEN_NO_COOKIE: u32 = 34;
pub const TCP_ZEROCOPY_RECEIVE: u32 = 35;
pub const TCP_INQ: u32 = 36;
pub const TCP_CM_INQ: u32 = 36;
pub const TCP_TX_DELAY: u32 = 37;
pub const TCP_REPAIR_ON: u32 = 1;
pub const TCP_REPAIR_OFF: u32 = 0;
pub const TCP_REPAIR_OFF_NO_WP: i32 = -1;
pub const TH_FIN: u32 = 1;
pub const TH_SYN: u32 = 2;
pub const TH_RST: u32 = 4;
pub const TH_PUSH: u32 = 8;
pub const TH_ACK: u32 = 16;
pub const TH_URG: u32 = 32;
pub const TCPOPT_EOL: u32 = 0;
pub const TCPOPT_NOP: u32 = 1;
pub const TCPOPT_MAXSEG: u32 = 2;
pub const TCPOLEN_MAXSEG: u32 = 4;
pub const TCPOPT_WINDOW: u32 = 3;
pub const TCPOLEN_WINDOW: u32 = 3;
pub const TCPOPT_SACK_PERMITTED: u32 = 4;
pub const TCPOLEN_SACK_PERMITTED: u32 = 2;
pub const TCPOPT_SACK: u32 = 5;
pub const TCPOPT_TIMESTAMP: u32 = 8;
pub const TCPOLEN_TIMESTAMP: u32 = 10;
pub const TCPOLEN_TSTAMP_APPA: u32 = 12;
pub const TCPOPT_TSTAMP_HDR: u32 = 16844810;
pub const TCP_MSS: u32 = 512;
pub const TCP_MAXWIN: u32 = 65535;
pub const TCP_MAX_WINSHIFT: u32 = 14;
pub const SOL_TCP: u32 = 6;
pub const TCPI_OPT_TIMESTAMPS: u32 = 1;
pub const TCPI_OPT_SACK: u32 = 2;
pub const TCPI_OPT_WSCALE: u32 = 4;
pub const TCPI_OPT_ECN: u32 = 8;
pub const TCPI_OPT_ECN_SEEN: u32 = 16;
pub const TCPI_OPT_SYN_DATA: u32 = 32;
pub const TCP_MD5SIG_MAXKEYLEN: u32 = 80;
pub const TCP_MD5SIG_FLAG_PREFIX: u32 = 1;
pub const TCP_COOKIE_MIN: u32 = 8;
pub const TCP_COOKIE_MAX: u32 = 16;
pub const TCP_COOKIE_PAIR_SIZE: u32 = 32;
pub const TCP_COOKIE_IN_ALWAYS: u32 = 1;
pub const TCP_COOKIE_OUT_NEVER: u32 = 2;
pub const TCP_S_DATA_IN: u32 = 4;
pub const TCP_S_DATA_OUT: u32 = 8;
pub const TCP_MSS_DEFAULT: u32 = 536;
pub const TCP_MSS_DESIRED: u32 = 1220;
pub const _ARPA_INET_H: u32 = 1;
pub const _NETDB_H: u32 = 1;
pub const _RPC_NETDB_H: u32 = 1;
#[allow(unsafe_code)]
pub const _PATH_HEQUIV: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/etc/hosts.equiv\0") };
#[allow(unsafe_code)]
pub const _PATH_HOSTS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/etc/hosts\0") };
#[allow(unsafe_code)]
pub const _PATH_NETWORKS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/etc/networks\0") };
#[allow(unsafe_code)]
pub const _PATH_NSSWITCH_CONF: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/etc/nsswitch.conf\0") };
#[allow(unsafe_code)]
pub const _PATH_PROTOCOLS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/etc/protocols\0") };
#[allow(unsafe_code)]
pub const _PATH_SERVICES: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"/etc/services\0") };
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const NO_ADDRESS: u32 = 4;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const GAI_WAIT: u32 = 0;
pub const GAI_NOWAIT: u32 = 1;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_V4MAPPED: u32 = 8;
pub const AI_ALL: u32 = 16;
pub const AI_ADDRCONFIG: u32 = 32;
pub const AI_IDN: u32 = 64;
pub const AI_CANONIDN: u32 = 128;
pub const AI_NUMERICSERV: u32 = 1024;
pub const EAI_BADFLAGS: i32 = -1;
pub const EAI_NONAME: i32 = -2;
pub const EAI_AGAIN: i32 = -3;
pub const EAI_FAIL: i32 = -4;
pub const EAI_FAMILY: i32 = -6;
pub const EAI_SOCKTYPE: i32 = -7;
pub const EAI_SERVICE: i32 = -8;
pub const EAI_MEMORY: i32 = -10;
pub const EAI_SYSTEM: i32 = -11;
pub const EAI_OVERFLOW: i32 = -12;
pub const EAI_NODATA: i32 = -5;
pub const EAI_ADDRFAMILY: i32 = -9;
pub const EAI_INPROGRESS: i32 = -100;
pub const EAI_CANCELED: i32 = -101;
pub const EAI_NOTCANCELED: i32 = -102;
pub const EAI_ALLDONE: i32 = -103;
pub const EAI_INTR: i32 = -104;
pub const EAI_IDN_ENCODE: i32 = -105;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NUMERICHOST: u32 = 1;
pub const NI_NUMERICSERV: u32 = 2;
pub const NI_NOFQDN: u32 = 4;
pub const NI_NAMEREQD: u32 = 8;
pub const NI_DGRAM: u32 = 16;
pub const NI_IDN: u32 = 32;
pub const _SYS_UN_H: u32 = 1;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const O_BINARY: u32 = 0;
pub const HAVE_CHARDEV_SERIAL: u32 = 1;
pub const HAVE_CHARDEV_PARALLEL: u32 = 1;
pub const QEMU_VMALLOC_ALIGN: u32 = 2097152;
#[allow(unsafe_code)]
pub const FMT_pid: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"%d\0") };
pub const ATOMIC_REG_SIZE: u32 = 8;
pub const NANOSECONDS_PER_SECOND: u32 = 1000000000;
pub const SCALE_MS: u32 = 1000000;
pub const SCALE_US: u32 = 1000;
pub const SCALE_NS: u32 = 1;
pub const QEMU_TIMER_ATTR_ALL: u32 = 4294967295;
#[allow(unsafe_code)]
pub const UUID_FMT: &::core::ffi::CStr = unsafe {
    :: core :: ffi :: CStr :: from_bytes_with_nul_unchecked (b"%02hhx%02hhx%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx\0")
};
#[allow(unsafe_code)]
pub const UUID_NONE: &::core::ffi::CStr = unsafe {
    ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"00000000-0000-0000-0000-000000000000\0")
};
pub const MAX_OPTION_ROMS: u32 = 16;
pub const MAX_PROM_ENVS: u32 = 128;
pub const MAX_PARALLEL_PORTS: u32 = 3;
pub const _SEMAPHORE_H: u32 = 1;
pub const __SIZEOF_SEM_T: u32 = 32;
pub const QEMU_THREAD_JOINABLE: u32 = 0;
pub const QEMU_THREAD_DETACHED: u32 = 1;
#[allow(unsafe_code)]
pub const TYPE_OBJECT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"object\0") };
pub const OBJECT_CLASS_CAST_CACHE: u32 = 4;
#[allow(unsafe_code)]
pub const TYPE_INTERFACE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"interface\0") };
#[allow(unsafe_code)]
pub const TYPE_HOTPLUG_HANDLER: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hotplug-handler\0") };
#[allow(unsafe_code)]
pub const TYPE_RESETTABLE_INTERFACE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"resettable\0") };
#[allow(unsafe_code)]
pub const TYPE_DEVICE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"device\0") };
#[allow(unsafe_code)]
pub const TYPE_BUS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"bus\0") };
#[allow(unsafe_code)]
pub const QDEV_HOTPLUG_HANDLER_PROPERTY: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"hotplug-handler\0") };
#[allow(unsafe_code)]
pub const VADDR_PRId: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ld\0") };
#[allow(unsafe_code)]
pub const VADDR_PRIu: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lu\0") };
#[allow(unsafe_code)]
pub const VADDR_PRIo: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lo\0") };
#[allow(unsafe_code)]
pub const VADDR_PRIx: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lx\0") };
#[allow(unsafe_code)]
pub const VADDR_PRIX: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lX\0") };
pub const HWADDR_BITS: u32 = 64;
#[allow(unsafe_code)]
pub const HWADDR_FMT_plx: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"%016lx\0") };
#[allow(unsafe_code)]
pub const HWADDR_PRId: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ld\0") };
#[allow(unsafe_code)]
pub const HWADDR_PRIi: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"li\0") };
#[allow(unsafe_code)]
pub const HWADDR_PRIo: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lo\0") };
#[allow(unsafe_code)]
pub const HWADDR_PRIu: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lu\0") };
#[allow(unsafe_code)]
pub const HWADDR_PRIx: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lx\0") };
#[allow(unsafe_code)]
pub const HWADDR_PRIX: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"lX\0") };
pub const bfd_mach_m68000: u32 = 1;
pub const bfd_mach_m68008: u32 = 2;
pub const bfd_mach_m68010: u32 = 3;
pub const bfd_mach_m68020: u32 = 4;
pub const bfd_mach_m68030: u32 = 5;
pub const bfd_mach_m68040: u32 = 6;
pub const bfd_mach_m68060: u32 = 7;
pub const bfd_mach_cpu32: u32 = 8;
pub const bfd_mach_mcf5200: u32 = 9;
pub const bfd_mach_mcf5206e: u32 = 10;
pub const bfd_mach_mcf5307: u32 = 11;
pub const bfd_mach_mcf5407: u32 = 12;
pub const bfd_mach_mcf528x: u32 = 13;
pub const bfd_mach_mcfv4e: u32 = 14;
pub const bfd_mach_mcf521x: u32 = 15;
pub const bfd_mach_mcf5249: u32 = 16;
pub const bfd_mach_mcf547x: u32 = 17;
pub const bfd_mach_mcf548x: u32 = 18;
pub const bfd_mach_i960_core: u32 = 1;
pub const bfd_mach_i960_ka_sa: u32 = 2;
pub const bfd_mach_i960_kb_sb: u32 = 3;
pub const bfd_mach_i960_mc: u32 = 4;
pub const bfd_mach_i960_xa: u32 = 5;
pub const bfd_mach_i960_ca: u32 = 6;
pub const bfd_mach_i960_jx: u32 = 7;
pub const bfd_mach_i960_hx: u32 = 8;
pub const bfd_mach_sparc: u32 = 1;
pub const bfd_mach_sparc_sparclet: u32 = 2;
pub const bfd_mach_sparc_sparclite: u32 = 3;
pub const bfd_mach_sparc_v8plus: u32 = 4;
pub const bfd_mach_sparc_v8plusa: u32 = 5;
pub const bfd_mach_sparc_sparclite_le: u32 = 6;
pub const bfd_mach_sparc_v9: u32 = 7;
pub const bfd_mach_sparc_v9a: u32 = 8;
pub const bfd_mach_sparc_v8plusb: u32 = 9;
pub const bfd_mach_sparc_v9b: u32 = 10;
pub const bfd_mach_mips3000: u32 = 3000;
pub const bfd_mach_mips3900: u32 = 3900;
pub const bfd_mach_mips4000: u32 = 4000;
pub const bfd_mach_mips4010: u32 = 4010;
pub const bfd_mach_mips4100: u32 = 4100;
pub const bfd_mach_mips4300: u32 = 4300;
pub const bfd_mach_mips4400: u32 = 4400;
pub const bfd_mach_mips4600: u32 = 4600;
pub const bfd_mach_mips4650: u32 = 4650;
pub const bfd_mach_mips5000: u32 = 5000;
pub const bfd_mach_mips6000: u32 = 6000;
pub const bfd_mach_mips8000: u32 = 8000;
pub const bfd_mach_mips10000: u32 = 10000;
pub const bfd_mach_mips16: u32 = 16;
pub const bfd_mach_i386_i386: u32 = 0;
pub const bfd_mach_i386_i8086: u32 = 1;
pub const bfd_mach_i386_i386_intel_syntax: u32 = 2;
pub const bfd_mach_x86_64: u32 = 3;
pub const bfd_mach_x86_64_intel_syntax: u32 = 4;
pub const bfd_mach_h8300: u32 = 1;
pub const bfd_mach_h8300h: u32 = 2;
pub const bfd_mach_h8300s: u32 = 3;
pub const bfd_mach_ppc: u32 = 0;
pub const bfd_mach_ppc64: u32 = 1;
pub const bfd_mach_ppc_403: u32 = 403;
pub const bfd_mach_ppc_403gc: u32 = 4030;
pub const bfd_mach_ppc_e500: u32 = 500;
pub const bfd_mach_ppc_505: u32 = 505;
pub const bfd_mach_ppc_601: u32 = 601;
pub const bfd_mach_ppc_602: u32 = 602;
pub const bfd_mach_ppc_603: u32 = 603;
pub const bfd_mach_ppc_ec603e: u32 = 6031;
pub const bfd_mach_ppc_604: u32 = 604;
pub const bfd_mach_ppc_620: u32 = 620;
pub const bfd_mach_ppc_630: u32 = 630;
pub const bfd_mach_ppc_750: u32 = 750;
pub const bfd_mach_ppc_860: u32 = 860;
pub const bfd_mach_ppc_a35: u32 = 35;
pub const bfd_mach_ppc_rs64ii: u32 = 642;
pub const bfd_mach_ppc_rs64iii: u32 = 643;
pub const bfd_mach_ppc_7400: u32 = 7400;
pub const bfd_mach_hppa10: u32 = 10;
pub const bfd_mach_hppa11: u32 = 11;
pub const bfd_mach_hppa20: u32 = 20;
pub const bfd_mach_hppa20w: u32 = 25;
pub const bfd_mach_z8001: u32 = 1;
pub const bfd_mach_z8002: u32 = 2;
pub const bfd_mach_sh: u32 = 1;
pub const bfd_mach_sh2: u32 = 32;
pub const bfd_mach_sh_dsp: u32 = 45;
pub const bfd_mach_sh2a: u32 = 42;
pub const bfd_mach_sh2a_nofpu: u32 = 43;
pub const bfd_mach_sh2e: u32 = 46;
pub const bfd_mach_sh3: u32 = 48;
pub const bfd_mach_sh3_nommu: u32 = 49;
pub const bfd_mach_sh3_dsp: u32 = 61;
pub const bfd_mach_sh3e: u32 = 62;
pub const bfd_mach_sh4: u32 = 64;
pub const bfd_mach_sh4_nofpu: u32 = 65;
pub const bfd_mach_sh4_nommu_nofpu: u32 = 66;
pub const bfd_mach_sh4a: u32 = 74;
pub const bfd_mach_sh4a_nofpu: u32 = 75;
pub const bfd_mach_sh4al_dsp: u32 = 77;
pub const bfd_mach_sh5: u32 = 80;
pub const bfd_mach_alpha: u32 = 1;
pub const bfd_mach_alpha_ev4: u32 = 16;
pub const bfd_mach_alpha_ev5: u32 = 32;
pub const bfd_mach_alpha_ev6: u32 = 48;
pub const bfd_mach_arm_unknown: u32 = 0;
pub const bfd_mach_arm_2: u32 = 1;
pub const bfd_mach_arm_2a: u32 = 2;
pub const bfd_mach_arm_3: u32 = 3;
pub const bfd_mach_arm_3M: u32 = 4;
pub const bfd_mach_arm_4: u32 = 5;
pub const bfd_mach_arm_4T: u32 = 6;
pub const bfd_mach_arm_5: u32 = 7;
pub const bfd_mach_arm_5T: u32 = 8;
pub const bfd_mach_arm_5TE: u32 = 9;
pub const bfd_mach_arm_XScale: u32 = 10;
pub const bfd_mach_arm_ep9312: u32 = 11;
pub const bfd_mach_arm_iWMMXt: u32 = 12;
pub const bfd_mach_arm_iWMMXt2: u32 = 13;
pub const bfd_mach_v850: u32 = 0;
pub const bfd_mach_arc_base: u32 = 0;
pub const bfd_mach_m32r: u32 = 0;
pub const bfd_mach_avr1: u32 = 1;
pub const bfd_mach_avr2: u32 = 2;
pub const bfd_mach_avr25: u32 = 25;
pub const bfd_mach_avr3: u32 = 3;
pub const bfd_mach_avr31: u32 = 31;
pub const bfd_mach_avr35: u32 = 35;
pub const bfd_mach_avr4: u32 = 4;
pub const bfd_mach_avr5: u32 = 5;
pub const bfd_mach_avr51: u32 = 51;
pub const bfd_mach_avr6: u32 = 6;
pub const bfd_mach_avrtiny: u32 = 100;
pub const bfd_mach_avrxmega1: u32 = 101;
pub const bfd_mach_avrxmega2: u32 = 102;
pub const bfd_mach_avrxmega3: u32 = 103;
pub const bfd_mach_avrxmega4: u32 = 104;
pub const bfd_mach_avrxmega5: u32 = 105;
pub const bfd_mach_avrxmega6: u32 = 106;
pub const bfd_mach_avrxmega7: u32 = 107;
pub const bfd_mach_cris_v0_v10: u32 = 255;
pub const bfd_mach_cris_v32: u32 = 32;
pub const bfd_mach_cris_v10_v32: u32 = 1032;
pub const bfd_mach_ia64_elf64: u32 = 64;
pub const bfd_mach_ia64_elf32: u32 = 32;
pub const bfd_mach_rx: u32 = 117;
pub const bfd_mach_rx_v2: u32 = 118;
pub const bfd_mach_rx_v3: u32 = 119;
pub const bfd_mach_s390_31: u32 = 31;
pub const bfd_mach_s390_64: u32 = 64;
pub const INSN_HAS_RELOC: u32 = 2147483648;
pub const INSN_ARM_BE32: u32 = 65536;
pub const MEMTX_OK: u32 = 0;
pub const MEMTX_ERROR: u32 = 1;
pub const MEMTX_DECODE_ERROR: u32 = 2;
pub const MEMTX_ACCESS_ERROR: u32 = 4;
pub const MMU_ACCESS_COUNT: u32 = 3;
pub const EXEC_TLB_COMMON_H: u32 = 1;
pub const CPU_TLB_ENTRY_BITS: u32 = 5;
#[allow(unsafe_code)]
pub const TYPE_CPU: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"cpu\0") };
pub const NB_MMU_MODES: u32 = 16;
pub const CPU_VTLB_SIZE: u32 = 8;
pub const CPU_UNSET_NUMA_NODE_ID: i32 = -1;
pub const SSTEP_ENABLE: u32 = 1;
pub const SSTEP_NOIRQ: u32 = 2;
pub const SSTEP_NOTIMER: u32 = 4;
pub const BP_MEM_READ: u32 = 1;
pub const BP_MEM_WRITE: u32 = 2;
pub const BP_MEM_ACCESS: u32 = 3;
pub const BP_STOP_BEFORE_ACCESS: u32 = 4;
pub const BP_GDB: u32 = 16;
pub const BP_CPU: u32 = 32;
pub const BP_ANY: u32 = 48;
pub const BP_HIT_SHIFT: u32 = 6;
pub const BP_WATCHPOINT_HIT_READ: u32 = 64;
pub const BP_WATCHPOINT_HIT_WRITE: u32 = 128;
pub const BP_WATCHPOINT_HIT: u32 = 192;
pub const UNASSIGNED_CPU_INDEX: i32 = -1;
pub const UNASSIGNED_CLUSTER_INDEX: i32 = -1;
pub const PAGE_READ: u32 = 1;
pub const PAGE_WRITE: u32 = 2;
pub const PAGE_EXEC: u32 = 4;
pub const PAGE_RWX: u32 = 7;
pub const PAGE_VALID: u32 = 8;
pub const PAGE_WRITE_ORG: u32 = 16;
pub const PAGE_WRITE_INV: u32 = 32;
pub const PAGE_RESET: u32 = 64;
pub const PAGE_ANON: u32 = 128;
pub const PAGE_TARGET_1: u32 = 512;
pub const PAGE_TARGET_2: u32 = 1024;
pub const PAGE_PASSTHROUGH: u32 = 2048;
pub const EXCP_INTERRUPT: u32 = 65536;
pub const EXCP_HLT: u32 = 65537;
pub const EXCP_DEBUG: u32 = 65538;
pub const EXCP_HALTED: u32 = 65539;
pub const EXCP_YIELD: u32 = 65540;
pub const EXCP_ATOMIC: u32 = 65541;
#[allow(unsafe_code)]
pub const RAM_ADDR_FMT: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"%lx\0") };
pub const DIRTY_MEMORY_VGA: u32 = 0;
pub const DIRTY_MEMORY_CODE: u32 = 1;
pub const DIRTY_MEMORY_MIGRATION: u32 = 2;
pub const DIRTY_MEMORY_NUM: u32 = 3;
pub const MAX_PHYS_ADDR_SPACE_BITS: u32 = 62;
#[allow(unsafe_code)]
pub const TYPE_MEMORY_REGION: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"memory-region\0") };
#[allow(unsafe_code)]
pub const TYPE_IOMMU_MEMORY_REGION: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"iommu-memory-region\0") };
#[allow(unsafe_code)]
pub const TYPE_RAM_DISCARD_MANAGER: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"ram-discard-manager\0") };
pub const GLOBAL_DIRTY_MIGRATION: u32 = 1;
pub const GLOBAL_DIRTY_DIRTY_RATE: u32 = 2;
pub const GLOBAL_DIRTY_LIMIT: u32 = 4;
pub const GLOBAL_DIRTY_MASK: u32 = 7;
pub const RAM_PREALLOC: u32 = 1;
pub const RAM_SHARED: u32 = 2;
pub const RAM_RESIZEABLE: u32 = 4;
pub const RAM_UF_ZEROPAGE: u32 = 8;
pub const RAM_MIGRATABLE: u32 = 16;
pub const RAM_PMEM: u32 = 32;
pub const RAM_UF_WRITEPROTECT: u32 = 64;
pub const RAM_NORESERVE: u32 = 128;
pub const RAM_PROTECTED: u32 = 256;
pub const RAM_NAMED_FILE: u32 = 512;
pub const RAM_READONLY: u32 = 1024;
pub const RAM_READONLY_FD: u32 = 2048;
pub const RAM_GUEST_MEMFD: u32 = 4096;
pub const MEMORY_LISTENER_PRIORITY_MIN: u32 = 0;
pub const MEMORY_LISTENER_PRIORITY_ACCEL: u32 = 10;
pub const MEMORY_LISTENER_PRIORITY_DEV_BACKEND: u32 = 10;
pub const QDEV_MAX_MMIO: u32 = 32;
pub const QDEV_MAX_PIO: u32 = 32;
#[allow(unsafe_code)]
pub const TYPE_SYSTEM_BUS: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"System\0") };
#[allow(unsafe_code)]
pub const TYPE_SYS_BUS_DEVICE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"sys-bus-device\0") };
#[allow(unsafe_code)]
pub const SYSBUS_DEVICE_GPIO_IRQ: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"sysbus-irq\0") };
pub const IAC_EOR: u32 = 239;
pub const IAC_SE: u32 = 240;
pub const IAC_NOP: u32 = 241;
pub const IAC_BREAK: u32 = 243;
pub const IAC_IP: u32 = 244;
pub const IAC_SB: u32 = 250;
pub const IAC: u32 = 255;
pub const CHR_READ_BUF_LEN: u32 = 4096;
#[allow(unsafe_code)]
pub const TYPE_CHARDEV: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_NULL: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-null\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_MUX: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-mux\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_RINGBUF: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-ringbuf\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_PTY: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-pty\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_CONSOLE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-console\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_STDIO: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-stdio\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_PIPE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-pipe\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_MEMORY: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-memory\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_PARALLEL: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-parallel\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_FILE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-file\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_SERIAL: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-serial\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_SOCKET: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-socket\0") };
#[allow(unsafe_code)]
pub const TYPE_CHARDEV_UDP: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"chardev-udp\0") };
#[allow(unsafe_code)]
pub const TYPE_EVENT_LOOP_BASE: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"event-loop-base\0") };
pub const SIG_IPI: u32 = 10;
#[allow(unsafe_code)]
pub const TYPE_MAIN_LOOP: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"main-loop\0") };
#[allow(unsafe_code)]
pub const TYPE_CLOCK: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"clock\0") };
pub const CLOCK_PERIOD_1SEC: u64 = 4294967296000000000;
#[allow(unsafe_code)]
pub const TYPE_IRQ: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"irq\0") };
#[allow(unsafe_code)]
pub const TYPE_VMSTATE_IF: &::core::ffi::CStr =
    unsafe { ::core::ffi::CStr::from_bytes_with_nul_unchecked(b"vmstate-if\0") };
pub const VMS_NULLPTR_MARKER: u32 = 48;
pub const VMSTATE_INSTANCE_ID_ANY: i32 = -1;
pub const CHR_IOCTL_SERIAL_SET_PARAMS: u32 = 1;
pub const CHR_IOCTL_SERIAL_SET_BREAK: u32 = 2;
pub const CHR_IOCTL_SERIAL_SET_TIOCM: u32 = 13;
pub const CHR_IOCTL_SERIAL_GET_TIOCM: u32 = 14;
pub const CHR_TIOCM_CTS: u32 = 32;
pub const CHR_TIOCM_CAR: u32 = 64;
pub const CHR_TIOCM_DSR: u32 = 256;
pub const CHR_TIOCM_RI: u32 = 128;
pub const CHR_TIOCM_DTR: u32 = 2;
pub const CHR_TIOCM_RTS: u32 = 4;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wchar_t = core::ffi::c_int;
pub type __u_char = core::ffi::c_uchar;
pub type __u_short = core::ffi::c_ushort;
pub type __u_int = core::ffi::c_uint;
pub type __u_long = core::ffi::c_ulong;
pub type __int8_t = core::ffi::c_schar;
pub type __uint8_t = core::ffi::c_uchar;
pub type __int16_t = core::ffi::c_short;
pub type __uint16_t = core::ffi::c_ushort;
pub type __int32_t = core::ffi::c_int;
pub type __uint32_t = core::ffi::c_uint;
pub type __int64_t = core::ffi::c_long;
pub type __uint64_t = core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = core::ffi::c_long;
pub type __u_quad_t = core::ffi::c_ulong;
pub type __intmax_t = core::ffi::c_long;
pub type __uintmax_t = core::ffi::c_ulong;
pub type __dev_t = core::ffi::c_ulong;
pub type __uid_t = core::ffi::c_uint;
pub type __gid_t = core::ffi::c_uint;
pub type __ino_t = core::ffi::c_ulong;
pub type __ino64_t = core::ffi::c_ulong;
pub type __mode_t = core::ffi::c_uint;
pub type __nlink_t = core::ffi::c_ulong;
pub type __off_t = core::ffi::c_long;
pub type __off64_t = core::ffi::c_long;
pub type __pid_t = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = core::ffi::c_long;
pub type __rlim_t = core::ffi::c_ulong;
pub type __rlim64_t = core::ffi::c_ulong;
pub type __id_t = core::ffi::c_uint;
pub type __time_t = core::ffi::c_long;
pub type __useconds_t = core::ffi::c_uint;
pub type __suseconds_t = core::ffi::c_long;
pub type __suseconds64_t = core::ffi::c_long;
pub type __daddr_t = core::ffi::c_int;
pub type __key_t = core::ffi::c_int;
pub type __clockid_t = core::ffi::c_int;
pub type __timer_t = *mut core::ffi::c_void;
pub type __blksize_t = core::ffi::c_long;
pub type __blkcnt_t = core::ffi::c_long;
pub type __blkcnt64_t = core::ffi::c_long;
pub type __fsblkcnt_t = core::ffi::c_ulong;
pub type __fsblkcnt64_t = core::ffi::c_ulong;
pub type __fsfilcnt_t = core::ffi::c_ulong;
pub type __fsfilcnt64_t = core::ffi::c_ulong;
pub type __fsword_t = core::ffi::c_long;
pub type __ssize_t = core::ffi::c_long;
pub type __syscall_slong_t = core::ffi::c_long;
pub type __syscall_ulong_t = core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut core::ffi::c_char;
pub type __intptr_t = core::ffi::c_long;
pub type __socklen_t = core::ffi::c_uint;
pub type __sig_atomic_t = core::ffi::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino64_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off64_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = core::ffi::c_ulong;
pub type ushort = core::ffi::c_ushort;
pub type uint = core::ffi::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [core::ffi::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::core::mem::MaybeUninit<__sigset_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::core::mem::MaybeUninit<timeval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::core::mem::MaybeUninit<timespec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __fd_mask = core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::core::mem::MaybeUninit<fd_set> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt64_t;
pub type fsblkcnt_t = __fsblkcnt64_t;
pub type fsfilcnt_t = __fsfilcnt64_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: core::ffi::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: core::ffi::c_uint,
    pub __high: core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for __atomic_wide_counter {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "__atomic_wide_counter {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_list> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_slist> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: core::ffi::c_int,
    pub __count: core::ffi::c_uint,
    pub __owner: core::ffi::c_int,
    pub __nusers: core::ffi::c_uint,
    pub __kind: core::ffi::c_int,
    pub __spins: core::ffi::c_short,
    pub __elision: core::ffi::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_mutex_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: core::ffi::c_uint,
    pub __writers: core::ffi::c_uint,
    pub __wrphase_futex: core::ffi::c_uint,
    pub __writers_futex: core::ffi::c_uint,
    pub __pad3: core::ffi::c_uint,
    pub __pad4: core::ffi::c_uint,
    pub __cur_writer: core::ffi::c_int,
    pub __shared: core::ffi::c_int,
    pub __rwelision: core::ffi::c_schar,
    pub __pad1: [core::ffi::c_uchar; 7usize],
    pub __pad2: core::ffi::c_ulong,
    pub __flags: core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [core::ffi::c_uint; 2usize],
    pub __g_size: [core::ffi::c_uint; 2usize],
    pub __g1_orig_size: core::ffi::c_uint,
    pub __wrefs: core::ffi::c_uint,
    pub __g_signals: [core::ffi::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for __pthread_cond_s {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "__pthread_cond_s {{ __wseq: {:?}, __g1_start: {:?}, __g_refs: {:?}, __g_size: {:?}, __g1_orig_size: {:?}, __wrefs: {:?}, __g_signals: {:?} }}" , self . __wseq , self . __g1_start , self . __g_refs , self . __g_size , self . __g1_orig_size , self . __wrefs , self . __g_signals)
    }
}
pub type __tss_t = core::ffi::c_uint;
pub type __thrd_t = core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __once_flag {
    pub __data: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::core::mem::MaybeUninit<__once_flag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::core::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = core::ffi::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [core::ffi::c_char; 4usize],
    pub __align: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutexattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for pthread_mutexattr_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "pthread_mutexattr_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [core::ffi::c_char; 4usize],
    pub __align: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_condattr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for pthread_condattr_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "pthread_condattr_t {{ union }}")
    }
}
pub type pthread_key_t = core::ffi::c_uint;
pub type pthread_once_t = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [core::ffi::c_char; 56usize],
    pub __align: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_attr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for pthread_attr_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "pthread_attr_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [core::ffi::c_char; 40usize],
    pub __align: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutex_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for pthread_mutex_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "pthread_mutex_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [core::ffi::c_char; 48usize],
    pub __align: core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_cond_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for pthread_cond_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "pthread_cond_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [core::ffi::c_char; 56usize],
    pub __align: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlock_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for pthread_rwlock_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "pthread_rwlock_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [core::ffi::c_char; 8usize],
    pub __align: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlockattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for pthread_rwlockattr_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "pthread_rwlockattr_t {{ union }}")
    }
}
pub type pthread_spinlock_t = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [core::ffi::c_char; 32usize],
    pub __align: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrier_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for pthread_barrier_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "pthread_barrier_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [core::ffi::c_char; 4usize],
    pub __align: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrierattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for pthread_barrierattr_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "pthread_barrierattr_t {{ union }}")
    }
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: core::ffi::c_int,
    pub rem: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::core::mem::MaybeUninit<div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: core::ffi::c_long,
    pub rem: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: core::ffi::c_longlong,
    pub rem: core::ffi::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const core::ffi::c_ushort,
    pub __ctype_tolower: *const core::ffi::c_int,
    pub __ctype_toupper: *const core::ffi::c_int,
    pub __names: [*const core::ffi::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::core::mem::MaybeUninit<__locale_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: core::ffi::c_int,
    pub rand_deg: core::ffi::c_int,
    pub rand_sep: core::ffi::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::core::mem::MaybeUninit<random_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::core::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
impl Default for random_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drand48_data {
    pub __x: [core::ffi::c_ushort; 3usize],
    pub __old_x: [core::ffi::c_ushort; 3usize],
    pub __c: core::ffi::c_ushort,
    pub __init: core::ffi::c_ushort,
    pub __a: core::ffi::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::core::mem::MaybeUninit<drand48_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::core::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: core::ffi::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: core::ffi::c_uint,
    pub __wchb: [core::ffi::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for __mbstate_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "__mbstate_t__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "__mbstate_t {{ __count: {:?}, __value: {:?} }}",
            self.__count, self.__value
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _G_fpos_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "_G_fpos_t {{ __pos: {:?}, __state: {:?} }}",
            self.__pos, self.__state
        )
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos64_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _G_fpos64_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "_G_fpos64_t {{ __pos: {:?}, __state: {:?} }}",
            self.__pos, self.__state
        )
    }
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: core::ffi::c_int,
    pub _IO_read_ptr: *mut core::ffi::c_char,
    pub _IO_read_end: *mut core::ffi::c_char,
    pub _IO_read_base: *mut core::ffi::c_char,
    pub _IO_write_base: *mut core::ffi::c_char,
    pub _IO_write_ptr: *mut core::ffi::c_char,
    pub _IO_write_end: *mut core::ffi::c_char,
    pub _IO_buf_base: *mut core::ffi::c_char,
    pub _IO_buf_end: *mut core::ffi::c_char,
    pub _IO_save_base: *mut core::ffi::c_char,
    pub _IO_backup_base: *mut core::ffi::c_char,
    pub _IO_save_end: *mut core::ffi::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: core::ffi::c_int,
    pub _flags2: core::ffi::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: core::ffi::c_ushort,
    pub _vtable_offset: core::ffi::c_schar,
    pub _shortbuf: [core::ffi::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut core::ffi::c_void,
    pub __pad5: usize,
    pub _mode: core::ffi::c_int,
    pub _unused2: [core::ffi::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_FILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cookie_read_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut core::ffi::c_void,
        __buf: *mut core::ffi::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut core::ffi::c_void,
        __buf: *const core::ffi::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut core::ffi::c_void,
        __pos: *mut __off64_t,
        __w: core::ffi::c_int,
    ) -> core::ffi::c_int,
>;
pub type cookie_close_function_t = ::core::option::Option<
    unsafe extern "C" fn(__cookie: *mut core::ffi::c_void) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_cookie_io_functions_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_cookie_io_functions_t),
            "::",
            stringify!(close)
        )
    );
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type socklen_t = __socklen_t;
pub const _PC_LINK_MAX: _bindgen_ty_1 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_1 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_1 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_1 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_1 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_1 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_1 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_1 = 7;
pub const _PC_VDISABLE: _bindgen_ty_1 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_1 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_1 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_1 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_1 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_1 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_1 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_1 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_1 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_1 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_1 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_1 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_1 = 20;
pub type _bindgen_ty_1 = core::ffi::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_2 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_2 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_2 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_2 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_2 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_2 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_2 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_2 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_2 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_2 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_2 = 10;
pub const _SC_TIMERS: _bindgen_ty_2 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_2 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_2 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_2 = 14;
pub const _SC_FSYNC: _bindgen_ty_2 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_2 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_2 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_2 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_2 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_2 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_2 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_2 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_2 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_2 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_2 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_2 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_2 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_2 = 28;
pub const _SC_VERSION: _bindgen_ty_2 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_2 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_2 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_2 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_2 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_2 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_2 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_2 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_2 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_2 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_2 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_2 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_2 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_2 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_2 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_2 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_2 = 45;
pub const _SC_2_VERSION: _bindgen_ty_2 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_2 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_2 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_2 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_2 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_2 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_2 = 52;
pub const _SC_PII: _bindgen_ty_2 = 53;
pub const _SC_PII_XTI: _bindgen_ty_2 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_2 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_2 = 56;
pub const _SC_PII_OSI: _bindgen_ty_2 = 57;
pub const _SC_POLL: _bindgen_ty_2 = 58;
pub const _SC_SELECT: _bindgen_ty_2 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_2 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_2 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_2 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_2 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_2 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_2 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_2 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_2 = 66;
pub const _SC_THREADS: _bindgen_ty_2 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_2 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_2 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_2 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_2 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_2 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_2 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_2 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_2 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_2 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_2 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_2 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_2 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_2 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_2 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_2 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_2 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_2 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_2 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_2 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_2 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_2 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_2 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_2 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_2 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_2 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_2 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_2 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_2 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_2 = 96;
pub const _SC_2_UPE: _bindgen_ty_2 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_2 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_2 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_2 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_2 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_2 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_2 = 103;
pub const _SC_INT_MAX: _bindgen_ty_2 = 104;
pub const _SC_INT_MIN: _bindgen_ty_2 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_2 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_2 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_2 = 108;
pub const _SC_NZERO: _bindgen_ty_2 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_2 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_2 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_2 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_2 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_2 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_2 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_2 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_2 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_2 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_2 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_2 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_2 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_2 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_2 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_2 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_2 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_2 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_2 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_2 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_2 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_2 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_2 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_2 = 132;
pub const _SC_BARRIERS: _bindgen_ty_2 = 133;
pub const _SC_BASE: _bindgen_ty_2 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_2 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_2 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_2 = 137;
pub const _SC_CPUTIME: _bindgen_ty_2 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_2 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_2 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_2 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_2 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_2 = 143;
pub const _SC_FIFO: _bindgen_ty_2 = 144;
pub const _SC_PIPE: _bindgen_ty_2 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_2 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_2 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_2 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_2 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_2 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_2 = 151;
pub const _SC_NETWORKING: _bindgen_ty_2 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_2 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_2 = 154;
pub const _SC_REGEXP: _bindgen_ty_2 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_2 = 156;
pub const _SC_SHELL: _bindgen_ty_2 = 157;
pub const _SC_SIGNALS: _bindgen_ty_2 = 158;
pub const _SC_SPAWN: _bindgen_ty_2 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_2 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_2 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_2 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_2 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_2 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_2 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_2 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_2 = 167;
pub const _SC_2_PBS: _bindgen_ty_2 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_2 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_2 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_2 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_2 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_2 = 173;
pub const _SC_STREAMS: _bindgen_ty_2 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_2 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_2 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_2 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_2 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_2 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_2 = 180;
pub const _SC_TRACE: _bindgen_ty_2 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_2 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_2 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_2 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_2 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_2 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_2 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_2 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_2 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_2 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_2 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_2 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_2 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_2 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_2 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_2 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_2 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_2 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_2 = 199;
pub const _SC_IPV6: _bindgen_ty_2 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_2 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_2 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_2 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_2 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_2 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_2 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_2 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_2 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_2 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_2 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_2 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_2 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_2 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_2 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_2 = 250;
pub type _bindgen_ty_2 = core::ffi::c_uint;
pub const _CS_PATH: _bindgen_ty_3 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_3 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_3 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_3 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_3 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_3 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_3 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_3 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_3 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_3 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_3 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_3 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_3 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_3 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_3 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_3 = 1149;
pub type _bindgen_ty_3 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timex {
    pub modes: core::ffi::c_uint,
    pub offset: __syscall_slong_t,
    pub freq: __syscall_slong_t,
    pub maxerror: __syscall_slong_t,
    pub esterror: __syscall_slong_t,
    pub status: core::ffi::c_int,
    pub constant: __syscall_slong_t,
    pub precision: __syscall_slong_t,
    pub tolerance: __syscall_slong_t,
    pub time: timeval,
    pub tick: __syscall_slong_t,
    pub ppsfreq: __syscall_slong_t,
    pub jitter: __syscall_slong_t,
    pub shift: core::ffi::c_int,
    pub stabil: __syscall_slong_t,
    pub jitcnt: __syscall_slong_t,
    pub calcnt: __syscall_slong_t,
    pub errcnt: __syscall_slong_t,
    pub stbcnt: __syscall_slong_t,
    pub tai: core::ffi::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize]>,
}
#[test]
fn bindgen_test_layout_timex() {
    const UNINIT: ::core::mem::MaybeUninit<timex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timex>(),
        208usize,
        concat!("Size of: ", stringify!(timex))
    );
    assert_eq!(
        ::core::mem::align_of::<timex>(),
        8usize,
        concat!("Alignment of ", stringify!(timex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(modes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxerror) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(maxerror)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).esterror) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(esterror)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).constant) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).precision) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(precision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tolerance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tolerance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tick) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ppsfreq) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(ppsfreq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jitter) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(jitter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shift) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stabil) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(stabil)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jitcnt) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(jitcnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calcnt) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(calcnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errcnt) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(errcnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stbcnt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(stbcnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tai) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(timex),
            "::",
            stringify!(tai)
        )
    );
}
impl Default for timex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: core::ffi::c_int,
    pub tm_min: core::ffi::c_int,
    pub tm_hour: core::ffi::c_int,
    pub tm_mday: core::ffi::c_int,
    pub tm_mon: core::ffi::c_int,
    pub tm_year: core::ffi::c_int,
    pub tm_wday: core::ffi::c_int,
    pub tm_yday: core::ffi::c_int,
    pub tm_isdst: core::ffi::c_int,
    pub tm_gmtoff: core::ffi::c_long,
    pub tm_zone: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::core::mem::MaybeUninit<tm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::core::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::core::mem::MaybeUninit<itimerspec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type error_t = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut core::ffi::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    const UNINIT: ::core::mem::MaybeUninit<iovec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::core::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const __pid_type_F_OWNER_TID: __pid_type = 0;
pub const __pid_type_F_OWNER_PID: __pid_type = 1;
pub const __pid_type_F_OWNER_PGRP: __pid_type = 2;
pub const __pid_type_F_OWNER_GID: __pid_type = 2;
pub type __pid_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct f_owner_ex {
    pub type_: __pid_type,
    pub pid: __pid_t,
}
#[test]
fn bindgen_test_layout_f_owner_ex() {
    const UNINIT: ::core::mem::MaybeUninit<f_owner_ex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<f_owner_ex>(),
        8usize,
        concat!("Size of: ", stringify!(f_owner_ex))
    );
    assert_eq!(
        ::core::mem::align_of::<f_owner_ex>(),
        4usize,
        concat!("Alignment of ", stringify!(f_owner_ex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(f_owner_ex),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(f_owner_ex),
            "::",
            stringify!(pid)
        )
    );
}
impl Default for f_owner_ex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct file_handle {
    pub handle_bytes: core::ffi::c_uint,
    pub handle_type: core::ffi::c_int,
    pub f_handle: __IncompleteArrayField<core::ffi::c_uchar>,
}
#[test]
fn bindgen_test_layout_file_handle() {
    const UNINIT: ::core::mem::MaybeUninit<file_handle> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<file_handle>(),
        8usize,
        concat!("Size of: ", stringify!(file_handle))
    );
    assert_eq!(
        ::core::mem::align_of::<file_handle>(),
        4usize,
        concat!("Alignment of ", stringify!(file_handle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle_bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(handle_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(handle_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(file_handle),
            "::",
            stringify!(f_handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: core::ffi::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    const UNINIT: ::core::mem::MaybeUninit<stat> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::core::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_atim) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_mtim) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_ctim) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__glibc_reserved) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct stat64 {
    pub st_dev: __dev_t,
    pub st_ino: __ino64_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: core::ffi::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt64_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat64() {
    const UNINIT: ::core::mem::MaybeUninit<stat64> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stat64>(),
        144usize,
        concat!("Size of: ", stringify!(stat64))
    );
    assert_eq!(
        ::core::mem::align_of::<stat64>(),
        8usize,
        concat!("Alignment of ", stringify!(stat64))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_atim) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_mtim) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).st_ctim) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__glibc_reserved) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat64),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct option {
    pub name: *const core::ffi::c_char,
    pub has_arg: core::ffi::c_int,
    pub flag: *mut core::ffi::c_int,
    pub val: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_option() {
    const UNINIT: ::core::mem::MaybeUninit<option> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<option>(),
        32usize,
        concat!("Size of: ", stringify!(option))
    );
    assert_eq!(
        ::core::mem::align_of::<option>(),
        8usize,
        concat!("Alignment of ", stringify!(option))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(option),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(option),
            "::",
            stringify!(has_arg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(option),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(option),
            "::",
            stringify!(val)
        )
    );
}
impl Default for option {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __s8 = core::ffi::c_schar;
pub type __u8 = core::ffi::c_uchar;
pub type __s16 = core::ffi::c_short;
pub type __u16 = core::ffi::c_ushort;
pub type __s32 = core::ffi::c_int;
pub type __u32 = core::ffi::c_uint;
pub type __s64 = core::ffi::c_longlong;
pub type __u64 = core::ffi::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [core::ffi::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::core::mem::MaybeUninit<__kernel_fd_set> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>;
pub type __kernel_key_t = core::ffi::c_int;
pub type __kernel_mqd_t = core::ffi::c_int;
pub type __kernel_old_uid_t = core::ffi::c_ushort;
pub type __kernel_old_gid_t = core::ffi::c_ushort;
pub type __kernel_old_dev_t = core::ffi::c_ulong;
pub type __kernel_long_t = core::ffi::c_long;
pub type __kernel_ulong_t = core::ffi::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = core::ffi::c_uint;
pub type __kernel_pid_t = core::ffi::c_int;
pub type __kernel_ipc_pid_t = core::ffi::c_int;
pub type __kernel_uid_t = core::ffi::c_uint;
pub type __kernel_gid_t = core::ffi::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = core::ffi::c_int;
pub type __kernel_uid32_t = core::ffi::c_uint;
pub type __kernel_gid32_t = core::ffi::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__kernel_fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = core::ffi::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = core::ffi::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = core::ffi::c_int;
pub type __kernel_clockid_t = core::ffi::c_int;
pub type __kernel_caddr_t = *mut core::ffi::c_char;
pub type __kernel_uid16_t = core::ffi::c_ushort;
pub type __kernel_gid16_t = core::ffi::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct statx_timestamp {
    pub tv_sec: __s64,
    pub tv_nsec: __u32,
    pub __reserved: __s32,
}
#[test]
fn bindgen_test_layout_statx_timestamp() {
    const UNINIT: ::core::mem::MaybeUninit<statx_timestamp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<statx_timestamp>(),
        16usize,
        concat!("Size of: ", stringify!(statx_timestamp))
    );
    assert_eq!(
        ::core::mem::align_of::<statx_timestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(statx_timestamp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(statx_timestamp),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(statx_timestamp),
            "::",
            stringify!(tv_nsec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__reserved) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(statx_timestamp),
            "::",
            stringify!(__reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct statx {
    pub stx_mask: __u32,
    pub stx_blksize: __u32,
    pub stx_attributes: __u64,
    pub stx_nlink: __u32,
    pub stx_uid: __u32,
    pub stx_gid: __u32,
    pub stx_mode: __u16,
    pub __spare0: [__u16; 1usize],
    pub stx_ino: __u64,
    pub stx_size: __u64,
    pub stx_blocks: __u64,
    pub stx_attributes_mask: __u64,
    pub stx_atime: statx_timestamp,
    pub stx_btime: statx_timestamp,
    pub stx_ctime: statx_timestamp,
    pub stx_mtime: statx_timestamp,
    pub stx_rdev_major: __u32,
    pub stx_rdev_minor: __u32,
    pub stx_dev_major: __u32,
    pub stx_dev_minor: __u32,
    pub stx_mnt_id: __u64,
    pub stx_dio_mem_align: __u32,
    pub stx_dio_offset_align: __u32,
    pub __spare3: [__u64; 12usize],
}
#[test]
fn bindgen_test_layout_statx() {
    const UNINIT: ::core::mem::MaybeUninit<statx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<statx>(),
        256usize,
        concat!("Size of: ", stringify!(statx))
    );
    assert_eq!(
        ::core::mem::align_of::<statx>(),
        8usize,
        concat!("Alignment of ", stringify!(statx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_blksize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_blksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_attributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_attributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_nlink) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_nlink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_uid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_gid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_gid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_mode) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__spare0) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(__spare0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_ino) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_ino)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_blocks) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_blocks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_attributes_mask) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_attributes_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_atime) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_atime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_btime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_btime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_ctime) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_ctime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_mtime) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_mtime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_rdev_major) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_rdev_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_rdev_minor) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_rdev_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_dev_major) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_dev_major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_dev_minor) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_dev_minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_mnt_id) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_mnt_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_dio_mem_align) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_dio_mem_align)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stx_dio_offset_align) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(stx_dio_offset_align)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__spare3) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(statx),
            "::",
            stringify!(__spare3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: core::ffi::c_int,
    pub tz_dsttime: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    const UNINIT: ::core::mem::MaybeUninit<timezone> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::core::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    const UNINIT: ::core::mem::MaybeUninit<itimerval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub use self::__itimer_which as __itimer_which_t;
pub type __jmp_buf = [core::ffi::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: core::ffi::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    const UNINIT: ::core::mem::MaybeUninit<__jmp_buf_tag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: core::ffi::c_int,
    pub sival_ptr: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::core::mem::MaybeUninit<sigval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::core::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for sigval {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "sigval {{ union }}")
    }
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: core::ffi::c_int,
    pub si_errno: core::ffi::c_int,
    pub si_code: core::ffi::c_int,
    pub __pad0: core::ffi::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [core::ffi::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: core::ffi::c_int,
    pub si_overrun: core::ffi::c_int,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_tid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_tid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_overrun) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_overrun)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_sigval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_sigval)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "siginfo_t__bindgen_ty_1__bindgen_ty_2 {{ si_tid: {:?}, si_overrun: {:?}, si_sigval: {:?} }}" , self . si_tid , self . si_overrun , self . si_sigval)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_sigval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_sigval)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "siginfo_t__bindgen_ty_1__bindgen_ty_3 {{ si_pid: {:?}, si_uid: {:?}, si_sigval: {:?} }}" , self . si_pid , self . si_uid , self . si_sigval)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: core::ffi::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_4> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_utime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_utime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_stime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut core::ffi::c_void,
    pub si_addr_lsb: core::ffi::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut core::ffi::c_void,
    pub _upper: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lower) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._upper) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._addr_bnd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._pkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_pkey)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {{ union }}"
        )
    }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::core::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_5> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_addr_lsb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_lsb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._bounds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_bounds)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "siginfo_t__bindgen_ty_1__bindgen_ty_5 {{ si_addr: {:?}, si_addr_lsb: {:?}, _bounds: {:?} }}" , self . si_addr , self . si_addr_lsb , self . _bounds)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: core::ffi::c_long,
    pub si_fd: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::core::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_6> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_fd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut core::ffi::c_void,
    pub _syscall: core::ffi::c_int,
    pub _arch: core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    const UNINIT: ::core::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_7> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._call_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._syscall) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._arch) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<siginfo_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._kill) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._timer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._rt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sigchld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sigfault) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sigpoll) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sigsys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
impl Default for siginfo_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for siginfo_t__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "siginfo_t__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    const UNINIT: ::core::mem::MaybeUninit<siginfo_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sifields) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(_sifields)
        )
    );
}
impl Default for siginfo_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for siginfo_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "siginfo_t {{ si_signo: {:?}, si_errno: {:?}, si_code: {:?}, __pad0: {:?}, _sifields: {:?} }}" , self . si_signo , self . si_errno , self . si_code , self . __pad0 , self . _sifields)
    }
}
pub const SI_ASYNCNL: _bindgen_ty_5 = -60;
pub const SI_DETHREAD: _bindgen_ty_5 = -7;
pub const SI_TKILL: _bindgen_ty_5 = -6;
pub const SI_SIGIO: _bindgen_ty_5 = -5;
pub const SI_ASYNCIO: _bindgen_ty_5 = -4;
pub const SI_MESGQ: _bindgen_ty_5 = -3;
pub const SI_TIMER: _bindgen_ty_5 = -2;
pub const SI_QUEUE: _bindgen_ty_5 = -1;
pub const SI_USER: _bindgen_ty_5 = 0;
pub const SI_KERNEL: _bindgen_ty_5 = 128;
pub type _bindgen_ty_5 = core::ffi::c_int;
pub const ILL_ILLOPC: _bindgen_ty_6 = 1;
pub const ILL_ILLOPN: _bindgen_ty_6 = 2;
pub const ILL_ILLADR: _bindgen_ty_6 = 3;
pub const ILL_ILLTRP: _bindgen_ty_6 = 4;
pub const ILL_PRVOPC: _bindgen_ty_6 = 5;
pub const ILL_PRVREG: _bindgen_ty_6 = 6;
pub const ILL_COPROC: _bindgen_ty_6 = 7;
pub const ILL_BADSTK: _bindgen_ty_6 = 8;
pub const ILL_BADIADDR: _bindgen_ty_6 = 9;
pub type _bindgen_ty_6 = core::ffi::c_uint;
pub const FPE_INTDIV: _bindgen_ty_7 = 1;
pub const FPE_INTOVF: _bindgen_ty_7 = 2;
pub const FPE_FLTDIV: _bindgen_ty_7 = 3;
pub const FPE_FLTOVF: _bindgen_ty_7 = 4;
pub const FPE_FLTUND: _bindgen_ty_7 = 5;
pub const FPE_FLTRES: _bindgen_ty_7 = 6;
pub const FPE_FLTINV: _bindgen_ty_7 = 7;
pub const FPE_FLTSUB: _bindgen_ty_7 = 8;
pub const FPE_FLTUNK: _bindgen_ty_7 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_7 = 15;
pub type _bindgen_ty_7 = core::ffi::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_8 = 1;
pub const SEGV_ACCERR: _bindgen_ty_8 = 2;
pub const SEGV_BNDERR: _bindgen_ty_8 = 3;
pub const SEGV_PKUERR: _bindgen_ty_8 = 4;
pub const SEGV_ACCADI: _bindgen_ty_8 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_8 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_8 = 7;
pub const SEGV_MTEAERR: _bindgen_ty_8 = 8;
pub const SEGV_MTESERR: _bindgen_ty_8 = 9;
pub type _bindgen_ty_8 = core::ffi::c_uint;
pub const BUS_ADRALN: _bindgen_ty_9 = 1;
pub const BUS_ADRERR: _bindgen_ty_9 = 2;
pub const BUS_OBJERR: _bindgen_ty_9 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_9 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_9 = 5;
pub type _bindgen_ty_9 = core::ffi::c_uint;
pub const TRAP_BRKPT: _bindgen_ty_10 = 1;
pub const TRAP_TRACE: _bindgen_ty_10 = 2;
pub const TRAP_BRANCH: _bindgen_ty_10 = 3;
pub const TRAP_HWBKPT: _bindgen_ty_10 = 4;
pub const TRAP_UNK: _bindgen_ty_10 = 5;
pub type _bindgen_ty_10 = core::ffi::c_uint;
pub const CLD_EXITED: _bindgen_ty_11 = 1;
pub const CLD_KILLED: _bindgen_ty_11 = 2;
pub const CLD_DUMPED: _bindgen_ty_11 = 3;
pub const CLD_TRAPPED: _bindgen_ty_11 = 4;
pub const CLD_STOPPED: _bindgen_ty_11 = 5;
pub const CLD_CONTINUED: _bindgen_ty_11 = 6;
pub type _bindgen_ty_11 = core::ffi::c_uint;
pub const POLL_IN: _bindgen_ty_12 = 1;
pub const POLL_OUT: _bindgen_ty_12 = 2;
pub const POLL_MSG: _bindgen_ty_12 = 3;
pub const POLL_ERR: _bindgen_ty_12 = 4;
pub const POLL_PRI: _bindgen_ty_12 = 5;
pub const POLL_HUP: _bindgen_ty_12 = 6;
pub type _bindgen_ty_12 = core::ffi::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: core::ffi::c_int,
    pub sigev_notify: core::ffi::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [core::ffi::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::core::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<sigevent__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._attribute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<sigevent__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._tid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sigev_thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
impl Default for sigevent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for sigevent__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "sigevent__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::core::mem::MaybeUninit<sigevent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::core::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sigev_un) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for sigevent {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "sigevent {{ sigev_value: {:?}, sigev_signo: {:?}, sigev_notify: {:?}, _sigev_un: {:?} }}" , self . sigev_value , self . sigev_signo , self . sigev_notify , self . _sigev_un)
    }
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_13 = 0;
pub const SIGEV_NONE: _bindgen_ty_13 = 1;
pub const SIGEV_THREAD: _bindgen_ty_13 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_13 = 4;
pub type _bindgen_ty_13 = core::ffi::c_uint;
pub type __sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>;
pub type sighandler_t = __sighandler_t;
pub type sig_t = __sighandler_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: core::ffi::c_int,
    pub sa_restorer: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: core::ffi::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut core::ffi::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<sigaction__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
impl Default for sigaction__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for sigaction__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "sigaction__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::core::mem::MaybeUninit<sigaction> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::core::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sigaction_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sa_restorer) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
impl Default for sigaction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for sigaction {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "sigaction {{ __sigaction_handler: {:?}, sa_mask: {:?}, sa_flags: {:?}, sa_restorer: {:?} }}" , self . __sigaction_handler , self . sa_mask , self . sa_flags , self . sa_restorer)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    const UNINIT: ::core::mem::MaybeUninit<_fpx_sw_bytes> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::core::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magic1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extended_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xstate_bv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xstate_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpreg {
    pub significand: [core::ffi::c_ushort; 4usize],
    pub exponent: core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    const UNINIT: ::core::mem::MaybeUninit<_fpreg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::core::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).significand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [core::ffi::c_ushort; 4usize],
    pub exponent: core::ffi::c_ushort,
    pub __glibc_reserved1: [core::ffi::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    const UNINIT: ::core::mem::MaybeUninit<_fpxreg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::core::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).significand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    const UNINIT: ::core::mem::MaybeUninit<_xmmreg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::core::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    const UNINIT: ::core::mem::MaybeUninit<_fpstate> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate))
    );
    assert_eq!(
        ::core::mem::align_of::<_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cwd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).swd) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftw) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fop) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rdp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mxcsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mxcr_mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._st) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._xmm) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: core::ffi::c_ushort,
    pub gs: core::ffi::c_ushort,
    pub fs: core::ffi::c_ushort,
    pub __pad0: core::ffi::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<sigcontext__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__fpstate_word) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(__fpstate_word)
        )
    );
}
impl Default for sigcontext__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for sigcontext__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "sigcontext__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_sigcontext() {
    const UNINIT: ::core::mem::MaybeUninit<sigcontext> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sigcontext>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::core::mem::align_of::<sigcontext>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r9) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r10) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r11) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r12) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r13) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r14) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r15) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rdi) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsi) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rbp) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rbx) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rdx) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rax) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcx) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsp) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eflags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cs) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gs) as usize - ptr as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trapno) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oldmask) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cr2) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__reserved1) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved1)
        )
    );
}
impl Default for sigcontext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for sigcontext {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "sigcontext {{ r8: {:?}, r9: {:?}, r10: {:?}, r11: {:?}, r12: {:?}, r13: {:?}, r14: {:?}, r15: {:?}, rdi: {:?}, rsi: {:?}, rbp: {:?}, rbx: {:?}, rdx: {:?}, rax: {:?}, rcx: {:?}, rsp: {:?}, rip: {:?}, eflags: {:?}, cs: {:?}, gs: {:?}, fs: {:?}, __pad0: {:?}, err: {:?}, trapno: {:?}, oldmask: {:?}, cr2: {:?}, __bindgen_anon_1: {:?}, __reserved1: {:?} }}" , self . r8 , self . r9 , self . r10 , self . r11 , self . r12 , self . r13 , self . r14 , self . r15 , self . rdi , self . rsi , self . rbp , self . rbx , self . rdx , self . rax , self . rcx , self . rsp , self . rip , self . eflags , self . cs , self . gs , self . fs , self . __pad0 , self . err , self . trapno , self . oldmask , self . cr2 , self . __bindgen_anon_1 , self . __reserved1)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    const UNINIT: ::core::mem::MaybeUninit<_xsave_hdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_xsave_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<_xsave_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xstate_bv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__glibc_reserved2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    const UNINIT: ::core::mem::MaybeUninit<_ymmh_state> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::core::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ymmh_space) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
impl Default for _ymmh_state {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    const UNINIT: ::core::mem::MaybeUninit<_xstate> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::core::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xstate_hdr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ymmh) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
impl Default for _xstate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut core::ffi::c_void,
    pub ss_flags: core::ffi::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_stack_t() {
    const UNINIT: ::core::mem::MaybeUninit<stack_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stack_t>(),
        24usize,
        concat!("Size of: ", stringify!(stack_t))
    );
    assert_eq!(
        ::core::mem::align_of::<stack_t>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_size)
        )
    );
}
impl Default for stack_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type greg_t = core::ffi::c_longlong;
pub type gregset_t = [greg_t; 23usize];
pub const REG_R8: _bindgen_ty_14 = 0;
pub const REG_R9: _bindgen_ty_14 = 1;
pub const REG_R10: _bindgen_ty_14 = 2;
pub const REG_R11: _bindgen_ty_14 = 3;
pub const REG_R12: _bindgen_ty_14 = 4;
pub const REG_R13: _bindgen_ty_14 = 5;
pub const REG_R14: _bindgen_ty_14 = 6;
pub const REG_R15: _bindgen_ty_14 = 7;
pub const REG_RDI: _bindgen_ty_14 = 8;
pub const REG_RSI: _bindgen_ty_14 = 9;
pub const REG_RBP: _bindgen_ty_14 = 10;
pub const REG_RBX: _bindgen_ty_14 = 11;
pub const REG_RDX: _bindgen_ty_14 = 12;
pub const REG_RAX: _bindgen_ty_14 = 13;
pub const REG_RCX: _bindgen_ty_14 = 14;
pub const REG_RSP: _bindgen_ty_14 = 15;
pub const REG_RIP: _bindgen_ty_14 = 16;
pub const REG_EFL: _bindgen_ty_14 = 17;
pub const REG_CSGSFS: _bindgen_ty_14 = 18;
pub const REG_ERR: _bindgen_ty_14 = 19;
pub const REG_TRAPNO: _bindgen_ty_14 = 20;
pub const REG_OLDMASK: _bindgen_ty_14 = 21;
pub const REG_CR2: _bindgen_ty_14 = 22;
pub type _bindgen_ty_14 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [core::ffi::c_ushort; 4usize],
    pub exponent: core::ffi::c_ushort,
    pub __glibc_reserved1: [core::ffi::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    const UNINIT: ::core::mem::MaybeUninit<_libc_fpxreg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_libc_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        ::core::mem::align_of::<_libc_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).significand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    const UNINIT: ::core::mem::MaybeUninit<_libc_xmmreg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_libc_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        ::core::mem::align_of::<_libc_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    const UNINIT: ::core::mem::MaybeUninit<_libc_fpstate> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_libc_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        ::core::mem::align_of::<_libc_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cwd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).swd) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftw) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fop) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rdp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mxcsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mxcr_mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._st) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._xmm) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [core::ffi::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    const UNINIT: ::core::mem::MaybeUninit<mcontext_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mcontext_t>(),
        256usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mcontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gregs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fpregs) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__reserved1) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(__reserved1)
        )
    );
}
impl Default for mcontext_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: core::ffi::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [core::ffi::c_ulonglong; 4usize],
}
#[test]
fn bindgen_test_layout_ucontext_t() {
    const UNINIT: ::core::mem::MaybeUninit<ucontext_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ucontext_t>(),
        968usize,
        concat!("Size of: ", stringify!(ucontext_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ucontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uc_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__fpregs_mem) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__fpregs_mem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ssp) as usize - ptr as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__ssp)
        )
    );
}
impl Default for ucontext_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const SS_ONSTACK: _bindgen_ty_15 = 1;
pub const SS_DISABLE: _bindgen_ty_15 = 2;
pub type _bindgen_ty_15 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut core::ffi::c_void,
    pub ss_onstack: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::core::mem::MaybeUninit<sigstack> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::core::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
impl Default for sigstack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub const idtype_t_P_PIDFD: idtype_t = 3;
pub type idtype_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    _unused: [u8; 0],
}
pub type gint8 = core::ffi::c_schar;
pub type guint8 = core::ffi::c_uchar;
pub type gint16 = core::ffi::c_short;
pub type guint16 = core::ffi::c_ushort;
pub type gint32 = core::ffi::c_int;
pub type guint32 = core::ffi::c_uint;
pub type gint64 = core::ffi::c_long;
pub type guint64 = core::ffi::c_ulong;
pub type gssize = core::ffi::c_long;
pub type gsize = core::ffi::c_ulong;
pub type goffset = gint64;
pub type gintptr = core::ffi::c_long;
pub type guintptr = core::ffi::c_ulong;
pub type GPid = core::ffi::c_int;
pub type gchar = core::ffi::c_char;
pub type gshort = core::ffi::c_short;
pub type glong = core::ffi::c_long;
pub type gint = core::ffi::c_int;
pub type gboolean = gint;
pub type guchar = core::ffi::c_uchar;
pub type gushort = core::ffi::c_ushort;
pub type gulong = core::ffi::c_ulong;
pub type guint = core::ffi::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut core::ffi::c_void;
pub type gconstpointer = *const core::ffi::c_void;
pub type GCompareFunc =
    ::core::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::core::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::core::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
pub type GEqualFuncFull = ::core::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gboolean,
>;
pub type GDestroyNotify = ::core::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::core::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::core::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::core::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
pub type GCopyFunc = ::core::option::Option<
    unsafe extern "C" fn(src: gconstpointer, user_data: gpointer) -> gpointer,
>;
pub type GFreeFunc = ::core::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GTranslateFunc = ::core::option::Option<
    unsafe extern "C" fn(str_: *const gchar, user_data: gpointer) -> *const gchar,
>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__GFloatIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
}
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::core::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::core::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::core::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GFloatIEEE754() {
    const UNINIT: ::core::mem::MaybeUninit<_GFloatIEEE754> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        ::core::mem::align_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mpn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
impl Default for _GFloatIEEE754 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GFloatIEEE754 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_GFloatIEEE754 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
}
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::core::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::core::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::core::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::core::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754() {
    const UNINIT: ::core::mem::MaybeUninit<_GDoubleIEEE754> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        ::core::mem::align_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mpn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
impl Default for _GDoubleIEEE754 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GDoubleIEEE754 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_GDoubleIEEE754 {{ union }}")
    }
}
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[test]
fn bindgen_test_layout__GTimeVal() {
    const UNINIT: ::core::mem::MaybeUninit<_GTimeVal> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GTimeVal>(),
        16usize,
        concat!("Size of: ", stringify!(_GTimeVal))
    );
    assert_eq!(
        ::core::mem::align_of::<_GTimeVal>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTimeVal))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type grefcount = gint;
pub type gatomicrefcount = gint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GArray() {
    const UNINIT: ::core::mem::MaybeUninit<_GArray> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GArray))
    );
    assert_eq!(
        ::core::mem::align_of::<_GArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GArray))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(len)
        )
    );
}
impl Default for _GArray {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GByteArray() {
    const UNINIT: ::core::mem::MaybeUninit<_GByteArray> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GByteArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GByteArray))
    );
    assert_eq!(
        ::core::mem::align_of::<_GByteArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GByteArray))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(len)
        )
    );
}
impl Default for _GByteArray {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GPtrArray() {
    const UNINIT: ::core::mem::MaybeUninit<_GPtrArray> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GPtrArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GPtrArray))
    );
    assert_eq!(
        ::core::mem::align_of::<_GPtrArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPtrArray))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(pdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(len)
        )
    );
}
impl Default for _GPtrArray {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GQuark = guint32;
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    const UNINIT: ::core::mem::MaybeUninit<_GError> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GError>(),
        16usize,
        concat!("Size of: ", stringify!(_GError))
    );
    assert_eq!(
        ::core::mem::align_of::<_GError>(),
        8usize,
        concat!("Alignment of ", stringify!(_GError))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(message)
        )
    );
}
impl Default for _GError {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GErrorInitFunc = ::core::option::Option<unsafe extern "C" fn(error: *mut GError)>;
pub type GErrorCopyFunc =
    ::core::option::Option<unsafe extern "C" fn(src_error: *const GError, dest_error: *mut GError)>;
pub type GErrorClearFunc = ::core::option::Option<unsafe extern "C" fn(error: *mut GError)>;
pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const GUserDirectory_G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const GUserDirectory_G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const GUserDirectory_G_USER_N_DIRECTORIES: GUserDirectory = 8;
pub type GUserDirectory = core::ffi::c_uint;
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[test]
fn bindgen_test_layout__GDebugKey() {
    const UNINIT: ::core::mem::MaybeUninit<_GDebugKey> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GDebugKey>(),
        16usize,
        concat!("Size of: ", stringify!(_GDebugKey))
    );
    assert_eq!(
        ::core::mem::align_of::<_GDebugKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugKey))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(value)
        )
    );
}
impl Default for _GDebugKey {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub const GFormatSizeFlags_G_FORMAT_SIZE_BITS: GFormatSizeFlags = 4;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_VALUE: GFormatSizeFlags = 8;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_UNIT: GFormatSizeFlags = 16;
pub type GFormatSizeFlags = core::ffi::c_uint;
pub type GVoidFunc = ::core::option::Option<unsafe extern "C" fn()>;
pub const GThreadError_G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = core::ffi::c_uint;
pub type GThreadFunc =
    ::core::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GMutex() {
    const UNINIT: ::core::mem::MaybeUninit<_GMutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GMutex>(),
        8usize,
        concat!("Size of: ", stringify!(_GMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<_GMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(i)
        )
    );
}
impl Default for _GMutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GMutex {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_GMutex {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRWLock() {
    const UNINIT: ::core::mem::MaybeUninit<_GRWLock> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GRWLock>(),
        16usize,
        concat!("Size of: ", stringify!(_GRWLock))
    );
    assert_eq!(
        ::core::mem::align_of::<_GRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRWLock))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(i)
        )
    );
}
impl Default for _GRWLock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GCond() {
    const UNINIT: ::core::mem::MaybeUninit<_GCond> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GCond>(),
        16usize,
        concat!("Size of: ", stringify!(_GCond))
    );
    assert_eq!(
        ::core::mem::align_of::<_GCond>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCond))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(i))
    );
}
impl Default for _GCond {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRecMutex() {
    const UNINIT: ::core::mem::MaybeUninit<_GRecMutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GRecMutex>(),
        16usize,
        concat!("Size of: ", stringify!(_GRecMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<_GRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRecMutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(i)
        )
    );
}
impl Default for _GRecMutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GPrivate() {
    const UNINIT: ::core::mem::MaybeUninit<_GPrivate> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GPrivate>(),
        32usize,
        concat!("Size of: ", stringify!(_GPrivate))
    );
    assert_eq!(
        ::core::mem::align_of::<_GPrivate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPrivate))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).future) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(future)
        )
    );
}
impl Default for _GPrivate {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const GOnceStatus_G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const GOnceStatus_G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[test]
fn bindgen_test_layout__GOnce() {
    const UNINIT: ::core::mem::MaybeUninit<_GOnce> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GOnce>(),
        16usize,
        concat!("Size of: ", stringify!(_GOnce))
    );
    assert_eq!(
        ::core::mem::align_of::<_GOnce>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOnce))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(retval)
        )
    );
}
impl Default for _GOnce {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GMutexLocker = core::ffi::c_void;
pub type GRecMutexLocker = core::ffi::c_void;
pub type GRWLockWriterLocker = core::ffi::c_void;
pub type GRWLockReaderLocker = core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const GTimeType_G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const GTimeType_G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const GTimeType_G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
pub type GTimeType = core::ffi::c_uint;
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
pub type GDateTime = _GDateTime;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
pub type GBookmarkFileError = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
pub type GBookmarkFile = _GBookmarkFile;
pub const GChecksumType_G_CHECKSUM_MD5: GChecksumType = 0;
pub const GChecksumType_G_CHECKSUM_SHA1: GChecksumType = 1;
pub const GChecksumType_G_CHECKSUM_SHA256: GChecksumType = 2;
pub const GChecksumType_G_CHECKSUM_SHA512: GChecksumType = 3;
pub const GChecksumType_G_CHECKSUM_SHA384: GChecksumType = 4;
pub type GChecksumType = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
pub type GChecksum = _GChecksum;
pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const GConvertError_G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const GConvertError_G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
pub const GConvertError_G_CONVERT_ERROR_EMBEDDED_NUL: GConvertError = 7;
pub type GConvertError = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
pub type GIConv = *mut _GIConv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::core::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
pub type GDuplicateFunc =
    ::core::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateDMY_G_DATE_DAY: GDateDMY = 0;
pub const GDateDMY_G_DATE_MONTH: GDateDMY = 1;
pub const GDateDMY_G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = core::ffi::c_uint;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = core::ffi::c_uint;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__GDate() {
    assert_eq!(
        ::core::mem::size_of::<_GDate>(),
        8usize,
        concat!("Size of: ", stringify!(_GDate))
    );
    assert_eq!(
        ::core::mem::align_of::<_GDate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDate))
    );
}
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::core::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::core::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::core::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::core::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::core::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::core::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino64_t,
    pub d_off: __off64_t,
    pub d_reclen: core::ffi::c_ushort,
    pub d_type: core::ffi::c_uchar,
    pub d_name: [core::ffi::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    const UNINIT: ::core::mem::MaybeUninit<dirent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<dirent>(),
        280usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::core::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_ino) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_off) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_off)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_reclen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_name) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
impl Default for dirent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent64 {
    pub d_ino: __ino64_t,
    pub d_off: __off64_t,
    pub d_reclen: core::ffi::c_ushort,
    pub d_type: core::ffi::c_uchar,
    pub d_name: [core::ffi::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent64() {
    const UNINIT: ::core::mem::MaybeUninit<dirent64> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<dirent64>(),
        280usize,
        concat!("Size of: ", stringify!(dirent64))
    );
    assert_eq!(
        ::core::mem::align_of::<dirent64>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent64))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_ino) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent64),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_off) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent64),
            "::",
            stringify!(d_off)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_reclen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent64),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent64),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_name) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent64),
            "::",
            stringify!(d_name)
        )
    );
}
impl Default for dirent64 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DT_UNKNOWN: _bindgen_ty_16 = 0;
pub const DT_FIFO: _bindgen_ty_16 = 1;
pub const DT_CHR: _bindgen_ty_16 = 2;
pub const DT_DIR: _bindgen_ty_16 = 4;
pub const DT_BLK: _bindgen_ty_16 = 6;
pub const DT_REG: _bindgen_ty_16 = 8;
pub const DT_LNK: _bindgen_ty_16 = 10;
pub const DT_SOCK: _bindgen_ty_16 = 12;
pub const DT_WHT: _bindgen_ty_16 = 14;
pub type _bindgen_ty_16 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
pub const GFileError_G_FILE_ERROR_EXIST: GFileError = 0;
pub const GFileError_G_FILE_ERROR_ISDIR: GFileError = 1;
pub const GFileError_G_FILE_ERROR_ACCES: GFileError = 2;
pub const GFileError_G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const GFileError_G_FILE_ERROR_NOENT: GFileError = 4;
pub const GFileError_G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const GFileError_G_FILE_ERROR_NXIO: GFileError = 6;
pub const GFileError_G_FILE_ERROR_NODEV: GFileError = 7;
pub const GFileError_G_FILE_ERROR_ROFS: GFileError = 8;
pub const GFileError_G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const GFileError_G_FILE_ERROR_FAULT: GFileError = 10;
pub const GFileError_G_FILE_ERROR_LOOP: GFileError = 11;
pub const GFileError_G_FILE_ERROR_NOSPC: GFileError = 12;
pub const GFileError_G_FILE_ERROR_NOMEM: GFileError = 13;
pub const GFileError_G_FILE_ERROR_MFILE: GFileError = 14;
pub const GFileError_G_FILE_ERROR_NFILE: GFileError = 15;
pub const GFileError_G_FILE_ERROR_BADF: GFileError = 16;
pub const GFileError_G_FILE_ERROR_INVAL: GFileError = 17;
pub const GFileError_G_FILE_ERROR_PIPE: GFileError = 18;
pub const GFileError_G_FILE_ERROR_AGAIN: GFileError = 19;
pub const GFileError_G_FILE_ERROR_INTR: GFileError = 20;
pub const GFileError_G_FILE_ERROR_IO: GFileError = 21;
pub const GFileError_G_FILE_ERROR_PERM: GFileError = 22;
pub const GFileError_G_FILE_ERROR_NOSYS: GFileError = 23;
pub const GFileError_G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = core::ffi::c_uint;
pub const GFileTest_G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const GFileTest_G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const GFileTest_G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const GFileTest_G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = core::ffi::c_uint;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_NONE: GFileSetContentsFlags = 0;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_CONSISTENT: GFileSetContentsFlags = 1;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_DURABLE: GFileSetContentsFlags = 2;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_ONLY_EXISTING: GFileSetContentsFlags = 4;
pub type GFileSetContentsFlags = core::ffi::c_uint;
pub type GMemVTable = _GMemVTable;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::core::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::core::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::core::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::core::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::core::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::core::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[test]
fn bindgen_test_layout__GMemVTable() {
    const UNINIT: ::core::mem::MaybeUninit<_GMemVTable> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GMemVTable>(),
        48usize,
        concat!("Size of: ", stringify!(_GMemVTable))
    );
    assert_eq!(
        ::core::mem::align_of::<_GMemVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemVTable))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).malloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).realloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).calloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(calloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).try_malloc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_malloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).try_realloc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_realloc)
        )
    );
}
pub type GNode = _GNode;
pub const GTraverseFlags_G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const GTraverseFlags_G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = core::ffi::c_uint;
pub const GTraverseType_G_IN_ORDER: GTraverseType = 0;
pub const GTraverseType_G_PRE_ORDER: GTraverseType = 1;
pub const GTraverseType_G_POST_ORDER: GTraverseType = 2;
pub const GTraverseType_G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = core::ffi::c_uint;
pub type GNodeTraverseFunc =
    ::core::option::Option<unsafe extern "C" fn(node: *mut GNode, user_data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::core::option::Option<unsafe extern "C" fn(node: *mut GNode, user_data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[test]
fn bindgen_test_layout__GNode() {
    const UNINIT: ::core::mem::MaybeUninit<_GNode> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GNode>(),
        40usize,
        concat!("Size of: ", stringify!(_GNode))
    );
    assert_eq!(
        ::core::mem::align_of::<_GNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNode))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(children)
        )
    );
}
impl Default for _GNode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    const UNINIT: ::core::mem::MaybeUninit<_GList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::core::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
impl Default for _GList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::core::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: core::ffi::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[test]
fn bindgen_test_layout__GHashTableIter() {
    const UNINIT: ::core::mem::MaybeUninit<_GHashTableIter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GHashTableIter>(),
        40usize,
        concat!("Size of: ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        ::core::mem::align_of::<_GHashTableIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy4) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy5) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy6) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy6)
        )
    );
}
impl Default for _GHashTableIter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
pub type GHmac = _GHmac;
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::core::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::core::option::Option<unsafe extern "C" fn(hook: *mut GHook, user_data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::core::option::Option<unsafe extern "C" fn(hook: *mut GHook, user_data: gpointer)>;
pub type GHookCheckMarshaller =
    ::core::option::Option<unsafe extern "C" fn(hook: *mut GHook, user_data: gpointer) -> gboolean>;
pub type GHookFunc = ::core::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::core::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::core::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const GHookFlagMask_G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GHookList() {
    const UNINIT: ::core::mem::MaybeUninit<_GHookList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GHookList>(),
        56usize,
        concat!("Size of: ", stringify!(_GHookList))
    );
    assert_eq!(
        ::core::mem::align_of::<_GHookList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHookList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seq_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(seq_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hooks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(hooks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).finalize_hook) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(finalize_hook)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy)
        )
    );
}
impl Default for _GHookList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::core::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::core::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[test]
fn bindgen_test_layout__GHook() {
    const UNINIT: ::core::mem::MaybeUninit<_GHook> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GHook>(),
        64usize,
        concat!("Size of: ", stringify!(_GHook))
    );
    assert_eq!(
        ::core::mem::align_of::<_GHook>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHook))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hook_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(hook_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(destroy)
        )
    );
}
impl Default for _GHook {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GPollFD = _GPollFD;
pub type GPollFunc = ::core::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
#[test]
fn bindgen_test_layout__GPollFD() {
    const UNINIT: ::core::mem::MaybeUninit<_GPollFD> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GPollFD>(),
        8usize,
        concat!("Size of: ", stringify!(_GPollFD))
    );
    assert_eq!(
        ::core::mem::align_of::<_GPollFD>(),
        4usize,
        concat!("Alignment of ", stringify!(_GPollFD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).revents) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(revents)
        )
    );
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    const UNINIT: ::core::mem::MaybeUninit<_GSList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GSList>(),
        16usize,
        concat!("Size of: ", stringify!(_GSList))
    );
    assert_eq!(
        ::core::mem::align_of::<_GSList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(next)
        )
    );
}
impl Default for _GSList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GIOCondition_G_IO_IN: GIOCondition = 1;
pub const GIOCondition_G_IO_OUT: GIOCondition = 4;
pub const GIOCondition_G_IO_PRI: GIOCondition = 2;
pub const GIOCondition_G_IO_ERR: GIOCondition = 8;
pub const GIOCondition_G_IO_HUP: GIOCondition = 16;
pub const GIOCondition_G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = core::ffi::c_uint;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_NONE: GMainContextFlags = 0;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: GMainContextFlags = 1;
pub type GMainContextFlags = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
pub type GMainLoop = _GMainLoop;
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
pub type GSourceFuncs = _GSourceFuncs;
pub type GSourceFunc =
    ::core::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
pub type GSourceOnceFunc = ::core::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
pub type GChildWatchFunc =
    ::core::option::Option<unsafe extern "C" fn(pid: GPid, wait_status: gint, user_data: gpointer)>;
pub type GSourceDisposeFunc = ::core::option::Option<unsafe extern "C" fn(source: *mut GSource)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut core::ffi::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[test]
fn bindgen_test_layout__GSource() {
    const UNINIT: ::core::mem::MaybeUninit<_GSource> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GSource>(),
        96usize,
        concat!("Size of: ", stringify!(_GSource))
    );
    assert_eq!(
        ::core::mem::align_of::<_GSource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSource))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_funcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_funcs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source_funcs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_funcs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll_fds) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(poll_fds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priv_)
        )
    );
}
impl Default for _GSource {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::core::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::core::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GSourceCallbackFuncs() {
    const UNINIT: ::core::mem::MaybeUninit<_GSourceCallbackFuncs> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GSourceCallbackFuncs>(),
        24usize,
        concat!("Size of: ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        ::core::mem::align_of::<_GSourceCallbackFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unref) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(unref)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(get)
        )
    );
}
pub type GSourceDummyMarshal = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::core::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::core::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::core::option::Option<
        unsafe extern "C" fn(
            source: *mut GSource,
            callback: GSourceFunc,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub finalize: ::core::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[test]
fn bindgen_test_layout__GSourceFuncs() {
    const UNINIT: ::core::mem::MaybeUninit<_GSourceFuncs> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GSourceFuncs>(),
        48usize,
        concat!("Size of: ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        ::core::mem::align_of::<_GSourceFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prepare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dispatch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).closure_callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).closure_marshal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_marshal)
        )
    );
}
pub type GMainContextPusher = core::ffi::c_void;
pub type GClearHandleFunc = ::core::option::Option<unsafe extern "C" fn(handle_id: guint)>;
pub type gunichar = guint32;
pub type gunichar2 = guint16;
pub const GUnicodeType_G_UNICODE_CONTROL: GUnicodeType = 0;
pub const GUnicodeType_G_UNICODE_FORMAT: GUnicodeType = 1;
pub const GUnicodeType_G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const GUnicodeType_G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const GUnicodeType_G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const GUnicodeType_G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const GUnicodeType_G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const GUnicodeType_G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const GUnicodeType_G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const GUnicodeType_G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
pub type GUnicodeType = core::ffi::c_uint;
pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARENTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
pub type GUnicodeBreakType = core::ffi::c_uint;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DOGRA: GUnicodeScript = 142;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUNJALA_GONDI: GUnicodeScript = 143;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANIFI_ROHINGYA: GUnicodeScript = 144;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAKASAR: GUnicodeScript = 145;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEDEFAIDRIN: GUnicodeScript = 146;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOGDIAN: GUnicodeScript = 147;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOGDIAN: GUnicodeScript = 148;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELYMAIC: GUnicodeScript = 149;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NANDINAGARI: GUnicodeScript = 150;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: GUnicodeScript = 151;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WANCHO: GUnicodeScript = 152;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHORASMIAN: GUnicodeScript = 153;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DIVES_AKURU: GUnicodeScript = 154;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT: GUnicodeScript = 155;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YEZIDI: GUnicodeScript = 156;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRO_MINOAN: GUnicodeScript = 157;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_UYGHUR: GUnicodeScript = 158;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGSA: GUnicodeScript = 159;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TOTO: GUnicodeScript = 160;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VITHKUQI: GUnicodeScript = 161;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MATH: GUnicodeScript = 162;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAWI: GUnicodeScript = 163;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NAG_MUNDARI: GUnicodeScript = 164;
pub type GUnicodeScript = core::ffi::c_int;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const GNormalizeMode_G_NORMALIZE_NFKC: GNormalizeMode = 3;
pub type GNormalizeMode = core::ffi::c_uint;
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str_: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[test]
fn bindgen_test_layout__GString() {
    const UNINIT: ::core::mem::MaybeUninit<_GString> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GString>(),
        24usize,
        concat!("Size of: ", stringify!(_GString))
    );
    assert_eq!(
        ::core::mem::align_of::<_GString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GString))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).allocated_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(allocated_len)
        )
    );
}
impl Default for _GString {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const GIOError_G_IO_ERROR_NONE: GIOError = 0;
pub const GIOError_G_IO_ERROR_AGAIN: GIOError = 1;
pub const GIOError_G_IO_ERROR_INVAL: GIOError = 2;
pub const GIOError_G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = core::ffi::c_uint;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = core::ffi::c_uint;
pub const GIOStatus_G_IO_STATUS_ERROR: GIOStatus = 0;
pub const GIOStatus_G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const GIOStatus_G_IO_STATUS_EOF: GIOStatus = 2;
pub const GIOStatus_G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = core::ffi::c_uint;
pub const GSeekType_G_SEEK_CUR: GSeekType = 0;
pub const GSeekType_G_SEEK_SET: GSeekType = 1;
pub const GSeekType_G_SEEK_END: GSeekType = 2;
pub type GSeekType = core::ffi::c_uint;
pub const GIOFlags_G_IO_FLAG_NONE: GIOFlags = 0;
pub const GIOFlags_G_IO_FLAG_APPEND: GIOFlags = 1;
pub const GIOFlags_G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const GIOFlags_G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const GIOFlags_G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const GIOFlags_G_IO_FLAG_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[test]
fn bindgen_test_layout__GIOChannel() {
    const UNINIT: ::core::mem::MaybeUninit<_GIOChannel> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GIOChannel>(),
        112usize,
        concat!("Size of: ", stringify!(_GIOChannel))
    );
    assert_eq!(
        ::core::mem::align_of::<_GIOChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOChannel))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).funcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_cd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_cd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_cd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_cd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line_term) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line_term_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_buf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encoded_read_buf) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoded_read_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_buf) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partial_write_buf) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(partial_write_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _GIOChannel {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::core::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::core::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::core::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::core::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::core::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::core::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::core::option::Option<
    unsafe extern "C" fn(
        source: *mut GIOChannel,
        condition: GIOCondition,
        user_data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::core::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::core::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::core::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::core::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::core::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::core::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::core::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            flags: GIOFlags,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_get_flags:
        ::core::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[test]
fn bindgen_test_layout__GIOFuncs() {
    const UNINIT: ::core::mem::MaybeUninit<_GIOFuncs> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GIOFuncs>(),
        64usize,
        concat!("Size of: ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        ::core::mem::align_of::<_GIOFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_create_watch) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_create_watch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_set_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_set_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_get_flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_get_flags)
        )
    );
}
pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const GKeyFileFlags_G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const GMarkupError_G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const GMarkupError_G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
pub type GMarkupError = core::ffi::c_uint;
pub const GMarkupParseFlags_G_MARKUP_DEFAULT_FLAGS: GMarkupParseFlags = 0;
pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
pub type GMarkupParseFlags = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
pub type GMarkupParseContext = _GMarkupParseContext;
pub type GMarkupParser = _GMarkupParser;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GMarkupParser() {
    const UNINIT: ::core::mem::MaybeUninit<_GMarkupParser> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GMarkupParser>(),
        40usize,
        concat!("Size of: ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        ::core::mem::align_of::<_GMarkupParser>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(start_element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end_element) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(end_element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).passthrough) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(passthrough)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(error)
        )
    );
}
pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
pub type GVariantType = _GVariantType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const GVariantClass_G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const GVariantClass_G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const GVariantClass_G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const GVariantClass_G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const GVariantClass_G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const GVariantClass_G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const GVariantClass_G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const GVariantClass_G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const GVariantClass_G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const GVariantClass_G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const GVariantClass_G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const GVariantClass_G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const GVariantClass_G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const GVariantClass_G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = core::ffi::c_uint;
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [gsize; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantIter() {
    const UNINIT: ::core::mem::MaybeUninit<_GVariantIter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GVariantIter>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantIter))
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantIter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantIter),
            "::",
            stringify!(x)
        )
    );
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partial_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
impl Default for _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_GVariantBuilder__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GVariantBuilder__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantBuilder__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
impl Default for _GVariantBuilder__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GVariantBuilder__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_GVariantBuilder__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout__GVariantBuilder() {
    const UNINIT: ::core::mem::MaybeUninit<_GVariantBuilder> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GVariantBuilder>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder),
            "::",
            stringify!(u)
        )
    );
}
impl Default for _GVariantBuilder {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GVariantBuilder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_GVariantBuilder {{ u: {:?} }}", self.u)
    }
}
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT:
    GVariantParseError = 16;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_RECURSION: GVariantParseError = 18;
pub type GVariantParseError = core::ffi::c_uint;
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_GVariantDict__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).asv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(asv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).partial_magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
impl Default for _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_GVariantDict__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GVariantDict__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantDict__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
impl Default for _GVariantDict__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GVariantDict__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_GVariantDict__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout__GVariantDict() {
    const UNINIT: ::core::mem::MaybeUninit<_GVariantDict> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GVariantDict>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict))
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantDict>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict),
            "::",
            stringify!(u)
        )
    );
}
impl Default for _GVariantDict {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GVariantDict {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_GVariantDict {{ u: {:?} }}", self.u)
    }
}
pub const GLogLevelFlags_G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const GLogLevelFlags_G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const GLogLevelFlags_G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const GLogLevelFlags_G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const GLogLevelFlags_G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const GLogLevelFlags_G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = core::ffi::c_int;
pub type GLogFunc = ::core::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
pub const GLogWriterOutput_G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const GLogWriterOutput_G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;
pub type GLogWriterOutput = core::ffi::c_uint;
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[test]
fn bindgen_test_layout__GLogField() {
    const UNINIT: ::core::mem::MaybeUninit<_GLogField> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GLogField>(),
        24usize,
        concat!("Size of: ", stringify!(_GLogField))
    );
    assert_eq!(
        ::core::mem::align_of::<_GLogField>(),
        8usize,
        concat!("Alignment of ", stringify!(_GLogField))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(length)
        )
    );
}
impl Default for _GLogField {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GLogWriterFunc = ::core::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
pub type GPrintFunc = ::core::option::Option<unsafe extern "C" fn(string: *const gchar)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
pub type GOptionGroup = _GOptionGroup;
pub type GOptionEntry = _GOptionEntry;
pub const GOptionFlags_G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const GOptionFlags_G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const GOptionFlags_G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const GOptionFlags_G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const GOptionFlags_G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const GOptionFlags_G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
pub type GOptionFlags = core::ffi::c_uint;
pub const GOptionArg_G_OPTION_ARG_NONE: GOptionArg = 0;
pub const GOptionArg_G_OPTION_ARG_STRING: GOptionArg = 1;
pub const GOptionArg_G_OPTION_ARG_INT: GOptionArg = 2;
pub const GOptionArg_G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const GOptionArg_G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const GOptionArg_G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const GOptionArg_G_OPTION_ARG_INT64: GOptionArg = 8;
pub type GOptionArg = core::ffi::c_uint;
pub type GOptionArgFunc = ::core::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
pub type GOptionParseFunc = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
pub type GOptionErrorFunc = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        user_data: gpointer,
        error: *mut *mut GError,
    ),
>;
pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const GOptionError_G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const GOptionError_G_OPTION_ERROR_FAILED: GOptionError = 2;
pub type GOptionError = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[test]
fn bindgen_test_layout__GOptionEntry() {
    const UNINIT: ::core::mem::MaybeUninit<_GOptionEntry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GOptionEntry>(),
        48usize,
        concat!("Size of: ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<_GOptionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).long_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).short_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(short_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg_description) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_description)
        )
    );
}
impl Default for _GOptionEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
pub type GQueue = _GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[test]
fn bindgen_test_layout__GQueue() {
    const UNINIT: ::core::mem::MaybeUninit<_GQueue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GQueue>(),
        24usize,
        concat!("Size of: ", stringify!(_GQueue))
    );
    assert_eq!(
        ::core::mem::align_of::<_GQueue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GQueue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(length)
        )
    );
}
impl Default for _GQueue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
pub type GRefString = core::ffi::c_char;
pub const GRegexError_G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const GRegexError_G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const GRegexError_G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const GRegexError_G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const GRegexError_G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const GRegexError_G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
pub type GRegexError = core::ffi::c_uint;
pub const GRegexCompileFlags_G_REGEX_DEFAULT: GRegexCompileFlags = 0;
pub const GRegexCompileFlags_G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const GRegexCompileFlags_G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const GRegexCompileFlags_G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const GRegexCompileFlags_G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const GRegexCompileFlags_G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const GRegexCompileFlags_G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const GRegexCompileFlags_G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const GRegexCompileFlags_G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const GRegexCompileFlags_G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const GRegexCompileFlags_G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
pub type GRegexCompileFlags = core::ffi::c_uint;
pub const GRegexMatchFlags_G_REGEX_MATCH_DEFAULT: GRegexMatchFlags = 0;
pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
pub type GRegexMatchFlags = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
pub type GMatchInfo = _GMatchInfo;
pub type GRegexEvalCallback = ::core::option::Option<
    unsafe extern "C" fn(
        match_info: *const GMatchInfo,
        result: *mut GString,
        user_data: gpointer,
    ) -> gboolean,
>;
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::core::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
pub const GErrorType_G_ERR_UNKNOWN: GErrorType = 0;
pub const GErrorType_G_ERR_UNEXP_EOF: GErrorType = 1;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const GErrorType_G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const GErrorType_G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const GErrorType_G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = core::ffi::c_uint;
pub const GTokenType_G_TOKEN_EOF: GTokenType = 0;
pub const GTokenType_G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const GTokenType_G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const GTokenType_G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const GTokenType_G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const GTokenType_G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const GTokenType_G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const GTokenType_G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const GTokenType_G_TOKEN_COMMA: GTokenType = 44;
pub const GTokenType_G_TOKEN_NONE: GTokenType = 256;
pub const GTokenType_G_TOKEN_ERROR: GTokenType = 257;
pub const GTokenType_G_TOKEN_CHAR: GTokenType = 258;
pub const GTokenType_G_TOKEN_BINARY: GTokenType = 259;
pub const GTokenType_G_TOKEN_OCTAL: GTokenType = 260;
pub const GTokenType_G_TOKEN_INT: GTokenType = 261;
pub const GTokenType_G_TOKEN_HEX: GTokenType = 262;
pub const GTokenType_G_TOKEN_FLOAT: GTokenType = 263;
pub const GTokenType_G_TOKEN_STRING: GTokenType = 264;
pub const GTokenType_G_TOKEN_SYMBOL: GTokenType = 265;
pub const GTokenType_G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const GTokenType_G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const GTokenType_G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const GTokenType_G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const GTokenType_G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
}
#[test]
fn bindgen_test_layout__GTokenValue() {
    const UNINIT: ::core::mem::MaybeUninit<_GTokenValue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GTokenValue>(),
        8usize,
        concat!("Size of: ", stringify!(_GTokenValue))
    );
    assert_eq!(
        ::core::mem::align_of::<_GTokenValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTokenValue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_symbol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_symbol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_identifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_binary) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_binary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_octal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_octal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_hex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_hex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_comment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_comment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_char) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_char)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_error)
        )
    );
}
impl Default for _GTokenValue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GTokenValue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_GTokenValue {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub padding_dummy: guint,
}
#[test]
fn bindgen_test_layout__GScannerConfig() {
    const UNINIT: ::core::mem::MaybeUninit<_GScannerConfig> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GScannerConfig>(),
        40usize,
        concat!("Size of: ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<_GScannerConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cset_skip_characters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_skip_characters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cset_identifier_first) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cset_identifier_nth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_nth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpair_comment_single) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cpair_comment_single)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding_dummy) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(padding_dummy)
        )
    );
}
impl Default for _GScannerConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::core::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::core::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::core::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::core::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::core::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::core::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::core::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::core::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::core::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::core::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::core::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::core::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::core::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::core::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::core::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::core::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::core::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::core::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::core::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::core::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::core::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::core::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[test]
fn bindgen_test_layout__GScanner() {
    const UNINIT: ::core::mem::MaybeUninit<_GScanner> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GScanner>(),
        144usize,
        concat!("Size of: ", stringify!(_GScanner))
    );
    assert_eq!(
        ::core::mem::align_of::<_GScanner>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScanner))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_parse_errors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(max_parse_errors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parse_errors) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(parse_errors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qdata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_token) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_token)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_line) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_position) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).symbol_table) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(symbol_table)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input_fd) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_fd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_end) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scope_id) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(scope_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_handler) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(msg_handler)
        )
    );
}
impl Default for _GScanner {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GScanner {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "_GScanner {{ user_data: {:?}, max_parse_errors: {:?}, parse_errors: {:?}, input_name: {:?}, qdata: {:?}, config: {:?}, token: {:?}, value: {:?}, line: {:?}, position: {:?}, next_token: {:?}, next_value: {:?}, next_line: {:?}, next_position: {:?}, symbol_table: {:?}, input_fd: {:?}, text: {:?}, text_end: {:?}, buffer: {:?}, scope_id: {:?}, msg_handler: {:?} }}" , self . user_data , self . max_parse_errors , self . parse_errors , self . input_name , self . qdata , self . config , self . token , self . value , self . line , self . position , self . next_token , self . next_value , self . next_line , self . next_position , self . symbol_table , self . input_fd , self . text , self . text_end , self . buffer , self . scope_id , self . msg_handler)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::core::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, user_data: gpointer) -> gint,
>;
pub const GShellError_G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const GShellError_G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const GShellError_G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = core::ffi::c_uint;
pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = core::ffi::c_uint;
pub const GSpawnError_G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const GSpawnError_G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const GSpawnError_G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const GSpawnError_G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const GSpawnError_G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const GSpawnError_G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const GSpawnError_G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const GSpawnError_G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const GSpawnError_G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const GSpawnError_G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const GSpawnError_G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const GSpawnError_G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const GSpawnError_G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const GSpawnError_G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const GSpawnError_G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const GSpawnError_G_SPAWN_ERROR_FAILED: GSpawnError = 19;
pub type GSpawnError = core::ffi::c_uint;
pub type GSpawnChildSetupFunc = ::core::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
pub const GSpawnFlags_G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDOUT: GSpawnFlags = 512;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDERR: GSpawnFlags = 1024;
pub const GSpawnFlags_G_SPAWN_STDIN_FROM_DEV_NULL: GSpawnFlags = 2048;
pub type GSpawnFlags = core::ffi::c_uint;
pub const GAsciiType_G_ASCII_ALNUM: GAsciiType = 1;
pub const GAsciiType_G_ASCII_ALPHA: GAsciiType = 2;
pub const GAsciiType_G_ASCII_CNTRL: GAsciiType = 4;
pub const GAsciiType_G_ASCII_DIGIT: GAsciiType = 8;
pub const GAsciiType_G_ASCII_GRAPH: GAsciiType = 16;
pub const GAsciiType_G_ASCII_LOWER: GAsciiType = 32;
pub const GAsciiType_G_ASCII_PRINT: GAsciiType = 64;
pub const GAsciiType_G_ASCII_PUNCT: GAsciiType = 128;
pub const GAsciiType_G_ASCII_SPACE: GAsciiType = 256;
pub const GAsciiType_G_ASCII_UPPER: GAsciiType = 512;
pub const GAsciiType_G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = core::ffi::c_uint;
pub type GStrv = *mut *mut gchar;
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;
pub type GNumberParserError = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStrvBuilder {
    _unused: [u8; 0],
}
pub type GStrvBuilder = _GStrvBuilder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::core::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::core::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::core::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
pub const GTestTrapFlags_G_TEST_TRAP_DEFAULT: GTestTrapFlags = 0;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
pub type GTestTrapFlags = core::ffi::c_uint;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_DEFAULT: GTestSubprocessFlags = 0;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[test]
fn bindgen_test_layout_GTestConfig() {
    const UNINIT: ::core::mem::MaybeUninit<GTestConfig> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GTestConfig>(),
        24usize,
        concat!("Size of: ", stringify!(GTestConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<GTestConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(GTestConfig))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).test_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_initialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).test_quick) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).test_perf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_perf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).test_verbose) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_verbose)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).test_quiet) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quiet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).test_undefined) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_undefined)
        )
    );
}
pub const GTestResult_G_TEST_RUN_SUCCESS: GTestResult = 0;
pub const GTestResult_G_TEST_RUN_SKIPPED: GTestResult = 1;
pub const GTestResult_G_TEST_RUN_FAILURE: GTestResult = 2;
pub const GTestResult_G_TEST_RUN_INCOMPLETE: GTestResult = 3;
pub type GTestResult = core::ffi::c_uint;
pub const GTestLogType_G_TEST_LOG_NONE: GTestLogType = 0;
pub const GTestLogType_G_TEST_LOG_ERROR: GTestLogType = 1;
pub const GTestLogType_G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const GTestLogType_G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const GTestLogType_G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const GTestLogType_G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const GTestLogType_G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const GTestLogType_G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const GTestLogType_G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const GTestLogType_G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const GTestLogType_G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const GTestLogType_G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut u128,
}
#[test]
fn bindgen_test_layout_GTestLogMsg() {
    const UNINIT: ::core::mem::MaybeUninit<GTestLogMsg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GTestLogMsg>(),
        32usize,
        concat!("Size of: ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        ::core::mem::align_of::<GTestLogMsg>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(log_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_strings) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_strings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_nums) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_nums)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nums) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(nums)
        )
    );
}
impl Default for GTestLogMsg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[test]
fn bindgen_test_layout_GTestLogBuffer() {
    const UNINIT: ::core::mem::MaybeUninit<GTestLogBuffer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GTestLogBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<GTestLogBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msgs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(msgs)
        )
    );
}
impl Default for GTestLogBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GTestLogFatalFunc = ::core::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
pub const GTestFileType_G_TEST_DIST: GTestFileType = 0;
pub const GTestFileType_G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = core::ffi::c_uint;
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[test]
fn bindgen_test_layout__GThreadPool() {
    const UNINIT: ::core::mem::MaybeUninit<_GThreadPool> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GThreadPool>(),
        24usize,
        concat!("Size of: ", stringify!(_GThreadPool))
    );
    assert_eq!(
        ::core::mem::align_of::<_GThreadPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadPool))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exclusive) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(exclusive)
        )
    );
}
impl Default for _GThreadPool {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[test]
fn bindgen_test_layout__GTrashStack() {
    const UNINIT: ::core::mem::MaybeUninit<_GTrashStack> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GTrashStack>(),
        8usize,
        concat!("Size of: ", stringify!(_GTrashStack))
    );
    assert_eq!(
        ::core::mem::align_of::<_GTrashStack>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTrashStack))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTrashStack),
            "::",
            stringify!(next)
        )
    );
}
impl Default for _GTrashStack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTreeNode {
    _unused: [u8; 0],
}
pub type GTreeNode = _GTreeNode;
pub type GTraverseFunc = ::core::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GTraverseNodeFunc = ::core::option::Option<
    unsafe extern "C" fn(node: *mut GTreeNode, user_data: gpointer) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUri {
    _unused: [u8; 0],
}
pub type GUri = _GUri;
pub const GUriFlags_G_URI_FLAGS_NONE: GUriFlags = 0;
pub const GUriFlags_G_URI_FLAGS_PARSE_RELAXED: GUriFlags = 1;
pub const GUriFlags_G_URI_FLAGS_HAS_PASSWORD: GUriFlags = 2;
pub const GUriFlags_G_URI_FLAGS_HAS_AUTH_PARAMS: GUriFlags = 4;
pub const GUriFlags_G_URI_FLAGS_ENCODED: GUriFlags = 8;
pub const GUriFlags_G_URI_FLAGS_NON_DNS: GUriFlags = 16;
pub const GUriFlags_G_URI_FLAGS_ENCODED_QUERY: GUriFlags = 32;
pub const GUriFlags_G_URI_FLAGS_ENCODED_PATH: GUriFlags = 64;
pub const GUriFlags_G_URI_FLAGS_ENCODED_FRAGMENT: GUriFlags = 128;
pub const GUriFlags_G_URI_FLAGS_SCHEME_NORMALIZE: GUriFlags = 256;
pub type GUriFlags = core::ffi::c_uint;
pub const GUriHideFlags_G_URI_HIDE_NONE: GUriHideFlags = 0;
pub const GUriHideFlags_G_URI_HIDE_USERINFO: GUriHideFlags = 1;
pub const GUriHideFlags_G_URI_HIDE_PASSWORD: GUriHideFlags = 2;
pub const GUriHideFlags_G_URI_HIDE_AUTH_PARAMS: GUriHideFlags = 4;
pub const GUriHideFlags_G_URI_HIDE_QUERY: GUriHideFlags = 8;
pub const GUriHideFlags_G_URI_HIDE_FRAGMENT: GUriHideFlags = 16;
pub type GUriHideFlags = core::ffi::c_uint;
pub const GUriParamsFlags_G_URI_PARAMS_NONE: GUriParamsFlags = 0;
pub const GUriParamsFlags_G_URI_PARAMS_CASE_INSENSITIVE: GUriParamsFlags = 1;
pub const GUriParamsFlags_G_URI_PARAMS_WWW_FORM: GUriParamsFlags = 2;
pub const GUriParamsFlags_G_URI_PARAMS_PARSE_RELAXED: GUriParamsFlags = 4;
pub type GUriParamsFlags = core::ffi::c_uint;
pub type GUriParamsIter = _GUriParamsIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUriParamsIter {
    pub dummy0: gint,
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: [guint8; 256usize],
}
#[test]
fn bindgen_test_layout__GUriParamsIter() {
    const UNINIT: ::core::mem::MaybeUninit<_GUriParamsIter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GUriParamsIter>(),
        280usize,
        concat!("Size of: ", stringify!(_GUriParamsIter))
    );
    assert_eq!(
        ::core::mem::align_of::<_GUriParamsIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUriParamsIter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy3)
        )
    );
}
impl Default for _GUriParamsIter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GUriError_G_URI_ERROR_FAILED: GUriError = 0;
pub const GUriError_G_URI_ERROR_BAD_SCHEME: GUriError = 1;
pub const GUriError_G_URI_ERROR_BAD_USER: GUriError = 2;
pub const GUriError_G_URI_ERROR_BAD_PASSWORD: GUriError = 3;
pub const GUriError_G_URI_ERROR_BAD_AUTH_PARAMS: GUriError = 4;
pub const GUriError_G_URI_ERROR_BAD_HOST: GUriError = 5;
pub const GUriError_G_URI_ERROR_BAD_PORT: GUriError = 6;
pub const GUriError_G_URI_ERROR_BAD_PATH: GUriError = 7;
pub const GUriError_G_URI_ERROR_BAD_QUERY: GUriError = 8;
pub const GUriError_G_URI_ERROR_BAD_FRAGMENT: GUriError = 9;
pub type GUriError = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::core::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::core::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::core::option::Option<unsafe extern "C" fn(value: gpointer)>;
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::core::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::core::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[test]
fn bindgen_test_layout__GCompletion() {
    const UNINIT: ::core::mem::MaybeUninit<_GCompletion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GCompletion>(),
        40usize,
        concat!("Size of: ", stringify!(_GCompletion))
    );
    assert_eq!(
        ::core::mem::align_of::<_GCompletion>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCompletion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).strncmp_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(strncmp_func)
        )
    );
}
impl Default for _GCompletion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GTuples() {
    const UNINIT: ::core::mem::MaybeUninit<_GTuples> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GTuples>(),
        4usize,
        concat!("Size of: ", stringify!(_GTuples))
    );
    assert_eq!(
        ::core::mem::align_of::<_GTuples>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTuples))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTuples),
            "::",
            stringify!(len)
        )
    );
}
pub const GThreadPriority_G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const GThreadPriority_G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const GThreadPriority_G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[test]
fn bindgen_test_layout__GThread() {
    const UNINIT: ::core::mem::MaybeUninit<_GThread> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GThread>(),
        24usize,
        concat!("Size of: ", stringify!(_GThread))
    );
    assert_eq!(
        ::core::mem::align_of::<_GThread>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThread))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).joinable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(joinable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(priority)
        )
    );
}
impl Default for _GThread {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::core::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::core::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::core::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::core::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::core::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::core::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::core::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::core::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::core::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::core::option::Option<
        unsafe extern "C" fn(
            cond: *mut GCond,
            mutex: *mut GMutex,
            end_time: *mut GTimeVal,
        ) -> gboolean,
    >,
    pub cond_free: ::core::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::core::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::core::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::core::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::core::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::core::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::core::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::core::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::core::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::core::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GThreadFunctions() {
    const UNINIT: ::core::mem::MaybeUninit<_GThreadFunctions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GThreadFunctions>(),
        168usize,
        concat!("Size of: ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        ::core::mem::align_of::<_GThreadFunctions>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex_new) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_new)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex_lock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex_trylock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_trylock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex_unlock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_unlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex_free) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cond_new) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_new)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cond_signal) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cond_broadcast) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_broadcast)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cond_wait) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_wait)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cond_timed_wait) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_timed_wait)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cond_free) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_new) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_new)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_get) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_set) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_create) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_create)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_yield) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_yield)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_join) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_join)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_exit) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_exit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_set_priority) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_set_priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_self) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_self)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_equal) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_equal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::core::mem::MaybeUninit<sched_param> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::core::mem::MaybeUninit<cpu_set_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_17 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_17 = 1;
pub type _bindgen_ty_17 = core::ffi::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_18 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_18 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_18 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_18 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_18 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_18 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_18 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_18 = 0;
pub const PTHREAD_MUTEX_FAST_NP: _bindgen_ty_18 = 0;
pub type _bindgen_ty_18 = core::ffi::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_19 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_19 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_19 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = core::ffi::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_20 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_20 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_20 = 2;
pub type _bindgen_ty_20 = core::ffi::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_21 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_21 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_21 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_21 = 0;
pub type _bindgen_ty_21 = core::ffi::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_22 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_22 = 1;
pub type _bindgen_ty_22 = core::ffi::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_23 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_23 = 1;
pub type _bindgen_ty_23 = core::ffi::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_24 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_24 = 1;
pub type _bindgen_ty_24 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
    pub __arg: *mut core::ffi::c_void,
    pub __canceltype: core::ffi::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::core::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
impl Default for _pthread_cleanup_buffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_25 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_25 = 1;
pub type _bindgen_ty_25 = core::ffi::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_26 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_26 = 1;
pub type _bindgen_ty_26 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    const UNINIT: ::core::mem::MaybeUninit<__cancel_jmp_buf_tag> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut core::ffi::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
impl Default for __pthread_unwind_buf_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
    pub __cancel_arg: *mut core::ffi::c_void,
    pub __do_it: core::ffi::c_int,
    pub __cancel_type: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
impl Default for __pthread_cleanup_frame {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_GStaticMutex() {
    const UNINIT: ::core::mem::MaybeUninit<GStaticMutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GStaticMutex>(),
        48usize,
        concat!("Size of: ", stringify!(GStaticMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<GStaticMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(GStaticMutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(unused)
        )
    );
}
impl Default for GStaticMutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for GStaticMutex {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "GStaticMutex {{ mutex: {:?}, unused: {:?} }}",
            self.mutex, self.unused
        )
    }
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: pthread_t,
    pub dummy: gdouble,
}
#[test]
fn bindgen_test_layout__GStaticRecMutex__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_GStaticRecMutex__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
impl Default for _GStaticRecMutex__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GStaticRecMutex__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "_GStaticRecMutex__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout__GStaticRecMutex() {
    const UNINIT: ::core::mem::MaybeUninit<_GStaticRecMutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GStaticRecMutex>(),
        64usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<_GStaticRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(unused)
        )
    );
}
impl Default for _GStaticRecMutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GStaticRecMutex {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "_GStaticRecMutex {{ mutex: {:?}, depth: {:?}, unused: {:?} }}",
            self.mutex, self.depth, self.unused
        )
    }
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[test]
fn bindgen_test_layout__GStaticRWLock() {
    const UNINIT: ::core::mem::MaybeUninit<_GStaticRWLock> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GStaticRWLock>(),
        80usize,
        concat!("Size of: ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        ::core::mem::align_of::<_GStaticRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_cond) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_cond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_cond) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(write_cond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_counter) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).have_writer) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(have_writer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).want_to_read) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).want_to_write) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_write)
        )
    );
}
impl Default for _GStaticRWLock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for _GStaticRWLock {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "_GStaticRWLock {{ mutex: {:?}, read_cond: {:?}, write_cond: {:?}, read_counter: {:?}, have_writer: {:?}, want_to_read: {:?}, want_to_write: {:?} }}" , self . mutex , self . read_cond , self . write_cond , self . read_counter , self . have_writer , self . want_to_read , self . want_to_write)
    }
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[test]
fn bindgen_test_layout__GStaticPrivate() {
    const UNINIT: ::core::mem::MaybeUninit<_GStaticPrivate> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GStaticPrivate>(),
        4usize,
        concat!("Size of: ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        ::core::mem::align_of::<_GStaticPrivate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticPrivate),
            "::",
            stringify!(index)
        )
    );
}
pub type GUnixFDSourceFunc = ::core::option::Option<
    unsafe extern "C" fn(fd: gint, condition: GIOCondition, user_data: gpointer) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct passwd {
    pub pw_name: *mut core::ffi::c_char,
    pub pw_passwd: *mut core::ffi::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut core::ffi::c_char,
    pub pw_dir: *mut core::ffi::c_char,
    pub pw_shell: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_passwd() {
    const UNINIT: ::core::mem::MaybeUninit<passwd> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<passwd>(),
        48usize,
        concat!("Size of: ", stringify!(passwd))
    );
    assert_eq!(
        ::core::mem::align_of::<passwd>(),
        8usize,
        concat!("Alignment of ", stringify!(passwd))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pw_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pw_passwd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_passwd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pw_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pw_gid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_gid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pw_gecos) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_gecos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pw_dir) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_dir)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pw_shell) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(passwd),
            "::",
            stringify!(pw_shell)
        )
    );
}
impl Default for passwd {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
pub type __socket_type = core::ffi::c_uint;
pub type sa_family_t = core::ffi::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [core::ffi::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    const UNINIT: ::core::mem::MaybeUninit<sockaddr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [core::ffi::c_char; 118usize],
    pub __ss_align: core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    const UNINIT: ::core::mem::MaybeUninit<sockaddr_storage> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ss_padding) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const MSG_OOB: _bindgen_ty_27 = 1;
pub const MSG_PEEK: _bindgen_ty_27 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_27 = 4;
pub const MSG_TRYHARD: _bindgen_ty_27 = 4;
pub const MSG_CTRUNC: _bindgen_ty_27 = 8;
pub const MSG_PROXY: _bindgen_ty_27 = 16;
pub const MSG_TRUNC: _bindgen_ty_27 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_27 = 64;
pub const MSG_EOR: _bindgen_ty_27 = 128;
pub const MSG_WAITALL: _bindgen_ty_27 = 256;
pub const MSG_FIN: _bindgen_ty_27 = 512;
pub const MSG_SYN: _bindgen_ty_27 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_27 = 2048;
pub const MSG_RST: _bindgen_ty_27 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_27 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_27 = 16384;
pub const MSG_MORE: _bindgen_ty_27 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_27 = 65536;
pub const MSG_BATCH: _bindgen_ty_27 = 262144;
pub const MSG_ZEROCOPY: _bindgen_ty_27 = 67108864;
pub const MSG_FASTOPEN: _bindgen_ty_27 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_27 = 1073741824;
pub type _bindgen_ty_27 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut core::ffi::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut core::ffi::c_void,
    pub msg_controllen: usize,
    pub msg_flags: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    const UNINIT: ::core::mem::MaybeUninit<msghdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<msghdr>(),
        56usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::core::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
impl Default for msghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: core::ffi::c_int,
    pub cmsg_type: core::ffi::c_int,
    pub __cmsg_data: __IncompleteArrayField<core::ffi::c_uchar>,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    const UNINIT: ::core::mem::MaybeUninit<cmsghdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cmsghdr>(),
        16usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::core::mem::align_of::<cmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cmsg_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(__cmsg_data)
        )
    );
}
pub const SCM_RIGHTS: _bindgen_ty_28 = 1;
pub const SCM_CREDENTIALS: _bindgen_ty_28 = 2;
pub type _bindgen_ty_28 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ucred {
    pub pid: pid_t,
    pub uid: uid_t,
    pub gid: gid_t,
}
#[test]
fn bindgen_test_layout_ucred() {
    const UNINIT: ::core::mem::MaybeUninit<ucred> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ucred>(),
        12usize,
        concat!("Size of: ", stringify!(ucred))
    );
    assert_eq!(
        ::core::mem::align_of::<ucred>(),
        4usize,
        concat!("Alignment of ", stringify!(ucred))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucred),
            "::",
            stringify!(gid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: core::ffi::c_int,
    pub l_linger: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    const UNINIT: ::core::mem::MaybeUninit<linger> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::core::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osockaddr {
    pub sa_family: core::ffi::c_ushort,
    pub sa_data: [core::ffi::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    const UNINIT: ::core::mem::MaybeUninit<osockaddr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<osockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(osockaddr))
    );
    assert_eq!(
        ::core::mem::align_of::<osockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(osockaddr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(osockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
pub const SHUT_RD: _bindgen_ty_29 = 0;
pub const SHUT_WR: _bindgen_ty_29 = 1;
pub const SHUT_RDWR: _bindgen_ty_29 = 2;
pub type _bindgen_ty_29 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __SOCKADDR_ARG {
    pub __sockaddr__: *mut sockaddr,
    pub __sockaddr_at__: *mut sockaddr_at,
    pub __sockaddr_ax25__: *mut sockaddr_ax25,
    pub __sockaddr_dl__: *mut sockaddr_dl,
    pub __sockaddr_eon__: *mut sockaddr_eon,
    pub __sockaddr_in__: *mut sockaddr_in,
    pub __sockaddr_in6__: *mut sockaddr_in6,
    pub __sockaddr_inarp__: *mut sockaddr_inarp,
    pub __sockaddr_ipx__: *mut sockaddr_ipx,
    pub __sockaddr_iso__: *mut sockaddr_iso,
    pub __sockaddr_ns__: *mut sockaddr_ns,
    pub __sockaddr_un__: *mut sockaddr_un,
    pub __sockaddr_x25__: *mut sockaddr_x25,
}
#[test]
fn bindgen_test_layout___SOCKADDR_ARG() {
    const UNINIT: ::core::mem::MaybeUninit<__SOCKADDR_ARG> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__SOCKADDR_ARG>(),
        8usize,
        concat!("Size of: ", stringify!(__SOCKADDR_ARG))
    );
    assert_eq!(
        ::core::mem::align_of::<__SOCKADDR_ARG>(),
        8usize,
        concat!("Alignment of ", stringify!(__SOCKADDR_ARG))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_at__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_at__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_ax25__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ax25__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_dl__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_dl__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_eon__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_eon__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_in__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_in6__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in6__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_inarp__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_inarp__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_ipx__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ipx__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_iso__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_iso__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_ns__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ns__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_un__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_un__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_x25__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_x25__)
        )
    );
}
impl Default for __SOCKADDR_ARG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for __SOCKADDR_ARG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "__SOCKADDR_ARG {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __CONST_SOCKADDR_ARG {
    pub __sockaddr__: *const sockaddr,
    pub __sockaddr_at__: *const sockaddr_at,
    pub __sockaddr_ax25__: *const sockaddr_ax25,
    pub __sockaddr_dl__: *const sockaddr_dl,
    pub __sockaddr_eon__: *const sockaddr_eon,
    pub __sockaddr_in__: *const sockaddr_in,
    pub __sockaddr_in6__: *const sockaddr_in6,
    pub __sockaddr_inarp__: *const sockaddr_inarp,
    pub __sockaddr_ipx__: *const sockaddr_ipx,
    pub __sockaddr_iso__: *const sockaddr_iso,
    pub __sockaddr_ns__: *const sockaddr_ns,
    pub __sockaddr_un__: *const sockaddr_un,
    pub __sockaddr_x25__: *const sockaddr_x25,
}
#[test]
fn bindgen_test_layout___CONST_SOCKADDR_ARG() {
    const UNINIT: ::core::mem::MaybeUninit<__CONST_SOCKADDR_ARG> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__CONST_SOCKADDR_ARG>(),
        8usize,
        concat!("Size of: ", stringify!(__CONST_SOCKADDR_ARG))
    );
    assert_eq!(
        ::core::mem::align_of::<__CONST_SOCKADDR_ARG>(),
        8usize,
        concat!("Alignment of ", stringify!(__CONST_SOCKADDR_ARG))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_at__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_at__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_ax25__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ax25__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_dl__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_dl__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_eon__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_eon__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_in__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_in6__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_in6__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_inarp__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_inarp__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_ipx__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ipx__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_iso__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_iso__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_ns__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_ns__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_un__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_un__)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sockaddr_x25__) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__CONST_SOCKADDR_ARG),
            "::",
            stringify!(__sockaddr_x25__)
        )
    );
}
impl Default for __CONST_SOCKADDR_ARG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for __CONST_SOCKADDR_ARG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "__CONST_SOCKADDR_ARG {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_mmsghdr() {
    const UNINIT: ::core::mem::MaybeUninit<mmsghdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mmsghdr>(),
        64usize,
        concat!("Size of: ", stringify!(mmsghdr))
    );
    assert_eq!(
        ::core::mem::align_of::<mmsghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(mmsghdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_len) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mmsghdr),
            "::",
            stringify!(msg_len)
        )
    );
}
impl Default for mmsghdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    const UNINIT: ::core::mem::MaybeUninit<in_addr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [core::ffi::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    const UNINIT: ::core::mem::MaybeUninit<ip_opts> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::core::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip_dst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip_opts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
impl Default for ip_opts {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: core::ffi::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    const UNINIT: ::core::mem::MaybeUninit<in_pktinfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipi_ifindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipi_spec_dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipi_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
pub const IPPROTO_IP: _bindgen_ty_30 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_30 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_30 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_30 = 4;
pub const IPPROTO_TCP: _bindgen_ty_30 = 6;
pub const IPPROTO_EGP: _bindgen_ty_30 = 8;
pub const IPPROTO_PUP: _bindgen_ty_30 = 12;
pub const IPPROTO_UDP: _bindgen_ty_30 = 17;
pub const IPPROTO_IDP: _bindgen_ty_30 = 22;
pub const IPPROTO_TP: _bindgen_ty_30 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_30 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_30 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_30 = 46;
pub const IPPROTO_GRE: _bindgen_ty_30 = 47;
pub const IPPROTO_ESP: _bindgen_ty_30 = 50;
pub const IPPROTO_AH: _bindgen_ty_30 = 51;
pub const IPPROTO_MTP: _bindgen_ty_30 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_30 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_30 = 98;
pub const IPPROTO_PIM: _bindgen_ty_30 = 103;
pub const IPPROTO_COMP: _bindgen_ty_30 = 108;
pub const IPPROTO_SCTP: _bindgen_ty_30 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_30 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_30 = 137;
pub const IPPROTO_ETHERNET: _bindgen_ty_30 = 143;
pub const IPPROTO_RAW: _bindgen_ty_30 = 255;
pub const IPPROTO_MPTCP: _bindgen_ty_30 = 262;
pub const IPPROTO_MAX: _bindgen_ty_30 = 263;
pub type _bindgen_ty_30 = core::ffi::c_uint;
pub const IPPROTO_HOPOPTS: _bindgen_ty_31 = 0;
pub const IPPROTO_ROUTING: _bindgen_ty_31 = 43;
pub const IPPROTO_FRAGMENT: _bindgen_ty_31 = 44;
pub const IPPROTO_ICMPV6: _bindgen_ty_31 = 58;
pub const IPPROTO_NONE: _bindgen_ty_31 = 59;
pub const IPPROTO_DSTOPTS: _bindgen_ty_31 = 60;
pub const IPPROTO_MH: _bindgen_ty_31 = 135;
pub type _bindgen_ty_31 = core::ffi::c_uint;
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_32 = 7;
pub const IPPORT_DISCARD: _bindgen_ty_32 = 9;
pub const IPPORT_SYSTAT: _bindgen_ty_32 = 11;
pub const IPPORT_DAYTIME: _bindgen_ty_32 = 13;
pub const IPPORT_NETSTAT: _bindgen_ty_32 = 15;
pub const IPPORT_FTP: _bindgen_ty_32 = 21;
pub const IPPORT_TELNET: _bindgen_ty_32 = 23;
pub const IPPORT_SMTP: _bindgen_ty_32 = 25;
pub const IPPORT_TIMESERVER: _bindgen_ty_32 = 37;
pub const IPPORT_NAMESERVER: _bindgen_ty_32 = 42;
pub const IPPORT_WHOIS: _bindgen_ty_32 = 43;
pub const IPPORT_MTP: _bindgen_ty_32 = 57;
pub const IPPORT_TFTP: _bindgen_ty_32 = 69;
pub const IPPORT_RJE: _bindgen_ty_32 = 77;
pub const IPPORT_FINGER: _bindgen_ty_32 = 79;
pub const IPPORT_TTYLINK: _bindgen_ty_32 = 87;
pub const IPPORT_SUPDUP: _bindgen_ty_32 = 95;
pub const IPPORT_EXECSERVER: _bindgen_ty_32 = 512;
pub const IPPORT_LOGINSERVER: _bindgen_ty_32 = 513;
pub const IPPORT_CMDSERVER: _bindgen_ty_32 = 514;
pub const IPPORT_EFSSERVER: _bindgen_ty_32 = 520;
pub const IPPORT_BIFFUDP: _bindgen_ty_32 = 512;
pub const IPPORT_WHOSERVER: _bindgen_ty_32 = 513;
pub const IPPORT_ROUTESERVER: _bindgen_ty_32 = 520;
pub const IPPORT_RESERVED: _bindgen_ty_32 = 1024;
pub const IPPORT_USERRESERVED: _bindgen_ty_32 = 5000;
pub type _bindgen_ty_32 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<in6_addr__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for in6_addr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "in6_addr__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    const UNINIT: ::core::mem::MaybeUninit<in6_addr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__in6_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
impl Default for in6_addr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for in6_addr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "in6_addr {{ __in6_u: {:?} }}", self.__in6_u)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [core::ffi::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    const UNINIT: ::core::mem::MaybeUninit<sockaddr_in> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    const UNINIT: ::core::mem::MaybeUninit<sockaddr_in6> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for sockaddr_in6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "sockaddr_in6 {{ sin6_family: {:?}, sin6_port: {:?}, sin6_flowinfo: {:?}, sin6_addr: {:?}, sin6_scope_id: {:?} }}" , self . sin6_family , self . sin6_port , self . sin6_flowinfo , self . sin6_addr , self . sin6_scope_id)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    const UNINIT: ::core::mem::MaybeUninit<ip_mreq> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::core::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    const UNINIT: ::core::mem::MaybeUninit<ip_mreqn> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::core::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imr_address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imr_ifindex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    const UNINIT: ::core::mem::MaybeUninit<ip_mreq_source> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::core::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imr_sourceaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    const UNINIT: ::core::mem::MaybeUninit<ipv6_mreq> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::core::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipv6mr_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipv6mr_interface) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for ipv6_mreq {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "ipv6_mreq {{ ipv6mr_multiaddr: {:?}, ipv6mr_interface: {:?} }}",
            self.ipv6mr_multiaddr, self.ipv6mr_interface
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    const UNINIT: ::core::mem::MaybeUninit<group_req> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<group_req>(),
        136usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::core::mem::align_of::<group_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gr_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_req),
            "::",
            stringify!(gr_group)
        )
    );
}
impl Default for group_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    const UNINIT: ::core::mem::MaybeUninit<group_source_req> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<group_source_req>(),
        264usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::core::mem::align_of::<group_source_req>(),
        8usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gsr_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gsr_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_group)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gsr_source) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_source_req),
            "::",
            stringify!(gsr_source)
        )
    );
}
impl Default for group_source_req {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    const UNINIT: ::core::mem::MaybeUninit<ip_msfilter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip_msfilter>(),
        20usize,
        concat!("Size of: ", stringify!(ip_msfilter))
    );
    assert_eq!(
        ::core::mem::align_of::<ip_msfilter>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_msfilter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imsf_multiaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_multiaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imsf_interface) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imsf_fmode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_fmode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imsf_numsrc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_numsrc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).imsf_slist) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_msfilter),
            "::",
            stringify!(imsf_slist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    const UNINIT: ::core::mem::MaybeUninit<group_filter> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<group_filter>(),
        272usize,
        concat!("Size of: ", stringify!(group_filter))
    );
    assert_eq!(
        ::core::mem::align_of::<group_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(group_filter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gf_interface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_interface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gf_group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_group)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gf_fmode) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_fmode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gf_numsrc) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_numsrc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gf_slist) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(group_filter),
            "::",
            stringify!(gf_slist)
        )
    );
}
impl Default for group_filter {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    const UNINIT: ::core::mem::MaybeUninit<in6_pktinfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipi6_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipi6_ifindex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
impl Default for in6_pktinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for in6_pktinfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "in6_pktinfo {{ ipi6_addr: {:?}, ipi6_ifindex: {:?} }}",
            self.ipi6_addr, self.ipi6_ifindex
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    const UNINIT: ::core::mem::MaybeUninit<ip6_mtuinfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6m_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6m_mtu) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
impl Default for ip6_mtuinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for ip6_mtuinfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "ip6_mtuinfo {{ ip6m_addr: {:?}, ip6m_mtu: {:?} }}",
            self.ip6m_addr, self.ip6m_mtu
        )
    }
}
pub type tcp_seq = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcphdr {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcphdr__bindgen_ty_1 {
    pub __bindgen_anon_1: tcphdr__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: tcphdr__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_1 {
    pub th_sport: u16,
    pub th_dport: u16,
    pub th_seq: tcp_seq,
    pub th_ack: tcp_seq,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub th_flags: u8,
    pub th_win: u16,
    pub th_sum: u16,
    pub th_urp: u16,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<tcphdr__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).th_sport) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_sport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).th_dport) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_dport)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).th_seq) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_seq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).th_ack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_ack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).th_flags) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).th_win) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_win)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).th_sum) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_sum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).th_urp) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(th_urp)
        )
    );
}
impl tcphdr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn th_x2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn th_off(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(th_x2: u8, th_off: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let th_x2: u8 = unsafe { ::core::mem::transmute(th_x2) };
            th_x2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let th_off: u8 = unsafe { ::core::mem::transmute(th_off) };
            th_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tcphdr__bindgen_ty_1__bindgen_ty_2 {
    pub source: u16,
    pub dest: u16,
    pub seq: u32,
    pub ack_seq: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub window: u16,
    pub check: u16,
    pub urg_ptr: u16,
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<tcphdr__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<tcphdr__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seq) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ack_seq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ack_seq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).urg_ptr) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(tcphdr__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(urg_ptr)
        )
    );
}
impl tcphdr__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn res1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn doff(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psh(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urg(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn res2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: u16,
        doff: u16,
        fin: u16,
        syn: u16,
        rst: u16,
        psh: u16,
        ack: u16,
        urg: u16,
        res2: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::core::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::core::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::core::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::core::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::core::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::core::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::core::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::core::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res2: u16 = unsafe { ::core::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_tcphdr__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<tcphdr__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<tcphdr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr__bindgen_ty_1))
    );
}
impl Default for tcphdr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for tcphdr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "tcphdr__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_tcphdr() {
    assert_eq!(
        ::core::mem::size_of::<tcphdr>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr))
    );
    assert_eq!(
        ::core::mem::align_of::<tcphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr))
    );
}
impl Default for tcphdr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for tcphdr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "tcphdr {{ __bindgen_anon_1: {:?} }}",
            self.__bindgen_anon_1
        )
    }
}
pub const TCP_ESTABLISHED: _bindgen_ty_33 = 1;
pub const TCP_SYN_SENT: _bindgen_ty_33 = 2;
pub const TCP_SYN_RECV: _bindgen_ty_33 = 3;
pub const TCP_FIN_WAIT1: _bindgen_ty_33 = 4;
pub const TCP_FIN_WAIT2: _bindgen_ty_33 = 5;
pub const TCP_TIME_WAIT: _bindgen_ty_33 = 6;
pub const TCP_CLOSE: _bindgen_ty_33 = 7;
pub const TCP_CLOSE_WAIT: _bindgen_ty_33 = 8;
pub const TCP_LAST_ACK: _bindgen_ty_33 = 9;
pub const TCP_LISTEN: _bindgen_ty_33 = 10;
pub const TCP_CLOSING: _bindgen_ty_33 = 11;
pub type _bindgen_ty_33 = core::ffi::c_uint;
pub const tcp_ca_state_TCP_CA_Open: tcp_ca_state = 0;
pub const tcp_ca_state_TCP_CA_Disorder: tcp_ca_state = 1;
pub const tcp_ca_state_TCP_CA_CWR: tcp_ca_state = 2;
pub const tcp_ca_state_TCP_CA_Recovery: tcp_ca_state = 3;
pub const tcp_ca_state_TCP_CA_Loss: tcp_ca_state = 4;
pub type tcp_ca_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tcp_info {
    pub tcpi_state: u8,
    pub tcpi_ca_state: u8,
    pub tcpi_retransmits: u8,
    pub tcpi_probes: u8,
    pub tcpi_backoff: u8,
    pub tcpi_options: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub tcpi_rto: u32,
    pub tcpi_ato: u32,
    pub tcpi_snd_mss: u32,
    pub tcpi_rcv_mss: u32,
    pub tcpi_unacked: u32,
    pub tcpi_sacked: u32,
    pub tcpi_lost: u32,
    pub tcpi_retrans: u32,
    pub tcpi_fackets: u32,
    pub tcpi_last_data_sent: u32,
    pub tcpi_last_ack_sent: u32,
    pub tcpi_last_data_recv: u32,
    pub tcpi_last_ack_recv: u32,
    pub tcpi_pmtu: u32,
    pub tcpi_rcv_ssthresh: u32,
    pub tcpi_rtt: u32,
    pub tcpi_rttvar: u32,
    pub tcpi_snd_ssthresh: u32,
    pub tcpi_snd_cwnd: u32,
    pub tcpi_advmss: u32,
    pub tcpi_reordering: u32,
    pub tcpi_rcv_rtt: u32,
    pub tcpi_rcv_space: u32,
    pub tcpi_total_retrans: u32,
}
#[test]
fn bindgen_test_layout_tcp_info() {
    const UNINIT: ::core::mem::MaybeUninit<tcp_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcp_info>(),
        104usize,
        concat!("Size of: ", stringify!(tcp_info))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_info>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_ca_state) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_ca_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_retransmits) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_retransmits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_probes) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_probes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_backoff) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_backoff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_options) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_options)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_rto) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rto)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_ato) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_ato)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_snd_mss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_mss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_rcv_mss) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_mss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_unacked) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_unacked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_sacked) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_sacked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_lost) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_lost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_retrans) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_retrans)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_fackets) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_fackets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_last_data_sent) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_data_sent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_last_ack_sent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_ack_sent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_last_data_recv) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_data_recv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_last_ack_recv) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_last_ack_recv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_pmtu) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_pmtu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_rcv_ssthresh) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_ssthresh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_rtt) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rtt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_rttvar) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rttvar)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_snd_ssthresh) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_ssthresh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_snd_cwnd) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_snd_cwnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_advmss) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_advmss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_reordering) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_reordering)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_rcv_rtt) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_rtt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_rcv_space) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_rcv_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpi_total_retrans) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_info),
            "::",
            stringify!(tcpi_total_retrans)
        )
    );
}
impl tcp_info {
    #[inline]
    pub fn tcpi_snd_wscale(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_snd_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_rcv_wscale(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_rcv_wscale(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcpi_snd_wscale: u8,
        tcpi_rcv_wscale: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let tcpi_snd_wscale: u8 = unsafe { ::core::mem::transmute(tcpi_snd_wscale) };
            tcpi_snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tcpi_rcv_wscale: u8 = unsafe { ::core::mem::transmute(tcpi_rcv_wscale) };
            tcpi_rcv_wscale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_md5sig {
    pub tcpm_addr: sockaddr_storage,
    pub tcpm_flags: u8,
    pub tcpm_prefixlen: u8,
    pub tcpm_keylen: u16,
    pub __tcpm_pad: u32,
    pub tcpm_key: [u8; 80usize],
}
#[test]
fn bindgen_test_layout_tcp_md5sig() {
    const UNINIT: ::core::mem::MaybeUninit<tcp_md5sig> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcp_md5sig>(),
        216usize,
        concat!("Size of: ", stringify!(tcp_md5sig))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_md5sig>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_md5sig))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpm_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpm_flags) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpm_prefixlen) as usize - ptr as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_prefixlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpm_keylen) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_keylen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tcpm_pad) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(__tcpm_pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpm_key) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_md5sig),
            "::",
            stringify!(tcpm_key)
        )
    );
}
impl Default for tcp_md5sig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tcp_repair_opt {
    pub opt_code: u32,
    pub opt_val: u32,
}
#[test]
fn bindgen_test_layout_tcp_repair_opt() {
    const UNINIT: ::core::mem::MaybeUninit<tcp_repair_opt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcp_repair_opt>(),
        8usize,
        concat!("Size of: ", stringify!(tcp_repair_opt))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_repair_opt>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_repair_opt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opt_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_opt),
            "::",
            stringify!(opt_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opt_val) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_opt),
            "::",
            stringify!(opt_val)
        )
    );
}
pub const TCP_NO_QUEUE: _bindgen_ty_34 = 0;
pub const TCP_RECV_QUEUE: _bindgen_ty_34 = 1;
pub const TCP_SEND_QUEUE: _bindgen_ty_34 = 2;
pub const TCP_QUEUES_NR: _bindgen_ty_34 = 3;
pub type _bindgen_ty_34 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_cookie_transactions {
    pub tcpct_flags: u16,
    pub __tcpct_pad1: u8,
    pub tcpct_cookie_desired: u8,
    pub tcpct_s_data_desired: u16,
    pub tcpct_used: u16,
    pub tcpct_value: [u8; 536usize],
}
#[test]
fn bindgen_test_layout_tcp_cookie_transactions() {
    const UNINIT: ::core::mem::MaybeUninit<tcp_cookie_transactions> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcp_cookie_transactions>(),
        544usize,
        concat!("Size of: ", stringify!(tcp_cookie_transactions))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_cookie_transactions>(),
        2usize,
        concat!("Alignment of ", stringify!(tcp_cookie_transactions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpct_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tcpct_pad1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(__tcpct_pad1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpct_cookie_desired) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_cookie_desired)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpct_s_data_desired) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_s_data_desired)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpct_used) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpct_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_cookie_transactions),
            "::",
            stringify!(tcpct_value)
        )
    );
}
impl Default for tcp_cookie_transactions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tcp_repair_window {
    pub snd_wl1: u32,
    pub snd_wnd: u32,
    pub max_window: u32,
    pub rcv_wnd: u32,
    pub rcv_wup: u32,
}
#[test]
fn bindgen_test_layout_tcp_repair_window() {
    const UNINIT: ::core::mem::MaybeUninit<tcp_repair_window> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcp_repair_window>(),
        20usize,
        concat!("Size of: ", stringify!(tcp_repair_window))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_repair_window>(),
        4usize,
        concat!("Alignment of ", stringify!(tcp_repair_window))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_wl1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(snd_wl1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).snd_wnd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(snd_wnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(max_window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcv_wnd) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(rcv_wnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcv_wup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_repair_window),
            "::",
            stringify!(rcv_wup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tcp_zerocopy_receive {
    pub address: u64,
    pub length: u32,
    pub recv_skip_hint: u32,
}
#[test]
fn bindgen_test_layout_tcp_zerocopy_receive() {
    const UNINIT: ::core::mem::MaybeUninit<tcp_zerocopy_receive> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tcp_zerocopy_receive>(),
        16usize,
        concat!("Size of: ", stringify!(tcp_zerocopy_receive))
    );
    assert_eq!(
        ::core::mem::align_of::<tcp_zerocopy_receive>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_zerocopy_receive))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recv_skip_hint) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tcp_zerocopy_receive),
            "::",
            stringify!(recv_skip_hint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut core::ffi::c_char,
    pub r_aliases: *mut *mut core::ffi::c_char,
    pub r_number: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_rpcent() {
    const UNINIT: ::core::mem::MaybeUninit<rpcent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rpcent>(),
        24usize,
        concat!("Size of: ", stringify!(rpcent))
    );
    assert_eq!(
        ::core::mem::align_of::<rpcent>(),
        8usize,
        concat!("Alignment of ", stringify!(rpcent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_aliases)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r_number) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rpcent),
            "::",
            stringify!(r_number)
        )
    );
}
impl Default for rpcent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut core::ffi::c_char,
    pub n_aliases: *mut *mut core::ffi::c_char,
    pub n_addrtype: core::ffi::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    const UNINIT: ::core::mem::MaybeUninit<netent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<netent>(),
        24usize,
        concat!("Size of: ", stringify!(netent))
    );
    assert_eq!(
        ::core::mem::align_of::<netent>(),
        8usize,
        concat!("Alignment of ", stringify!(netent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_aliases)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_addrtype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_addrtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_net) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netent),
            "::",
            stringify!(n_net)
        )
    );
}
impl Default for netent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut core::ffi::c_char,
    pub h_aliases: *mut *mut core::ffi::c_char,
    pub h_addrtype: core::ffi::c_int,
    pub h_length: core::ffi::c_int,
    pub h_addr_list: *mut *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    const UNINIT: ::core::mem::MaybeUninit<hostent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hostent>(),
        32usize,
        concat!("Size of: ", stringify!(hostent))
    );
    assert_eq!(
        ::core::mem::align_of::<hostent>(),
        8usize,
        concat!("Alignment of ", stringify!(hostent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_aliases)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_addrtype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addrtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h_addr_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hostent),
            "::",
            stringify!(h_addr_list)
        )
    );
}
impl Default for hostent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut core::ffi::c_char,
    pub s_aliases: *mut *mut core::ffi::c_char,
    pub s_port: core::ffi::c_int,
    pub s_proto: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    const UNINIT: ::core::mem::MaybeUninit<servent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<servent>(),
        32usize,
        concat!("Size of: ", stringify!(servent))
    );
    assert_eq!(
        ::core::mem::align_of::<servent>(),
        8usize,
        concat!("Alignment of ", stringify!(servent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_aliases)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s_port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s_proto) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(servent),
            "::",
            stringify!(s_proto)
        )
    );
}
impl Default for servent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut core::ffi::c_char,
    pub p_aliases: *mut *mut core::ffi::c_char,
    pub p_proto: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    const UNINIT: ::core::mem::MaybeUninit<protoent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<protoent>(),
        24usize,
        concat!("Size of: ", stringify!(protoent))
    );
    assert_eq!(
        ::core::mem::align_of::<protoent>(),
        8usize,
        concat!("Alignment of ", stringify!(protoent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_aliases) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_aliases)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_proto) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(protoent),
            "::",
            stringify!(p_proto)
        )
    );
}
impl Default for protoent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: core::ffi::c_int,
    pub ai_family: core::ffi::c_int,
    pub ai_socktype: core::ffi::c_int,
    pub ai_protocol: core::ffi::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut core::ffi::c_char,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    const UNINIT: ::core::mem::MaybeUninit<addrinfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ai_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ai_family) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ai_socktype) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_socktype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ai_protocol) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ai_addrlen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addrlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ai_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ai_canonname) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_canonname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ai_next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
impl Default for addrinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gaicb {
    pub ar_name: *const core::ffi::c_char,
    pub ar_service: *const core::ffi::c_char,
    pub ar_request: *const addrinfo,
    pub ar_result: *mut addrinfo,
    pub __return: core::ffi::c_int,
    pub __glibc_reserved: [core::ffi::c_int; 5usize],
}
#[test]
fn bindgen_test_layout_gaicb() {
    const UNINIT: ::core::mem::MaybeUninit<gaicb> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<gaicb>(),
        56usize,
        concat!("Size of: ", stringify!(gaicb))
    );
    assert_eq!(
        ::core::mem::align_of::<gaicb>(),
        8usize,
        concat!("Alignment of ", stringify!(gaicb))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ar_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(ar_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ar_service) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(ar_service)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ar_request) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(ar_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ar_result) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(ar_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__return) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(__return)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__glibc_reserved) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(gaicb),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
impl Default for gaicb {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_family: sa_family_t,
    pub sun_path: [core::ffi::c_char; 108usize],
}
#[test]
fn bindgen_test_layout_sockaddr_un() {
    const UNINIT: ::core::mem::MaybeUninit<sockaddr_un> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sockaddr_un>(),
        110usize,
        concat!("Size of: ", stringify!(sockaddr_un))
    );
    assert_eq!(
        ::core::mem::align_of::<sockaddr_un>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr_un))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sun_family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sun_path) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_un),
            "::",
            stringify!(sun_path)
        )
    );
}
impl Default for sockaddr_un {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelCPUState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Aml {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArchCPU {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BdrvDirtyBitmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BdrvDirtyBitmapIter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockBackend {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockBackendRootState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockDriverState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConfidentialGuestSupport {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUArchState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUPluginState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DirtyBitmapSnapshot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisasContextBase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DisplayChangeListener {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DriveInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DumpState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Error {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FWCfgState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HostMemoryBackend {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2CBus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct I2SCodec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISABus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISADevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IsaDma {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JSONWriter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MACAddr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachineClass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachineState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryMappingList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MigrationIncomingState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MigrationState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Monitor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MSIMessage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetClientState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NetFilterState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NICInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIBridge {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIBus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIEPort {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIESlot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIExpressDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIExpressHost {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIHostDeviceAddress {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCIHostState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QBool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QDict {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUBH {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuConsole {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUCursor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUFile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuOpts {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuOptsList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUSGList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QNull {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QNum {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QObject {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QString {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RAMBlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHPCDevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SSIBus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGCPUOps {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TCGHelperInfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TaskState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TranslationBlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtIODevice {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Visitor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VMChangeStateEntry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRQState {
    _unused: [u8; 0],
}
pub type qemu_irq = *mut IRQState;
pub type qemu_irq_handler = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut core::ffi::c_void,
        n: core::ffi::c_int,
        level: core::ffi::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_signalfd_siginfo {
    pub ssi_signo: u32,
    pub ssi_errno: i32,
    pub ssi_code: i32,
    pub ssi_pid: u32,
    pub ssi_uid: u32,
    pub ssi_fd: i32,
    pub ssi_tid: u32,
    pub ssi_band: u32,
    pub ssi_overrun: u32,
    pub ssi_trapno: u32,
    pub ssi_status: i32,
    pub ssi_int: i32,
    pub ssi_ptr: u64,
    pub ssi_utime: u64,
    pub ssi_stime: u64,
    pub ssi_addr: u64,
    pub pad: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_qemu_signalfd_siginfo() {
    const UNINIT: ::core::mem::MaybeUninit<qemu_signalfd_siginfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<qemu_signalfd_siginfo>(),
        128usize,
        concat!("Size of: ", stringify!(qemu_signalfd_siginfo))
    );
    assert_eq!(
        ::core::mem::align_of::<qemu_signalfd_siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(qemu_signalfd_siginfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_signo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_errno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_pid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_uid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_fd) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_fd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_tid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_tid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_band) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_band)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_overrun) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_overrun)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_trapno) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_trapno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_int) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_int)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_ptr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_utime) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_utime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_stime) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_stime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssi_addr) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(ssi_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(qemu_signalfd_siginfo),
            "::",
            stringify!(pad)
        )
    );
}
impl Default for qemu_signalfd_siginfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ThreadContext {
    _unused: [u8; 0],
}
pub const module_init_type_MODULE_INIT_MIGRATION: module_init_type = 0;
pub const module_init_type_MODULE_INIT_BLOCK: module_init_type = 1;
pub const module_init_type_MODULE_INIT_OPTS: module_init_type = 2;
pub const module_init_type_MODULE_INIT_QOM: module_init_type = 3;
pub const module_init_type_MODULE_INIT_TRACE: module_init_type = 4;
pub const module_init_type_MODULE_INIT_XEN_BACKEND: module_init_type = 5;
pub const module_init_type_MODULE_INIT_LIBQOS: module_init_type = 6;
pub const module_init_type_MODULE_INIT_FUZZ_TARGET: module_init_type = 7;
pub const module_init_type_MODULE_INIT_MAX: module_init_type = 8;
pub type module_init_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QemuModinfo {
    pub name: *const core::ffi::c_char,
    pub arch: *const core::ffi::c_char,
    pub objs: *mut *const core::ffi::c_char,
    pub deps: *mut *const core::ffi::c_char,
    pub opts: *mut *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_QemuModinfo() {
    const UNINIT: ::core::mem::MaybeUninit<QemuModinfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QemuModinfo>(),
        40usize,
        concat!("Size of: ", stringify!(QemuModinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<QemuModinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(QemuModinfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuModinfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuModinfo),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).objs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuModinfo),
            "::",
            stringify!(objs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deps) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuModinfo),
            "::",
            stringify!(deps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opts) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuModinfo),
            "::",
            stringify!(opts)
        )
    );
}
impl Default for QemuModinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cfunc_t = ::core::option::Option<
    unsafe extern "C" fn(
        blk: *mut BlockBackend,
        argc: core::ffi::c_int,
        argv: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_int,
>;
pub type helpfunc_t = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmdinfo {
    pub name: *const core::ffi::c_char,
    pub altname: *const core::ffi::c_char,
    pub cfunc: cfunc_t,
    pub argmin: core::ffi::c_int,
    pub argmax: core::ffi::c_int,
    pub canpush: core::ffi::c_int,
    pub flags: core::ffi::c_int,
    pub args: *const core::ffi::c_char,
    pub oneline: *const core::ffi::c_char,
    pub help: helpfunc_t,
    pub perm: u64,
}
#[test]
fn bindgen_test_layout_cmdinfo() {
    const UNINIT: ::core::mem::MaybeUninit<cmdinfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cmdinfo>(),
        72usize,
        concat!("Size of: ", stringify!(cmdinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<cmdinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(cmdinfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdinfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).altname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdinfo),
            "::",
            stringify!(altname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cfunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdinfo),
            "::",
            stringify!(cfunc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).argmin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdinfo),
            "::",
            stringify!(argmin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).argmax) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdinfo),
            "::",
            stringify!(argmax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).canpush) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdinfo),
            "::",
            stringify!(canpush)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdinfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdinfo),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oneline) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdinfo),
            "::",
            stringify!(oneline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).help) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdinfo),
            "::",
            stringify!(help)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).perm) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cmdinfo),
            "::",
            stringify!(perm)
        )
    );
}
impl Default for cmdinfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type cmdinfo_t = cmdinfo;
pub type Int128 = __int128_t;
pub type Int128Aligned = __int128_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union Int128Alias {
    pub u: Int128Alias___uint128_t,
    pub i: __int128_t,
    pub s: Int128,
}
#[test]
fn bindgen_test_layout_Int128Alias() {
    const UNINIT: ::core::mem::MaybeUninit<Int128Alias> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Int128Alias>(),
        16usize,
        concat!("Size of: ", stringify!(Int128Alias))
    );
    assert_eq!(
        ::core::mem::align_of::<Int128Alias>(),
        16usize,
        concat!("Alignment of ", stringify!(Int128Alias))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Int128Alias),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Int128Alias),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Int128Alias),
            "::",
            stringify!(s)
        )
    );
}
impl Default for Int128Alias {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for Int128Alias {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "Int128Alias {{ union }}")
    }
}
pub type aligned_int64_t = i64;
pub type aligned_uint64_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QTailQLink {
    pub tql_next: *mut core::ffi::c_void,
    pub tql_prev: *mut QTailQLink,
}
#[test]
fn bindgen_test_layout_QTailQLink() {
    const UNINIT: ::core::mem::MaybeUninit<QTailQLink> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QTailQLink>(),
        16usize,
        concat!("Size of: ", stringify!(QTailQLink))
    );
    assert_eq!(
        ::core::mem::align_of::<QTailQLink>(),
        8usize,
        concat!("Alignment of ", stringify!(QTailQLink))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tql_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QTailQLink),
            "::",
            stringify!(tql_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tql_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QTailQLink),
            "::",
            stringify!(tql_prev)
        )
    );
}
impl Default for QTailQLink {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Notifier {
    pub notify: ::core::option::Option<
        unsafe extern "C" fn(notifier: *mut Notifier, data: *mut core::ffi::c_void),
    >,
    pub node: Notifier__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Notifier__bindgen_ty_1 {
    pub le_next: *mut Notifier,
    pub le_prev: *mut *mut Notifier,
}
#[test]
fn bindgen_test_layout_Notifier__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<Notifier__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Notifier__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(Notifier__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<Notifier__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Notifier__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Notifier__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Notifier__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
impl Default for Notifier__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_Notifier() {
    const UNINIT: ::core::mem::MaybeUninit<Notifier> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Notifier>(),
        24usize,
        concat!("Size of: ", stringify!(Notifier))
    );
    assert_eq!(
        ::core::mem::align_of::<Notifier>(),
        8usize,
        concat!("Alignment of ", stringify!(Notifier))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Notifier),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Notifier),
            "::",
            stringify!(node)
        )
    );
}
impl Default for Notifier {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierList {
    pub notifiers: NotifierList__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierList__bindgen_ty_1 {
    pub lh_first: *mut Notifier,
}
#[test]
fn bindgen_test_layout_NotifierList__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<NotifierList__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotifierList__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(NotifierList__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NotifierList__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(NotifierList__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotifierList__bindgen_ty_1),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for NotifierList__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NotifierList() {
    const UNINIT: ::core::mem::MaybeUninit<NotifierList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotifierList>(),
        8usize,
        concat!("Size of: ", stringify!(NotifierList))
    );
    assert_eq!(
        ::core::mem::align_of::<NotifierList>(),
        8usize,
        concat!("Alignment of ", stringify!(NotifierList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notifiers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotifierList),
            "::",
            stringify!(notifiers)
        )
    );
}
impl Default for NotifierList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NotifierWithReturnFunc = ::core::option::Option<
    unsafe extern "C" fn(
        notifier: *mut NotifierWithReturn,
        data: *mut core::ffi::c_void,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierWithReturn {
    pub notify: NotifierWithReturnFunc,
    pub node: NotifierWithReturn__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierWithReturn__bindgen_ty_1 {
    pub le_next: *mut NotifierWithReturn,
    pub le_prev: *mut *mut NotifierWithReturn,
}
#[test]
fn bindgen_test_layout_NotifierWithReturn__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<NotifierWithReturn__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotifierWithReturn__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(NotifierWithReturn__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NotifierWithReturn__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NotifierWithReturn__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotifierWithReturn__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NotifierWithReturn__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
impl Default for NotifierWithReturn__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NotifierWithReturn() {
    const UNINIT: ::core::mem::MaybeUninit<NotifierWithReturn> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotifierWithReturn>(),
        24usize,
        concat!("Size of: ", stringify!(NotifierWithReturn))
    );
    assert_eq!(
        ::core::mem::align_of::<NotifierWithReturn>(),
        8usize,
        concat!("Alignment of ", stringify!(NotifierWithReturn))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotifierWithReturn),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NotifierWithReturn),
            "::",
            stringify!(node)
        )
    );
}
impl Default for NotifierWithReturn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierWithReturnList {
    pub notifiers: NotifierWithReturnList__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NotifierWithReturnList__bindgen_ty_1 {
    pub lh_first: *mut NotifierWithReturn,
}
#[test]
fn bindgen_test_layout_NotifierWithReturnList__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<NotifierWithReturnList__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotifierWithReturnList__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NotifierWithReturnList__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<NotifierWithReturnList__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(NotifierWithReturnList__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotifierWithReturnList__bindgen_ty_1),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for NotifierWithReturnList__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NotifierWithReturnList() {
    const UNINIT: ::core::mem::MaybeUninit<NotifierWithReturnList> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NotifierWithReturnList>(),
        8usize,
        concat!("Size of: ", stringify!(NotifierWithReturnList))
    );
    assert_eq!(
        ::core::mem::align_of::<NotifierWithReturnList>(),
        8usize,
        concat!("Alignment of ", stringify!(NotifierWithReturnList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notifiers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NotifierWithReturnList),
            "::",
            stringify!(notifiers)
        )
    );
}
impl Default for NotifierWithReturnList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const QEMUClockType_QEMU_CLOCK_REALTIME: QEMUClockType = 0;
pub const QEMUClockType_QEMU_CLOCK_VIRTUAL: QEMUClockType = 1;
pub const QEMUClockType_QEMU_CLOCK_HOST: QEMUClockType = 2;
pub const QEMUClockType_QEMU_CLOCK_VIRTUAL_RT: QEMUClockType = 3;
pub const QEMUClockType_QEMU_CLOCK_MAX: QEMUClockType = 4;
pub type QEMUClockType = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUTimerList {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUTimerListGroup {
    pub tl: [*mut QEMUTimerList; 4usize],
}
#[test]
fn bindgen_test_layout_QEMUTimerListGroup() {
    const UNINIT: ::core::mem::MaybeUninit<QEMUTimerListGroup> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QEMUTimerListGroup>(),
        32usize,
        concat!("Size of: ", stringify!(QEMUTimerListGroup))
    );
    assert_eq!(
        ::core::mem::align_of::<QEMUTimerListGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(QEMUTimerListGroup))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUTimerListGroup),
            "::",
            stringify!(tl)
        )
    );
}
impl Default for QEMUTimerListGroup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type QEMUTimerCB = ::core::option::Option<unsafe extern "C" fn(opaque: *mut core::ffi::c_void)>;
pub type QEMUTimerListNotifyCB = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut core::ffi::c_void, type_: QEMUClockType),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUTimer {
    pub expire_time: i64,
    pub timer_list: *mut QEMUTimerList,
    pub cb: QEMUTimerCB,
    pub opaque: *mut core::ffi::c_void,
    pub next: *mut QEMUTimer,
    pub attributes: core::ffi::c_int,
    pub scale: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_QEMUTimer() {
    const UNINIT: ::core::mem::MaybeUninit<QEMUTimer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QEMUTimer>(),
        48usize,
        concat!("Size of: ", stringify!(QEMUTimer))
    );
    assert_eq!(
        ::core::mem::align_of::<QEMUTimer>(),
        8usize,
        concat!("Alignment of ", stringify!(QEMUTimer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).expire_time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUTimer),
            "::",
            stringify!(expire_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timer_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUTimer),
            "::",
            stringify!(timer_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUTimer),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUTimer),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUTimer),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUTimer),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUTimer),
            "::",
            stringify!(scale)
        )
    );
}
impl Default for QEMUTimer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QemuUUID {
    pub __bindgen_anon_1: QemuUUID__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union QemuUUID__bindgen_ty_1 {
    pub data: [core::ffi::c_uchar; 16usize],
    pub fields: QemuUUID__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QemuUUID__bindgen_ty_1__bindgen_ty_1 {
    pub time_low: u32,
    pub time_mid: u16,
    pub time_high_and_version: u16,
    pub clock_seq_and_reserved: u8,
    pub clock_seq_low: u8,
    pub node: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_QemuUUID__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<QemuUUID__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QemuUUID__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(QemuUUID__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<QemuUUID__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(QemuUUID__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuUUID__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(time_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_mid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuUUID__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(time_mid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_high_and_version) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuUUID__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(time_high_and_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clock_seq_and_reserved) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuUUID__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(clock_seq_and_reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clock_seq_low) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuUUID__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(clock_seq_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuUUID__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(node)
        )
    );
}
#[test]
fn bindgen_test_layout_QemuUUID__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<QemuUUID__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QemuUUID__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(QemuUUID__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<QemuUUID__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(QemuUUID__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuUUID__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuUUID__bindgen_ty_1),
            "::",
            stringify!(fields)
        )
    );
}
impl Default for QemuUUID__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for QemuUUID__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "QemuUUID__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_QemuUUID() {
    assert_eq!(
        ::core::mem::size_of::<QemuUUID>(),
        16usize,
        concat!("Size of: ", stringify!(QemuUUID))
    );
    assert_eq!(
        ::core::mem::align_of::<QemuUUID>(),
        4usize,
        concat!("Alignment of ", stringify!(QemuUUID))
    );
}
impl Default for QemuUUID {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for QemuUUID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "QemuUUID {{ __bindgen_anon_1: {:?} }}",
            self.__bindgen_anon_1
        )
    }
}
pub const VGAInterfaceType_VGA_NONE: VGAInterfaceType = 0;
pub const VGAInterfaceType_VGA_STD: VGAInterfaceType = 1;
pub const VGAInterfaceType_VGA_CIRRUS: VGAInterfaceType = 2;
pub const VGAInterfaceType_VGA_VMWARE: VGAInterfaceType = 3;
pub const VGAInterfaceType_VGA_XENFB: VGAInterfaceType = 4;
pub const VGAInterfaceType_VGA_QXL: VGAInterfaceType = 5;
pub const VGAInterfaceType_VGA_TCX: VGAInterfaceType = 6;
pub const VGAInterfaceType_VGA_CG3: VGAInterfaceType = 7;
pub const VGAInterfaceType_VGA_DEVICE: VGAInterfaceType = 8;
pub const VGAInterfaceType_VGA_VIRTIO: VGAInterfaceType = 9;
pub const VGAInterfaceType_VGA_TYPE_MAX: VGAInterfaceType = 10;
pub type VGAInterfaceType = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEMUOptionRom {
    pub name: *const core::ffi::c_char,
    pub bootindex: i32,
}
#[test]
fn bindgen_test_layout_QEMUOptionRom() {
    const UNINIT: ::core::mem::MaybeUninit<QEMUOptionRom> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QEMUOptionRom>(),
        16usize,
        concat!("Size of: ", stringify!(QEMUOptionRom))
    );
    assert_eq!(
        ::core::mem::align_of::<QEMUOptionRom>(),
        8usize,
        concat!("Alignment of ", stringify!(QEMUOptionRom))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUOptionRom),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bootindex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUOptionRom),
            "::",
            stringify!(bootindex)
        )
    );
}
impl Default for QEMUOptionRom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type QEMUBootSetHandler = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut core::ffi::c_void,
        boot_order: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [core::ffi::c_char; 32usize],
    pub __align: core::ffi::c_long,
}
#[test]
fn bindgen_test_layout_sem_t() {
    const UNINIT: ::core::mem::MaybeUninit<sem_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sem_t>(),
        32usize,
        concat!("Size of: ", stringify!(sem_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sem_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sem_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for sem_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for sem_t {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "sem_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QemuMutex {
    pub lock: pthread_mutex_t,
    pub file: *const core::ffi::c_char,
    pub line: core::ffi::c_int,
    pub initialized: bool,
}
#[test]
fn bindgen_test_layout_QemuMutex() {
    const UNINIT: ::core::mem::MaybeUninit<QemuMutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QemuMutex>(),
        56usize,
        concat!("Size of: ", stringify!(QemuMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<QemuMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(QemuMutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuMutex),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuMutex),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuMutex),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuMutex),
            "::",
            stringify!(initialized)
        )
    );
}
impl Default for QemuMutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for QemuMutex {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "QemuMutex {{ lock: {:?}, file: {:?}, line: {:?}, initialized: {:?} }}",
            self.lock, self.file, self.line, self.initialized
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QemuRecMutex {
    pub m: QemuMutex,
}
#[test]
fn bindgen_test_layout_QemuRecMutex() {
    const UNINIT: ::core::mem::MaybeUninit<QemuRecMutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QemuRecMutex>(),
        56usize,
        concat!("Size of: ", stringify!(QemuRecMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<QemuRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(QemuRecMutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuRecMutex),
            "::",
            stringify!(m)
        )
    );
}
impl Default for QemuRecMutex {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for QemuRecMutex {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "QemuRecMutex {{ m: {:?} }}", self.m)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QemuCond {
    pub cond: pthread_cond_t,
    pub initialized: bool,
}
#[test]
fn bindgen_test_layout_QemuCond() {
    const UNINIT: ::core::mem::MaybeUninit<QemuCond> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QemuCond>(),
        56usize,
        concat!("Size of: ", stringify!(QemuCond))
    );
    assert_eq!(
        ::core::mem::align_of::<QemuCond>(),
        8usize,
        concat!("Alignment of ", stringify!(QemuCond))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cond) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuCond),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuCond),
            "::",
            stringify!(initialized)
        )
    );
}
impl Default for QemuCond {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for QemuCond {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "QemuCond {{ cond: {:?}, initialized: {:?} }}",
            self.cond, self.initialized
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct QemuSemaphore {
    pub mutex: QemuMutex,
    pub cond: QemuCond,
    pub count: core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_QemuSemaphore() {
    const UNINIT: ::core::mem::MaybeUninit<QemuSemaphore> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QemuSemaphore>(),
        120usize,
        concat!("Size of: ", stringify!(QemuSemaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<QemuSemaphore>(),
        8usize,
        concat!("Alignment of ", stringify!(QemuSemaphore))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuSemaphore),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cond) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuSemaphore),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuSemaphore),
            "::",
            stringify!(count)
        )
    );
}
impl Default for QemuSemaphore {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for QemuSemaphore {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "QemuSemaphore {{ mutex: {:?}, cond: {:?}, count: {:?} }}",
            self.mutex, self.cond, self.count
        )
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QemuEvent {
    pub value: core::ffi::c_uint,
    pub initialized: bool,
}
#[test]
fn bindgen_test_layout_QemuEvent() {
    const UNINIT: ::core::mem::MaybeUninit<QemuEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QemuEvent>(),
        8usize,
        concat!("Size of: ", stringify!(QemuEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<QemuEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(QemuEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuEvent),
            "::",
            stringify!(initialized)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QemuThread {
    pub thread: pthread_t,
}
#[test]
fn bindgen_test_layout_QemuThread() {
    const UNINIT: ::core::mem::MaybeUninit<QemuThread> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QemuThread>(),
        8usize,
        concat!("Size of: ", stringify!(QemuThread))
    );
    assert_eq!(
        ::core::mem::align_of::<QemuThread>(),
        8usize,
        concat!("Alignment of ", stringify!(QemuThread))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuThread),
            "::",
            stringify!(thread)
        )
    );
}
pub const QSPSortBy_QSP_SORT_BY_TOTAL_WAIT_TIME: QSPSortBy = 0;
pub const QSPSortBy_QSP_SORT_BY_AVG_WAIT_TIME: QSPSortBy = 1;
pub type QSPSortBy = core::ffi::c_uint;
pub type QemuMutexLockFunc = ::core::option::Option<
    unsafe extern "C" fn(m: *mut QemuMutex, f: *const core::ffi::c_char, l: core::ffi::c_int),
>;
pub type QemuMutexTrylockFunc = ::core::option::Option<
    unsafe extern "C" fn(
        m: *mut QemuMutex,
        f: *const core::ffi::c_char,
        l: core::ffi::c_int,
    ) -> core::ffi::c_int,
>;
pub type QemuRecMutexLockFunc = ::core::option::Option<
    unsafe extern "C" fn(m: *mut QemuRecMutex, f: *const core::ffi::c_char, l: core::ffi::c_int),
>;
pub type QemuRecMutexTrylockFunc = ::core::option::Option<
    unsafe extern "C" fn(
        m: *mut QemuRecMutex,
        f: *const core::ffi::c_char,
        l: core::ffi::c_int,
    ) -> core::ffi::c_int,
>;
pub type QemuCondWaitFunc = ::core::option::Option<
    unsafe extern "C" fn(
        c: *mut QemuCond,
        m: *mut QemuMutex,
        f: *const core::ffi::c_char,
        l: core::ffi::c_int,
    ),
>;
pub type QemuCondTimedWaitFunc = ::core::option::Option<
    unsafe extern "C" fn(
        c: *mut QemuCond,
        m: *mut QemuMutex,
        ms: core::ffi::c_int,
        f: *const core::ffi::c_char,
        l: core::ffi::c_int,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QemuSpin {
    pub value: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_QemuSpin() {
    const UNINIT: ::core::mem::MaybeUninit<QemuSpin> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QemuSpin>(),
        4usize,
        concat!("Size of: ", stringify!(QemuSpin))
    );
    assert_eq!(
        ::core::mem::align_of::<QemuSpin>(),
        4usize,
        concat!("Alignment of ", stringify!(QemuSpin))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuSpin),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QemuLockCnt {
    pub count: core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_QemuLockCnt() {
    const UNINIT: ::core::mem::MaybeUninit<QemuLockCnt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QemuLockCnt>(),
        4usize,
        concat!("Size of: ", stringify!(QemuLockCnt))
    );
    assert_eq!(
        ::core::mem::align_of::<QemuLockCnt>(),
        4usize,
        concat!("Alignment of ", stringify!(QemuLockCnt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QemuLockCnt),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_reader_data {
    pub ctr: core::ffi::c_ulong,
    pub waiting: bool,
    pub depth: core::ffi::c_uint,
    pub node: rcu_reader_data__bindgen_ty_1,
    pub force_rcu: NotifierList,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_reader_data__bindgen_ty_1 {
    pub le_next: *mut rcu_reader_data,
    pub le_prev: *mut *mut rcu_reader_data,
}
#[test]
fn bindgen_test_layout_rcu_reader_data__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<rcu_reader_data__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rcu_reader_data__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rcu_reader_data__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<rcu_reader_data__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_reader_data__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_reader_data__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_reader_data__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
impl Default for rcu_reader_data__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_rcu_reader_data() {
    const UNINIT: ::core::mem::MaybeUninit<rcu_reader_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rcu_reader_data>(),
        40usize,
        concat!("Size of: ", stringify!(rcu_reader_data))
    );
    assert_eq!(
        ::core::mem::align_of::<rcu_reader_data>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_reader_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_reader_data),
            "::",
            stringify!(ctr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waiting) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_reader_data),
            "::",
            stringify!(waiting)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_reader_data),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_reader_data),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).force_rcu) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_reader_data),
            "::",
            stringify!(force_rcu)
        )
    );
}
impl Default for rcu_reader_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type RCUCBFunc = ::core::option::Option<unsafe extern "C" fn(head: *mut rcu_head)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rcu_head {
    pub next: *mut rcu_head,
    pub func: RCUCBFunc,
}
#[test]
fn bindgen_test_layout_rcu_head() {
    const UNINIT: ::core::mem::MaybeUninit<rcu_head> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rcu_head>(),
        16usize,
        concat!("Size of: ", stringify!(rcu_head))
    );
    assert_eq!(
        ::core::mem::align_of::<rcu_head>(),
        8usize,
        concat!("Alignment of ", stringify!(rcu_head))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_head),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rcu_head),
            "::",
            stringify!(func)
        )
    );
}
impl Default for rcu_head {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type RCUReadAuto = core::ffi::c_void;
pub const QapiSpecialFeature_QAPI_DEPRECATED: QapiSpecialFeature = 0;
pub const QapiSpecialFeature_QAPI_UNSTABLE: QapiSpecialFeature = 1;
pub type QapiSpecialFeature = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QEnumLookup {
    pub array: *const *const core::ffi::c_char,
    pub special_features: *const core::ffi::c_uchar,
    pub size: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_QEnumLookup() {
    const UNINIT: ::core::mem::MaybeUninit<QEnumLookup> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QEnumLookup>(),
        24usize,
        concat!("Size of: ", stringify!(QEnumLookup))
    );
    assert_eq!(
        ::core::mem::align_of::<QEnumLookup>(),
        8usize,
        concat!("Alignment of ", stringify!(QEnumLookup))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QEnumLookup),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).special_features) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QEnumLookup),
            "::",
            stringify!(special_features)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(QEnumLookup),
            "::",
            stringify!(size)
        )
    );
}
impl Default for QEnumLookup {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const QType_QTYPE_NONE: QType = 0;
pub const QType_QTYPE_QNULL: QType = 1;
pub const QType_QTYPE_QNUM: QType = 2;
pub const QType_QTYPE_QSTRING: QType = 3;
pub const QType_QTYPE_QDICT: QType = 4;
pub const QType_QTYPE_QLIST: QType = 5;
pub const QType_QTYPE_QBOOL: QType = 6;
pub const QType_QTYPE__MAX: QType = 7;
pub type QType = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct strList {
    pub next: *mut strList,
    pub value: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_strList() {
    const UNINIT: ::core::mem::MaybeUninit<strList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<strList>(),
        16usize,
        concat!("Size of: ", stringify!(strList))
    );
    assert_eq!(
        ::core::mem::align_of::<strList>(),
        8usize,
        concat!("Alignment of ", stringify!(strList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(strList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(strList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for strList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct numberList {
    pub next: *mut numberList,
    pub value: f64,
}
#[test]
fn bindgen_test_layout_numberList() {
    const UNINIT: ::core::mem::MaybeUninit<numberList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<numberList>(),
        16usize,
        concat!("Size of: ", stringify!(numberList))
    );
    assert_eq!(
        ::core::mem::align_of::<numberList>(),
        8usize,
        concat!("Alignment of ", stringify!(numberList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(numberList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(numberList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for numberList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intList {
    pub next: *mut intList,
    pub value: i64,
}
#[test]
fn bindgen_test_layout_intList() {
    const UNINIT: ::core::mem::MaybeUninit<intList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<intList>(),
        16usize,
        concat!("Size of: ", stringify!(intList))
    );
    assert_eq!(
        ::core::mem::align_of::<intList>(),
        8usize,
        concat!("Alignment of ", stringify!(intList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(intList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(intList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for intList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int8List {
    pub next: *mut int8List,
    pub value: i8,
}
#[test]
fn bindgen_test_layout_int8List() {
    const UNINIT: ::core::mem::MaybeUninit<int8List> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<int8List>(),
        16usize,
        concat!("Size of: ", stringify!(int8List))
    );
    assert_eq!(
        ::core::mem::align_of::<int8List>(),
        8usize,
        concat!("Alignment of ", stringify!(int8List))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(int8List),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(int8List),
            "::",
            stringify!(value)
        )
    );
}
impl Default for int8List {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int16List {
    pub next: *mut int16List,
    pub value: i16,
}
#[test]
fn bindgen_test_layout_int16List() {
    const UNINIT: ::core::mem::MaybeUninit<int16List> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<int16List>(),
        16usize,
        concat!("Size of: ", stringify!(int16List))
    );
    assert_eq!(
        ::core::mem::align_of::<int16List>(),
        8usize,
        concat!("Alignment of ", stringify!(int16List))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(int16List),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(int16List),
            "::",
            stringify!(value)
        )
    );
}
impl Default for int16List {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int32List {
    pub next: *mut int32List,
    pub value: i32,
}
#[test]
fn bindgen_test_layout_int32List() {
    const UNINIT: ::core::mem::MaybeUninit<int32List> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<int32List>(),
        16usize,
        concat!("Size of: ", stringify!(int32List))
    );
    assert_eq!(
        ::core::mem::align_of::<int32List>(),
        8usize,
        concat!("Alignment of ", stringify!(int32List))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(int32List),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(int32List),
            "::",
            stringify!(value)
        )
    );
}
impl Default for int32List {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int64List {
    pub next: *mut int64List,
    pub value: i64,
}
#[test]
fn bindgen_test_layout_int64List() {
    const UNINIT: ::core::mem::MaybeUninit<int64List> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<int64List>(),
        16usize,
        concat!("Size of: ", stringify!(int64List))
    );
    assert_eq!(
        ::core::mem::align_of::<int64List>(),
        8usize,
        concat!("Alignment of ", stringify!(int64List))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(int64List),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(int64List),
            "::",
            stringify!(value)
        )
    );
}
impl Default for int64List {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint8List {
    pub next: *mut uint8List,
    pub value: u8,
}
#[test]
fn bindgen_test_layout_uint8List() {
    const UNINIT: ::core::mem::MaybeUninit<uint8List> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<uint8List>(),
        16usize,
        concat!("Size of: ", stringify!(uint8List))
    );
    assert_eq!(
        ::core::mem::align_of::<uint8List>(),
        8usize,
        concat!("Alignment of ", stringify!(uint8List))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uint8List),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uint8List),
            "::",
            stringify!(value)
        )
    );
}
impl Default for uint8List {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint16List {
    pub next: *mut uint16List,
    pub value: u16,
}
#[test]
fn bindgen_test_layout_uint16List() {
    const UNINIT: ::core::mem::MaybeUninit<uint16List> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<uint16List>(),
        16usize,
        concat!("Size of: ", stringify!(uint16List))
    );
    assert_eq!(
        ::core::mem::align_of::<uint16List>(),
        8usize,
        concat!("Alignment of ", stringify!(uint16List))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uint16List),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uint16List),
            "::",
            stringify!(value)
        )
    );
}
impl Default for uint16List {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint32List {
    pub next: *mut uint32List,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_uint32List() {
    const UNINIT: ::core::mem::MaybeUninit<uint32List> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<uint32List>(),
        16usize,
        concat!("Size of: ", stringify!(uint32List))
    );
    assert_eq!(
        ::core::mem::align_of::<uint32List>(),
        8usize,
        concat!("Alignment of ", stringify!(uint32List))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uint32List),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uint32List),
            "::",
            stringify!(value)
        )
    );
}
impl Default for uint32List {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint64List {
    pub next: *mut uint64List,
    pub value: u64,
}
#[test]
fn bindgen_test_layout_uint64List() {
    const UNINIT: ::core::mem::MaybeUninit<uint64List> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<uint64List>(),
        16usize,
        concat!("Size of: ", stringify!(uint64List))
    );
    assert_eq!(
        ::core::mem::align_of::<uint64List>(),
        8usize,
        concat!("Alignment of ", stringify!(uint64List))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uint64List),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uint64List),
            "::",
            stringify!(value)
        )
    );
}
impl Default for uint64List {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sizeList {
    pub next: *mut sizeList,
    pub value: u64,
}
#[test]
fn bindgen_test_layout_sizeList() {
    const UNINIT: ::core::mem::MaybeUninit<sizeList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sizeList>(),
        16usize,
        concat!("Size of: ", stringify!(sizeList))
    );
    assert_eq!(
        ::core::mem::align_of::<sizeList>(),
        8usize,
        concat!("Alignment of ", stringify!(sizeList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sizeList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sizeList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for sizeList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct boolList {
    pub next: *mut boolList,
    pub value: bool,
}
#[test]
fn bindgen_test_layout_boolList() {
    const UNINIT: ::core::mem::MaybeUninit<boolList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<boolList>(),
        16usize,
        concat!("Size of: ", stringify!(boolList))
    );
    assert_eq!(
        ::core::mem::align_of::<boolList>(),
        8usize,
        concat!("Alignment of ", stringify!(boolList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(boolList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(boolList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for boolList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct anyList {
    pub next: *mut anyList,
    pub value: *mut QObject,
}
#[test]
fn bindgen_test_layout_anyList() {
    const UNINIT: ::core::mem::MaybeUninit<anyList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<anyList>(),
        16usize,
        concat!("Size of: ", stringify!(anyList))
    );
    assert_eq!(
        ::core::mem::align_of::<anyList>(),
        8usize,
        concat!("Alignment of ", stringify!(anyList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(anyList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(anyList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for anyList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nullList {
    pub next: *mut nullList,
    pub value: *mut QNull,
}
#[test]
fn bindgen_test_layout_nullList() {
    const UNINIT: ::core::mem::MaybeUninit<nullList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<nullList>(),
        16usize,
        concat!("Size of: ", stringify!(nullList))
    );
    assert_eq!(
        ::core::mem::align_of::<nullList>(),
        8usize,
        concat!("Alignment of ", stringify!(nullList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nullList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nullList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for nullList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeImpl {
    _unused: [u8; 0],
}
pub type Type = *mut TypeImpl;
pub type ObjectPropertyAccessor = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut Object,
        v: *mut Visitor,
        name: *const core::ffi::c_char,
        opaque: *mut core::ffi::c_void,
        errp: *mut *mut Error,
    ),
>;
pub type ObjectPropertyResolve = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut Object,
        opaque: *mut core::ffi::c_void,
        part: *const core::ffi::c_char,
    ) -> *mut Object,
>;
pub type ObjectPropertyRelease = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        opaque: *mut core::ffi::c_void,
    ),
>;
pub type ObjectPropertyInit =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut Object, prop: *mut ObjectProperty)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectProperty {
    pub name: *mut core::ffi::c_char,
    pub type_: *mut core::ffi::c_char,
    pub description: *mut core::ffi::c_char,
    pub get: ObjectPropertyAccessor,
    pub set: ObjectPropertyAccessor,
    pub resolve: ObjectPropertyResolve,
    pub release: ObjectPropertyRelease,
    pub init: ObjectPropertyInit,
    pub opaque: *mut core::ffi::c_void,
    pub defval: *mut QObject,
}
#[test]
fn bindgen_test_layout_ObjectProperty() {
    const UNINIT: ::core::mem::MaybeUninit<ObjectProperty> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ObjectProperty>(),
        80usize,
        concat!("Size of: ", stringify!(ObjectProperty))
    );
    assert_eq!(
        ::core::mem::align_of::<ObjectProperty>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjectProperty))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectProperty),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectProperty),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectProperty),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectProperty),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectProperty),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resolve) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectProperty),
            "::",
            stringify!(resolve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectProperty),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectProperty),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectProperty),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).defval) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectProperty),
            "::",
            stringify!(defval)
        )
    );
}
impl Default for ObjectProperty {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ObjectUnparent = ::core::option::Option<unsafe extern "C" fn(obj: *mut Object)>;
pub type ObjectFree = ::core::option::Option<unsafe extern "C" fn(obj: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectClass {
    pub type_: Type,
    pub interfaces: *mut GSList,
    pub object_cast_cache: [*const core::ffi::c_char; 4usize],
    pub class_cast_cache: [*const core::ffi::c_char; 4usize],
    pub unparent: ObjectUnparent,
    pub properties: *mut GHashTable,
}
#[test]
fn bindgen_test_layout_ObjectClass() {
    const UNINIT: ::core::mem::MaybeUninit<ObjectClass> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ObjectClass>(),
        96usize,
        concat!("Size of: ", stringify!(ObjectClass))
    );
    assert_eq!(
        ::core::mem::align_of::<ObjectClass>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjectClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectClass),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interfaces) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectClass),
            "::",
            stringify!(interfaces)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).object_cast_cache) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectClass),
            "::",
            stringify!(object_cast_cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class_cast_cache) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectClass),
            "::",
            stringify!(class_cast_cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unparent) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectClass),
            "::",
            stringify!(unparent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectClass),
            "::",
            stringify!(properties)
        )
    );
}
impl Default for ObjectClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Object {
    pub class: *mut ObjectClass,
    pub free: ObjectFree,
    pub properties: *mut GHashTable,
    pub ref_: u32,
    pub parent: *mut Object,
}
#[test]
fn bindgen_test_layout_Object() {
    const UNINIT: ::core::mem::MaybeUninit<Object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Object>(),
        40usize,
        concat!("Size of: ", stringify!(Object))
    );
    assert_eq!(
        ::core::mem::align_of::<Object>(),
        8usize,
        concat!("Alignment of ", stringify!(Object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Object),
            "::",
            stringify!(parent)
        )
    );
}
impl Default for Object {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeInfo {
    pub name: *const core::ffi::c_char,
    pub parent: *const core::ffi::c_char,
    pub instance_size: usize,
    pub instance_align: usize,
    pub instance_init: ::core::option::Option<unsafe extern "C" fn(obj: *mut Object)>,
    pub instance_post_init: ::core::option::Option<unsafe extern "C" fn(obj: *mut Object)>,
    pub instance_finalize: ::core::option::Option<unsafe extern "C" fn(obj: *mut Object)>,
    pub abstract_: bool,
    pub class_size: usize,
    pub class_init: ::core::option::Option<
        unsafe extern "C" fn(klass: *mut ObjectClass, data: *mut core::ffi::c_void),
    >,
    pub class_base_init: ::core::option::Option<
        unsafe extern "C" fn(klass: *mut ObjectClass, data: *mut core::ffi::c_void),
    >,
    pub class_data: *mut core::ffi::c_void,
    pub interfaces: *mut InterfaceInfo,
}
#[test]
fn bindgen_test_layout_TypeInfo() {
    const UNINIT: ::core::mem::MaybeUninit<TypeInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TypeInfo>(),
        104usize,
        concat!("Size of: ", stringify!(TypeInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<TypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(TypeInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).instance_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(instance_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).instance_align) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(instance_align)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).instance_init) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(instance_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).instance_post_init) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(instance_post_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).instance_finalize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(instance_finalize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).abstract_) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(abstract_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(class_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class_init) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(class_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class_base_init) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(class_base_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class_data) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(class_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interfaces) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(interfaces)
        )
    );
}
impl Default for TypeInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InterfaceInfo {
    pub type_: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_InterfaceInfo() {
    const UNINIT: ::core::mem::MaybeUninit<InterfaceInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InterfaceInfo>(),
        8usize,
        concat!("Size of: ", stringify!(InterfaceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<InterfaceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(InterfaceInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InterfaceInfo),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for InterfaceInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InterfaceClass {
    pub parent_class: ObjectClass,
    pub concrete_class: *mut ObjectClass,
    pub interface_type: Type,
}
#[test]
fn bindgen_test_layout_InterfaceClass() {
    const UNINIT: ::core::mem::MaybeUninit<InterfaceClass> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InterfaceClass>(),
        112usize,
        concat!("Size of: ", stringify!(InterfaceClass))
    );
    assert_eq!(
        ::core::mem::align_of::<InterfaceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(InterfaceClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InterfaceClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).concrete_class) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(InterfaceClass),
            "::",
            stringify!(concrete_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interface_type) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(InterfaceClass),
            "::",
            stringify!(interface_type)
        )
    );
}
impl Default for InterfaceClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ObjectPropertyIterator {
    pub nextclass: *mut ObjectClass,
    pub iter: GHashTableIter,
}
#[test]
fn bindgen_test_layout_ObjectPropertyIterator() {
    const UNINIT: ::core::mem::MaybeUninit<ObjectPropertyIterator> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ObjectPropertyIterator>(),
        48usize,
        concat!("Size of: ", stringify!(ObjectPropertyIterator))
    );
    assert_eq!(
        ::core::mem::align_of::<ObjectPropertyIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(ObjectPropertyIterator))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nextclass) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectPropertyIterator),
            "::",
            stringify!(nextclass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ObjectPropertyIterator),
            "::",
            stringify!(iter)
        )
    );
}
impl Default for ObjectPropertyIterator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ObjectPropertyLinkFlags_OBJ_PROP_LINK_STRONG: ObjectPropertyLinkFlags = 1;
pub const ObjectPropertyLinkFlags_OBJ_PROP_LINK_DIRECT: ObjectPropertyLinkFlags = 2;
pub const ObjectPropertyLinkFlags_OBJ_PROP_LINK_CLASS: ObjectPropertyLinkFlags = 4;
pub type ObjectPropertyLinkFlags = core::ffi::c_uint;
pub const ObjectPropertyFlags_OBJ_PROP_FLAG_READ: ObjectPropertyFlags = 1;
pub const ObjectPropertyFlags_OBJ_PROP_FLAG_WRITE: ObjectPropertyFlags = 2;
pub const ObjectPropertyFlags_OBJ_PROP_FLAG_READWRITE: ObjectPropertyFlags = 3;
pub type ObjectPropertyFlags = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HotplugHandler {
    _unused: [u8; 0],
}
pub type hotplug_fn = ::core::option::Option<
    unsafe extern "C" fn(
        plug_handler: *mut HotplugHandler,
        plugged_dev: *mut DeviceState,
        errp: *mut *mut Error,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HotplugHandlerClass {
    pub parent: InterfaceClass,
    pub pre_plug: hotplug_fn,
    pub plug: hotplug_fn,
    pub unplug_request: hotplug_fn,
    pub unplug: hotplug_fn,
    pub is_hotpluggable_bus: ::core::option::Option<
        unsafe extern "C" fn(plug_handler: *mut HotplugHandler, bus: *mut BusState) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_HotplugHandlerClass() {
    const UNINIT: ::core::mem::MaybeUninit<HotplugHandlerClass> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HotplugHandlerClass>(),
        152usize,
        concat!("Size of: ", stringify!(HotplugHandlerClass))
    );
    assert_eq!(
        ::core::mem::align_of::<HotplugHandlerClass>(),
        8usize,
        concat!("Alignment of ", stringify!(HotplugHandlerClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HotplugHandlerClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pre_plug) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(HotplugHandlerClass),
            "::",
            stringify!(pre_plug)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plug) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(HotplugHandlerClass),
            "::",
            stringify!(plug)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unplug_request) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(HotplugHandlerClass),
            "::",
            stringify!(unplug_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unplug) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(HotplugHandlerClass),
            "::",
            stringify!(unplug)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_hotpluggable_bus) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(HotplugHandlerClass),
            "::",
            stringify!(is_hotpluggable_bus)
        )
    );
}
impl Default for HotplugHandlerClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const ResetType_RESET_TYPE_COLD: ResetType = 0;
pub const ResetType_RESET_TYPE_SNAPSHOT_LOAD: ResetType = 1;
pub type ResetType = core::ffi::c_uint;
pub type ResettableEnterPhase =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut Object, type_: ResetType)>;
pub type ResettableHoldPhase =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut Object, type_: ResetType)>;
pub type ResettableExitPhase =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut Object, type_: ResetType)>;
pub type ResettableGetState =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut Object) -> *mut ResettableState>;
pub type ResettableTrFunction = ::core::option::Option<unsafe extern "C" fn(obj: *mut Object)>;
pub type ResettableGetTrFunction =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut Object) -> ResettableTrFunction>;
pub type ResettableChildCallback = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut Object, opaque: *mut core::ffi::c_void, type_: ResetType),
>;
pub type ResettableChildForeach = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut Object,
        cb: ResettableChildCallback,
        opaque: *mut core::ffi::c_void,
        type_: ResetType,
    ),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ResettablePhases {
    pub enter: ResettableEnterPhase,
    pub hold: ResettableHoldPhase,
    pub exit: ResettableExitPhase,
}
#[test]
fn bindgen_test_layout_ResettablePhases() {
    const UNINIT: ::core::mem::MaybeUninit<ResettablePhases> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ResettablePhases>(),
        24usize,
        concat!("Size of: ", stringify!(ResettablePhases))
    );
    assert_eq!(
        ::core::mem::align_of::<ResettablePhases>(),
        8usize,
        concat!("Alignment of ", stringify!(ResettablePhases))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ResettablePhases),
            "::",
            stringify!(enter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hold) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ResettablePhases),
            "::",
            stringify!(hold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ResettablePhases),
            "::",
            stringify!(exit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ResettableClass {
    pub parent_class: InterfaceClass,
    pub phases: ResettablePhases,
    pub get_state: ResettableGetState,
    pub get_transitional_function: ResettableGetTrFunction,
    pub child_foreach: ResettableChildForeach,
}
#[test]
fn bindgen_test_layout_ResettableClass() {
    const UNINIT: ::core::mem::MaybeUninit<ResettableClass> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ResettableClass>(),
        160usize,
        concat!("Size of: ", stringify!(ResettableClass))
    );
    assert_eq!(
        ::core::mem::align_of::<ResettableClass>(),
        8usize,
        concat!("Alignment of ", stringify!(ResettableClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ResettableClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phases) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ResettableClass),
            "::",
            stringify!(phases)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_state) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ResettableClass),
            "::",
            stringify!(get_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_transitional_function) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ResettableClass),
            "::",
            stringify!(get_transitional_function)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).child_foreach) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ResettableClass),
            "::",
            stringify!(child_foreach)
        )
    );
}
impl Default for ResettableClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ResettableState {
    pub count: core::ffi::c_uint,
    pub hold_phase_pending: bool,
    pub exit_phase_in_progress: bool,
}
#[test]
fn bindgen_test_layout_ResettableState() {
    const UNINIT: ::core::mem::MaybeUninit<ResettableState> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ResettableState>(),
        8usize,
        concat!("Size of: ", stringify!(ResettableState))
    );
    assert_eq!(
        ::core::mem::align_of::<ResettableState>(),
        4usize,
        concat!("Alignment of ", stringify!(ResettableState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ResettableState),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hold_phase_pending) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ResettableState),
            "::",
            stringify!(hold_phase_pending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exit_phase_in_progress) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(ResettableState),
            "::",
            stringify!(exit_phase_in_progress)
        )
    );
}
pub const DEV_NVECTORS_UNSPECIFIED: _bindgen_ty_35 = -1;
pub type _bindgen_ty_35 = core::ffi::c_int;
pub const DeviceCategory_DEVICE_CATEGORY_BRIDGE: DeviceCategory = 0;
pub const DeviceCategory_DEVICE_CATEGORY_USB: DeviceCategory = 1;
pub const DeviceCategory_DEVICE_CATEGORY_STORAGE: DeviceCategory = 2;
pub const DeviceCategory_DEVICE_CATEGORY_NETWORK: DeviceCategory = 3;
pub const DeviceCategory_DEVICE_CATEGORY_INPUT: DeviceCategory = 4;
pub const DeviceCategory_DEVICE_CATEGORY_DISPLAY: DeviceCategory = 5;
pub const DeviceCategory_DEVICE_CATEGORY_SOUND: DeviceCategory = 6;
pub const DeviceCategory_DEVICE_CATEGORY_MISC: DeviceCategory = 7;
pub const DeviceCategory_DEVICE_CATEGORY_CPU: DeviceCategory = 8;
pub const DeviceCategory_DEVICE_CATEGORY_WATCHDOG: DeviceCategory = 9;
pub const DeviceCategory_DEVICE_CATEGORY_MAX: DeviceCategory = 10;
pub type DeviceCategory = core::ffi::c_uint;
pub type DeviceRealize =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut DeviceState, errp: *mut *mut Error)>;
pub type DeviceUnrealize = ::core::option::Option<unsafe extern "C" fn(dev: *mut DeviceState)>;
pub type DeviceReset = ::core::option::Option<unsafe extern "C" fn(dev: *mut DeviceState)>;
pub type BusRealize =
    ::core::option::Option<unsafe extern "C" fn(bus: *mut BusState, errp: *mut *mut Error)>;
pub type BusUnrealize = ::core::option::Option<unsafe extern "C" fn(bus: *mut BusState)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceClass {
    pub parent_class: ObjectClass,
    pub categories: [core::ffi::c_ulong; 1usize],
    pub fw_name: *const core::ffi::c_char,
    pub desc: *const core::ffi::c_char,
    pub props_: *mut Property,
    pub user_creatable: bool,
    pub hotpluggable: bool,
    pub reset: DeviceReset,
    pub realize: DeviceRealize,
    pub unrealize: DeviceUnrealize,
    pub vmsd: *const VMStateDescription,
    pub bus_type: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_DeviceClass() {
    const UNINIT: ::core::mem::MaybeUninit<DeviceClass> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DeviceClass>(),
        176usize,
        concat!("Size of: ", stringify!(DeviceClass))
    );
    assert_eq!(
        ::core::mem::align_of::<DeviceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(DeviceClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).categories) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(categories)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw_name) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(fw_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).props_) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(props_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_creatable) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(user_creatable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hotpluggable) as usize - ptr as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(hotpluggable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).realize) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(realize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unrealize) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(unrealize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vmsd) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(vmsd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_type) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceClass),
            "::",
            stringify!(bus_type)
        )
    );
}
impl Default for DeviceClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedGPIOList {
    pub name: *mut core::ffi::c_char,
    pub in_: *mut qemu_irq,
    pub num_in: core::ffi::c_int,
    pub num_out: core::ffi::c_int,
    pub node: NamedGPIOList__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedGPIOList__bindgen_ty_1 {
    pub le_next: *mut NamedGPIOList,
    pub le_prev: *mut *mut NamedGPIOList,
}
#[test]
fn bindgen_test_layout_NamedGPIOList__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<NamedGPIOList__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NamedGPIOList__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(NamedGPIOList__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NamedGPIOList__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedGPIOList__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedGPIOList__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedGPIOList__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
impl Default for NamedGPIOList__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NamedGPIOList() {
    const UNINIT: ::core::mem::MaybeUninit<NamedGPIOList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NamedGPIOList>(),
        40usize,
        concat!("Size of: ", stringify!(NamedGPIOList))
    );
    assert_eq!(
        ::core::mem::align_of::<NamedGPIOList>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedGPIOList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedGPIOList),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedGPIOList),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_in) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedGPIOList),
            "::",
            stringify!(num_in)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_out) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedGPIOList),
            "::",
            stringify!(num_out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedGPIOList),
            "::",
            stringify!(node)
        )
    );
}
impl Default for NamedGPIOList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedClockList {
    pub name: *mut core::ffi::c_char,
    pub clock: *mut Clock,
    pub output: bool,
    pub alias: bool,
    pub node: NamedClockList__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedClockList__bindgen_ty_1 {
    pub le_next: *mut NamedClockList,
    pub le_prev: *mut *mut NamedClockList,
}
#[test]
fn bindgen_test_layout_NamedClockList__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<NamedClockList__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NamedClockList__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(NamedClockList__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NamedClockList__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedClockList__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedClockList__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedClockList__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
impl Default for NamedClockList__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_NamedClockList() {
    const UNINIT: ::core::mem::MaybeUninit<NamedClockList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NamedClockList>(),
        40usize,
        concat!("Size of: ", stringify!(NamedClockList))
    );
    assert_eq!(
        ::core::mem::align_of::<NamedClockList>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedClockList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedClockList),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedClockList),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedClockList),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedClockList),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedClockList),
            "::",
            stringify!(node)
        )
    );
}
impl Default for NamedClockList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemReentrancyGuard {
    pub engaged_in_io: bool,
}
#[test]
fn bindgen_test_layout_MemReentrancyGuard() {
    const UNINIT: ::core::mem::MaybeUninit<MemReentrancyGuard> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemReentrancyGuard>(),
        1usize,
        concat!("Size of: ", stringify!(MemReentrancyGuard))
    );
    assert_eq!(
        ::core::mem::align_of::<MemReentrancyGuard>(),
        1usize,
        concat!("Alignment of ", stringify!(MemReentrancyGuard))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).engaged_in_io) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemReentrancyGuard),
            "::",
            stringify!(engaged_in_io)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedGPIOListHead {
    pub lh_first: *mut NamedGPIOList,
}
#[test]
fn bindgen_test_layout_NamedGPIOListHead() {
    const UNINIT: ::core::mem::MaybeUninit<NamedGPIOListHead> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NamedGPIOListHead>(),
        8usize,
        concat!("Size of: ", stringify!(NamedGPIOListHead))
    );
    assert_eq!(
        ::core::mem::align_of::<NamedGPIOListHead>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedGPIOListHead))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedGPIOListHead),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for NamedGPIOListHead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NamedClockListHead {
    pub lh_first: *mut NamedClockList,
}
#[test]
fn bindgen_test_layout_NamedClockListHead() {
    const UNINIT: ::core::mem::MaybeUninit<NamedClockListHead> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NamedClockListHead>(),
        8usize,
        concat!("Size of: ", stringify!(NamedClockListHead))
    );
    assert_eq!(
        ::core::mem::align_of::<NamedClockListHead>(),
        8usize,
        concat!("Alignment of ", stringify!(NamedClockListHead))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NamedClockListHead),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for NamedClockListHead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BusStateHead {
    pub lh_first: *mut BusState,
}
#[test]
fn bindgen_test_layout_BusStateHead() {
    const UNINIT: ::core::mem::MaybeUninit<BusStateHead> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BusStateHead>(),
        8usize,
        concat!("Size of: ", stringify!(BusStateHead))
    );
    assert_eq!(
        ::core::mem::align_of::<BusStateHead>(),
        8usize,
        concat!("Alignment of ", stringify!(BusStateHead))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BusStateHead),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for BusStateHead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DeviceState {
    pub parent_obj: Object,
    pub id: *mut core::ffi::c_char,
    pub canonical_path: *mut core::ffi::c_char,
    pub realized: bool,
    pub pending_deleted_event: bool,
    pub pending_deleted_expires_ms: i64,
    pub opts: *mut QDict,
    pub hotplugged: core::ffi::c_int,
    pub allow_unplug_during_migration: bool,
    pub parent_bus: *mut BusState,
    pub gpios: NamedGPIOListHead,
    pub clocks: NamedClockListHead,
    pub child_bus: BusStateHead,
    pub num_child_bus: core::ffi::c_int,
    pub instance_id_alias: core::ffi::c_int,
    pub alias_required_for_version: core::ffi::c_int,
    pub reset: ResettableState,
    pub unplug_blockers: *mut GSList,
    pub mem_reentrancy_guard: MemReentrancyGuard,
}
#[test]
fn bindgen_test_layout_DeviceState() {
    const UNINIT: ::core::mem::MaybeUninit<DeviceState> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DeviceState>(),
        160usize,
        concat!("Size of: ", stringify!(DeviceState))
    );
    assert_eq!(
        ::core::mem::align_of::<DeviceState>(),
        8usize,
        concat!("Alignment of ", stringify!(DeviceState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(parent_obj)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).canonical_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(canonical_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).realized) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(realized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pending_deleted_event) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(pending_deleted_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pending_deleted_expires_ms) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(pending_deleted_expires_ms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opts) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(opts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hotplugged) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(hotplugged)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).allow_unplug_during_migration) as usize - ptr as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(allow_unplug_during_migration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_bus) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(parent_bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpios) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(gpios)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clocks) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(clocks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).child_bus) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(child_bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_child_bus) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(num_child_bus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).instance_id_alias) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(instance_id_alias)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alias_required_for_version) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(alias_required_for_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unplug_blockers) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(unplug_blockers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_reentrancy_guard) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceState),
            "::",
            stringify!(mem_reentrancy_guard)
        )
    );
}
impl Default for DeviceState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DeviceListener {
    pub realize: ::core::option::Option<
        unsafe extern "C" fn(listener: *mut DeviceListener, dev: *mut DeviceState),
    >,
    pub unrealize: ::core::option::Option<
        unsafe extern "C" fn(listener: *mut DeviceListener, dev: *mut DeviceState),
    >,
    pub hide_device: ::core::option::Option<
        unsafe extern "C" fn(
            listener: *mut DeviceListener,
            device_opts: *const QDict,
            from_json: bool,
            errp: *mut *mut Error,
        ) -> bool,
    >,
    pub link: DeviceListener__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DeviceListener__bindgen_ty_1 {
    pub tqe_next: *mut DeviceListener,
    pub tqe_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_DeviceListener__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<DeviceListener__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DeviceListener__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(DeviceListener__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DeviceListener__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(DeviceListener__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceListener__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceListener__bindgen_ty_1),
            "::",
            stringify!(tqe_circ)
        )
    );
}
impl Default for DeviceListener__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for DeviceListener__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "DeviceListener__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_DeviceListener() {
    const UNINIT: ::core::mem::MaybeUninit<DeviceListener> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DeviceListener>(),
        40usize,
        concat!("Size of: ", stringify!(DeviceListener))
    );
    assert_eq!(
        ::core::mem::align_of::<DeviceListener>(),
        8usize,
        concat!("Alignment of ", stringify!(DeviceListener))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).realize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceListener),
            "::",
            stringify!(realize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unrealize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceListener),
            "::",
            stringify!(unrealize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hide_device) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceListener),
            "::",
            stringify!(hide_device)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DeviceListener),
            "::",
            stringify!(link)
        )
    );
}
impl Default for DeviceListener {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for DeviceListener {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "DeviceListener {{ realize: {:?}, unrealize: {:?}, hide_device: {:?}, link: {:?} }}",
            self.realize, self.unrealize, self.hide_device, self.link
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BusClass {
    pub parent_class: ObjectClass,
    pub print_dev: ::core::option::Option<
        unsafe extern "C" fn(mon: *mut Monitor, dev: *mut DeviceState, indent: core::ffi::c_int),
    >,
    pub get_dev_path: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut DeviceState) -> *mut core::ffi::c_char,
    >,
    pub get_fw_dev_path: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut DeviceState) -> *mut core::ffi::c_char,
    >,
    pub check_address: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut BusState,
            dev: *mut DeviceState,
            errp: *mut *mut Error,
        ) -> bool,
    >,
    pub realize: BusRealize,
    pub unrealize: BusUnrealize,
    pub max_dev: core::ffi::c_int,
    pub automatic_ids: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_BusClass() {
    const UNINIT: ::core::mem::MaybeUninit<BusClass> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BusClass>(),
        152usize,
        concat!("Size of: ", stringify!(BusClass))
    );
    assert_eq!(
        ::core::mem::align_of::<BusClass>(),
        8usize,
        concat!("Alignment of ", stringify!(BusClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BusClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).print_dev) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BusClass),
            "::",
            stringify!(print_dev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_dev_path) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(BusClass),
            "::",
            stringify!(get_dev_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_fw_dev_path) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(BusClass),
            "::",
            stringify!(get_fw_dev_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).check_address) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(BusClass),
            "::",
            stringify!(check_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).realize) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(BusClass),
            "::",
            stringify!(realize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unrealize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(BusClass),
            "::",
            stringify!(unrealize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_dev) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(BusClass),
            "::",
            stringify!(max_dev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).automatic_ids) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(BusClass),
            "::",
            stringify!(automatic_ids)
        )
    );
}
impl Default for BusClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BusChild {
    pub rcu: rcu_head,
    pub child: *mut DeviceState,
    pub index: core::ffi::c_int,
    pub sibling: BusChild__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BusChild__bindgen_ty_1 {
    pub tqe_next: *mut BusChild,
    pub tqe_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_BusChild__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<BusChild__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BusChild__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(BusChild__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<BusChild__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(BusChild__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BusChild__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BusChild__bindgen_ty_1),
            "::",
            stringify!(tqe_circ)
        )
    );
}
impl Default for BusChild__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for BusChild__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "BusChild__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_BusChild() {
    const UNINIT: ::core::mem::MaybeUninit<BusChild> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BusChild>(),
        48usize,
        concat!("Size of: ", stringify!(BusChild))
    );
    assert_eq!(
        ::core::mem::align_of::<BusChild>(),
        8usize,
        concat!("Alignment of ", stringify!(BusChild))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BusChild),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).child) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BusChild),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BusChild),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sibling) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BusChild),
            "::",
            stringify!(sibling)
        )
    );
}
impl Default for BusChild {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for BusChild {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "BusChild {{ rcu: {:?}, child: {:?}, index: {:?}, sibling: {:?} }}",
            self.rcu, self.child, self.index, self.sibling
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BusChildHead {
    pub tqh_first: *mut BusChild,
    pub tqh_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_BusChildHead() {
    const UNINIT: ::core::mem::MaybeUninit<BusChildHead> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BusChildHead>(),
        16usize,
        concat!("Size of: ", stringify!(BusChildHead))
    );
    assert_eq!(
        ::core::mem::align_of::<BusChildHead>(),
        8usize,
        concat!("Alignment of ", stringify!(BusChildHead))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BusChildHead),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BusChildHead),
            "::",
            stringify!(tqh_circ)
        )
    );
}
impl Default for BusChildHead {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for BusChildHead {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "BusChildHead {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BusStateEntry {
    pub le_next: *mut BusState,
    pub le_prev: *mut *mut BusState,
}
#[test]
fn bindgen_test_layout_BusStateEntry() {
    const UNINIT: ::core::mem::MaybeUninit<BusStateEntry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BusStateEntry>(),
        16usize,
        concat!("Size of: ", stringify!(BusStateEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<BusStateEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(BusStateEntry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BusStateEntry),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BusStateEntry),
            "::",
            stringify!(le_prev)
        )
    );
}
impl Default for BusStateEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BusState {
    pub obj: Object,
    pub parent: *mut DeviceState,
    pub name: *mut core::ffi::c_char,
    pub hotplug_handler: *mut HotplugHandler,
    pub max_index: core::ffi::c_int,
    pub realized: bool,
    pub full: bool,
    pub num_children: core::ffi::c_int,
    pub children: BusChildHead,
    pub sibling: BusStateEntry,
    pub reset: ResettableState,
}
#[test]
fn bindgen_test_layout_BusState() {
    const UNINIT: ::core::mem::MaybeUninit<BusState> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BusState>(),
        120usize,
        concat!("Size of: ", stringify!(BusState))
    );
    assert_eq!(
        ::core::mem::align_of::<BusState>(),
        8usize,
        concat!("Alignment of ", stringify!(BusState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BusState),
            "::",
            stringify!(obj)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BusState),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BusState),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hotplug_handler) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BusState),
            "::",
            stringify!(hotplug_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_index) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BusState),
            "::",
            stringify!(max_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).realized) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(BusState),
            "::",
            stringify!(realized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).full) as usize - ptr as usize },
        69usize,
        concat!(
            "Offset of field: ",
            stringify!(BusState),
            "::",
            stringify!(full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_children) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BusState),
            "::",
            stringify!(num_children)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BusState),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sibling) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BusState),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(BusState),
            "::",
            stringify!(reset)
        )
    );
}
impl Default for BusState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for BusState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "BusState {{ obj: {:?}, parent: {:?}, name: {:?}, hotplug_handler: {:?}, max_index: {:?}, realized: {:?}, full: {:?}, num_children: {:?}, children: {:?}, sibling: {:?}, reset: {:?} }}" , self . obj , self . parent , self . name , self . hotplug_handler , self . max_index , self . realized , self . full , self . num_children , self . children , self . sibling , self . reset)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GlobalProperty {
    pub driver: *const core::ffi::c_char,
    pub property: *const core::ffi::c_char,
    pub value: *const core::ffi::c_char,
    pub used: bool,
    pub optional: bool,
}
#[test]
fn bindgen_test_layout_GlobalProperty() {
    const UNINIT: ::core::mem::MaybeUninit<GlobalProperty> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GlobalProperty>(),
        32usize,
        concat!("Size of: ", stringify!(GlobalProperty))
    );
    assert_eq!(
        ::core::mem::align_of::<GlobalProperty>(),
        8usize,
        concat!("Alignment of ", stringify!(GlobalProperty))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).driver) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalProperty),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalProperty),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalProperty),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalProperty),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).optional) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(GlobalProperty),
            "::",
            stringify!(optional)
        )
    );
}
impl Default for GlobalProperty {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const GpioPolarity_GPIO_POLARITY_ACTIVE_LOW: GpioPolarity = 0;
pub const GpioPolarity_GPIO_POLARITY_ACTIVE_HIGH: GpioPolarity = 1;
pub type GpioPolarity = core::ffi::c_uint;
pub type qbus_walkerfn = ::core::option::Option<
    unsafe extern "C" fn(bus: *mut BusState, opaque: *mut core::ffi::c_void) -> core::ffi::c_int,
>;
pub type qdev_walkerfn = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut DeviceState, opaque: *mut core::ffi::c_void) -> core::ffi::c_int,
>;
pub const MachineInitPhase_PHASE_NO_MACHINE: MachineInitPhase = 0;
pub const MachineInitPhase_PHASE_MACHINE_CREATED: MachineInitPhase = 1;
pub const MachineInitPhase_PHASE_ACCEL_CREATED: MachineInitPhase = 2;
pub const MachineInitPhase_PHASE_LATE_BACKENDS_CREATED: MachineInitPhase = 3;
pub const MachineInitPhase_PHASE_MACHINE_INITIALIZED: MachineInitPhase = 4;
pub const MachineInitPhase_PHASE_MACHINE_READY: MachineInitPhase = 5;
pub type MachineInitPhase = core::ffi::c_uint;
pub type vaddr = u64;
pub type hwaddr = u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemMapEntry {
    pub base: hwaddr,
    pub size: hwaddr,
}
#[test]
fn bindgen_test_layout_MemMapEntry() {
    const UNINIT: ::core::mem::MaybeUninit<MemMapEntry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemMapEntry>(),
        16usize,
        concat!("Size of: ", stringify!(MemMapEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<MemMapEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(MemMapEntry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemMapEntry),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemMapEntry),
            "::",
            stringify!(size)
        )
    );
}
pub type PTR = *mut core::ffi::c_void;
pub type bfd_vma = u64;
pub type bfd_signed_vma = i64;
pub type bfd_byte = u8;
pub const bfd_flavour_bfd_target_unknown_flavour: bfd_flavour = 0;
pub const bfd_flavour_bfd_target_aout_flavour: bfd_flavour = 1;
pub const bfd_flavour_bfd_target_coff_flavour: bfd_flavour = 2;
pub const bfd_flavour_bfd_target_ecoff_flavour: bfd_flavour = 3;
pub const bfd_flavour_bfd_target_elf_flavour: bfd_flavour = 4;
pub const bfd_flavour_bfd_target_ieee_flavour: bfd_flavour = 5;
pub const bfd_flavour_bfd_target_nlm_flavour: bfd_flavour = 6;
pub const bfd_flavour_bfd_target_oasys_flavour: bfd_flavour = 7;
pub const bfd_flavour_bfd_target_tekhex_flavour: bfd_flavour = 8;
pub const bfd_flavour_bfd_target_srec_flavour: bfd_flavour = 9;
pub const bfd_flavour_bfd_target_ihex_flavour: bfd_flavour = 10;
pub const bfd_flavour_bfd_target_som_flavour: bfd_flavour = 11;
pub const bfd_flavour_bfd_target_os9k_flavour: bfd_flavour = 12;
pub const bfd_flavour_bfd_target_versados_flavour: bfd_flavour = 13;
pub const bfd_flavour_bfd_target_msdos_flavour: bfd_flavour = 14;
pub const bfd_flavour_bfd_target_evax_flavour: bfd_flavour = 15;
pub type bfd_flavour = core::ffi::c_uint;
pub const bfd_endian_BFD_ENDIAN_BIG: bfd_endian = 0;
pub const bfd_endian_BFD_ENDIAN_LITTLE: bfd_endian = 1;
pub const bfd_endian_BFD_ENDIAN_UNKNOWN: bfd_endian = 2;
pub type bfd_endian = core::ffi::c_uint;
pub const bfd_architecture_bfd_arch_unknown: bfd_architecture = 0;
pub const bfd_architecture_bfd_arch_obscure: bfd_architecture = 1;
pub const bfd_architecture_bfd_arch_m68k: bfd_architecture = 2;
pub const bfd_architecture_bfd_arch_vax: bfd_architecture = 3;
pub const bfd_architecture_bfd_arch_i960: bfd_architecture = 4;
pub const bfd_architecture_bfd_arch_a29k: bfd_architecture = 5;
pub const bfd_architecture_bfd_arch_sparc: bfd_architecture = 6;
pub const bfd_architecture_bfd_arch_mips: bfd_architecture = 7;
pub const bfd_architecture_bfd_arch_i386: bfd_architecture = 8;
pub const bfd_architecture_bfd_arch_we32k: bfd_architecture = 9;
pub const bfd_architecture_bfd_arch_tahoe: bfd_architecture = 10;
pub const bfd_architecture_bfd_arch_i860: bfd_architecture = 11;
pub const bfd_architecture_bfd_arch_romp: bfd_architecture = 12;
pub const bfd_architecture_bfd_arch_alliant: bfd_architecture = 13;
pub const bfd_architecture_bfd_arch_convex: bfd_architecture = 14;
pub const bfd_architecture_bfd_arch_m88k: bfd_architecture = 15;
pub const bfd_architecture_bfd_arch_pyramid: bfd_architecture = 16;
pub const bfd_architecture_bfd_arch_h8300: bfd_architecture = 17;
pub const bfd_architecture_bfd_arch_powerpc: bfd_architecture = 18;
pub const bfd_architecture_bfd_arch_rs6000: bfd_architecture = 19;
pub const bfd_architecture_bfd_arch_hppa: bfd_architecture = 20;
pub const bfd_architecture_bfd_arch_d10v: bfd_architecture = 21;
pub const bfd_architecture_bfd_arch_z8k: bfd_architecture = 22;
pub const bfd_architecture_bfd_arch_h8500: bfd_architecture = 23;
pub const bfd_architecture_bfd_arch_sh: bfd_architecture = 24;
pub const bfd_architecture_bfd_arch_alpha: bfd_architecture = 25;
pub const bfd_architecture_bfd_arch_arm: bfd_architecture = 26;
pub const bfd_architecture_bfd_arch_ns32k: bfd_architecture = 27;
pub const bfd_architecture_bfd_arch_w65: bfd_architecture = 28;
pub const bfd_architecture_bfd_arch_tic30: bfd_architecture = 29;
pub const bfd_architecture_bfd_arch_v850: bfd_architecture = 30;
pub const bfd_architecture_bfd_arch_arc: bfd_architecture = 31;
pub const bfd_architecture_bfd_arch_m32r: bfd_architecture = 32;
pub const bfd_architecture_bfd_arch_mn10200: bfd_architecture = 33;
pub const bfd_architecture_bfd_arch_mn10300: bfd_architecture = 34;
pub const bfd_architecture_bfd_arch_avr: bfd_architecture = 35;
pub const bfd_architecture_bfd_arch_cris: bfd_architecture = 36;
pub const bfd_architecture_bfd_arch_microblaze: bfd_architecture = 37;
pub const bfd_architecture_bfd_arch_moxie: bfd_architecture = 38;
pub const bfd_architecture_bfd_arch_ia64: bfd_architecture = 39;
pub const bfd_architecture_bfd_arch_rx: bfd_architecture = 40;
pub const bfd_architecture_bfd_arch_loongarch: bfd_architecture = 41;
pub const bfd_architecture_bfd_arch_last: bfd_architecture = 42;
pub type bfd_architecture = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct symbol_cache_entry {
    pub name: *const core::ffi::c_char,
    pub udata: symbol_cache_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union symbol_cache_entry__bindgen_ty_1 {
    pub p: PTR,
    pub i: bfd_vma,
}
#[test]
fn bindgen_test_layout_symbol_cache_entry__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<symbol_cache_entry__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<symbol_cache_entry__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(symbol_cache_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<symbol_cache_entry__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(symbol_cache_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(symbol_cache_entry__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(symbol_cache_entry__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
}
impl Default for symbol_cache_entry__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for symbol_cache_entry__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "symbol_cache_entry__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_symbol_cache_entry() {
    const UNINIT: ::core::mem::MaybeUninit<symbol_cache_entry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<symbol_cache_entry>(),
        16usize,
        concat!("Size of: ", stringify!(symbol_cache_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<symbol_cache_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(symbol_cache_entry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(symbol_cache_entry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).udata) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(symbol_cache_entry),
            "::",
            stringify!(udata)
        )
    );
}
impl Default for symbol_cache_entry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for symbol_cache_entry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "symbol_cache_entry {{ name: {:?}, udata: {:?} }}",
            self.name, self.udata
        )
    }
}
pub type asymbol = symbol_cache_entry;
pub type fprintf_function = ::core::option::Option<
    unsafe extern "C" fn(f: *mut FILE, fmt: *const core::ffi::c_char, ...) -> core::ffi::c_int,
>;
pub const dis_insn_type_dis_noninsn: dis_insn_type = 0;
pub const dis_insn_type_dis_nonbranch: dis_insn_type = 1;
pub const dis_insn_type_dis_branch: dis_insn_type = 2;
pub const dis_insn_type_dis_condbranch: dis_insn_type = 3;
pub const dis_insn_type_dis_jsr: dis_insn_type = 4;
pub const dis_insn_type_dis_condjsr: dis_insn_type = 5;
pub const dis_insn_type_dis_dref: dis_insn_type = 6;
pub const dis_insn_type_dis_dref2: dis_insn_type = 7;
pub type dis_insn_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct disassemble_info {
    pub fprintf_func: fprintf_function,
    pub stream: *mut FILE,
    pub application_data: PTR,
    pub flavour: bfd_flavour,
    pub arch: bfd_architecture,
    pub mach: core::ffi::c_ulong,
    pub endian: bfd_endian,
    pub symbols: *mut *mut asymbol,
    pub num_symbols: core::ffi::c_int,
    pub flags: core::ffi::c_ulong,
    pub private_data: PTR,
    pub read_memory_func: ::core::option::Option<
        unsafe extern "C" fn(
            memaddr: bfd_vma,
            myaddr: *mut bfd_byte,
            length: core::ffi::c_int,
            info: *mut disassemble_info,
        ) -> core::ffi::c_int,
    >,
    pub memory_error_func: ::core::option::Option<
        unsafe extern "C" fn(
            status: core::ffi::c_int,
            memaddr: bfd_vma,
            info: *mut disassemble_info,
        ),
    >,
    pub print_address_func:
        ::core::option::Option<unsafe extern "C" fn(addr: bfd_vma, info: *mut disassemble_info)>,
    pub print_insn: ::core::option::Option<
        unsafe extern "C" fn(addr: bfd_vma, info: *mut disassemble_info) -> core::ffi::c_int,
    >,
    pub symbol_at_address_func: ::core::option::Option<
        unsafe extern "C" fn(addr: bfd_vma, info: *mut disassemble_info) -> core::ffi::c_int,
    >,
    pub buffer: *const bfd_byte,
    pub buffer_vma: bfd_vma,
    pub buffer_length: core::ffi::c_int,
    pub bytes_per_line: core::ffi::c_int,
    pub bytes_per_chunk: core::ffi::c_int,
    pub display_endian: bfd_endian,
    pub insn_info_valid: core::ffi::c_char,
    pub branch_delay_insns: core::ffi::c_char,
    pub data_size: core::ffi::c_char,
    pub insn_type: dis_insn_type,
    pub target: bfd_vma,
    pub target2: bfd_vma,
    pub disassembler_options: *mut core::ffi::c_char,
    pub show_opcodes: bool,
    pub target_info: *mut core::ffi::c_void,
    pub cap_arch: core::ffi::c_int,
    pub cap_mode: core::ffi::c_int,
    pub cap_insn_unit: core::ffi::c_int,
    pub cap_insn_split: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_disassemble_info() {
    const UNINIT: ::core::mem::MaybeUninit<disassemble_info> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<disassemble_info>(),
        216usize,
        concat!("Size of: ", stringify!(disassemble_info))
    );
    assert_eq!(
        ::core::mem::align_of::<disassemble_info>(),
        8usize,
        concat!("Alignment of ", stringify!(disassemble_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fprintf_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(fprintf_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).application_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(application_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flavour) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(flavour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arch) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mach) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(mach)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).endian) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(endian)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).symbols) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(symbols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_symbols) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(num_symbols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_memory_func) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(read_memory_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory_error_func) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(memory_error_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).print_address_func) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(print_address_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).print_insn) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(print_insn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).symbol_at_address_func) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(symbol_at_address_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_vma) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(buffer_vma)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_length) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(buffer_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_per_line) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(bytes_per_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_per_chunk) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(bytes_per_chunk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display_endian) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(display_endian)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).insn_info_valid) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(insn_info_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).branch_delay_insns) as usize - ptr as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(branch_delay_insns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_size) as usize - ptr as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(data_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).insn_type) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(insn_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target2) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(target2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disassembler_options) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(disassembler_options)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).show_opcodes) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(show_opcodes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target_info) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(target_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cap_arch) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(cap_arch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cap_mode) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(cap_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cap_insn_unit) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(cap_insn_unit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cap_insn_split) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(disassemble_info),
            "::",
            stringify!(cap_insn_split)
        )
    );
}
impl Default for disassemble_info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type disassembler_ftype = ::core::option::Option<
    unsafe extern "C" fn(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int,
>;
pub type bfd_boolean = bool;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemTxAttrs {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
#[test]
fn bindgen_test_layout_MemTxAttrs() {
    assert_eq!(
        ::core::mem::size_of::<MemTxAttrs>(),
        4usize,
        concat!("Size of: ", stringify!(MemTxAttrs))
    );
    assert_eq!(
        ::core::mem::align_of::<MemTxAttrs>(),
        4usize,
        concat!("Alignment of ", stringify!(MemTxAttrs))
    );
}
impl MemTxAttrs {
    #[inline]
    pub fn unspecified(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unspecified(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secure(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_secure(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn space(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_space(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn user(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_user(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memory(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memory(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn requester_id(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_requester_id(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unspecified: core::ffi::c_uint,
        secure: core::ffi::c_uint,
        space: core::ffi::c_uint,
        user: core::ffi::c_uint,
        memory: core::ffi::c_uint,
        requester_id: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let unspecified: u32 = unsafe { ::core::mem::transmute(unspecified) };
            unspecified as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let secure: u32 = unsafe { ::core::mem::transmute(secure) };
            secure as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let space: u32 = unsafe { ::core::mem::transmute(space) };
            space as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let user: u32 = unsafe { ::core::mem::transmute(user) };
            user as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let memory: u32 = unsafe { ::core::mem::transmute(memory) };
            memory as u64
        });
        __bindgen_bitfield_unit.set(6usize, 16u8, {
            let requester_id: u32 = unsafe { ::core::mem::transmute(requester_id) };
            requester_id as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type MemTxResult = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPUBreakpoint {
    pub pc: vaddr,
    pub flags: core::ffi::c_int,
    pub entry: CPUBreakpoint__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUBreakpoint__bindgen_ty_1 {
    pub tqe_next: *mut CPUBreakpoint,
    pub tqe_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_CPUBreakpoint__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CPUBreakpoint__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUBreakpoint__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(CPUBreakpoint__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUBreakpoint__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUBreakpoint__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUBreakpoint__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUBreakpoint__bindgen_ty_1),
            "::",
            stringify!(tqe_circ)
        )
    );
}
impl Default for CPUBreakpoint__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUBreakpoint__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "CPUBreakpoint__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_CPUBreakpoint() {
    const UNINIT: ::core::mem::MaybeUninit<CPUBreakpoint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUBreakpoint>(),
        32usize,
        concat!("Size of: ", stringify!(CPUBreakpoint))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUBreakpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUBreakpoint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUBreakpoint),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUBreakpoint),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUBreakpoint),
            "::",
            stringify!(entry)
        )
    );
}
impl Default for CPUBreakpoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUBreakpoint {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "CPUBreakpoint {{ pc: {:?}, flags: {:?}, entry: {:?} }}",
            self.pc, self.flags, self.entry
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPUWatchpoint {
    pub vaddr: vaddr,
    pub len: vaddr,
    pub hitaddr: vaddr,
    pub hitattrs: MemTxAttrs,
    pub flags: core::ffi::c_int,
    pub entry: CPUWatchpoint__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUWatchpoint__bindgen_ty_1 {
    pub tqe_next: *mut CPUWatchpoint,
    pub tqe_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_CPUWatchpoint__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CPUWatchpoint__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUWatchpoint__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(CPUWatchpoint__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUWatchpoint__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUWatchpoint__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUWatchpoint__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUWatchpoint__bindgen_ty_1),
            "::",
            stringify!(tqe_circ)
        )
    );
}
impl Default for CPUWatchpoint__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUWatchpoint__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "CPUWatchpoint__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_CPUWatchpoint() {
    const UNINIT: ::core::mem::MaybeUninit<CPUWatchpoint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUWatchpoint>(),
        48usize,
        concat!("Size of: ", stringify!(CPUWatchpoint))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUWatchpoint>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUWatchpoint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vaddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUWatchpoint),
            "::",
            stringify!(vaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUWatchpoint),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hitaddr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUWatchpoint),
            "::",
            stringify!(hitaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hitattrs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUWatchpoint),
            "::",
            stringify!(hitattrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUWatchpoint),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUWatchpoint),
            "::",
            stringify!(entry)
        )
    );
}
impl Default for CPUWatchpoint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUWatchpoint {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "CPUWatchpoint {{ vaddr: {:?}, len: {:?}, hitaddr: {:?}, hitattrs: {:?}, flags: {:?}, entry: {:?} }}" , self . vaddr , self . len , self . hitaddr , self . hitattrs , self . flags , self . entry)
    }
}
pub const MMUAccessType_MMU_DATA_LOAD: MMUAccessType = 0;
pub const MMUAccessType_MMU_DATA_STORE: MMUAccessType = 1;
pub const MMUAccessType_MMU_INST_FETCH: MMUAccessType = 2;
pub type MMUAccessType = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUTLBEntry {
    pub __bindgen_anon_1: CPUTLBEntry__bindgen_ty_1,
    pub addr_idx: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CPUTLBEntry__bindgen_ty_1 {
    pub addr_read: u64,
    pub addr_write: u64,
    pub addr_code: u64,
    pub addend: usize,
}
#[test]
fn bindgen_test_layout_CPUTLBEntry__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CPUTLBEntry__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUTLBEntry__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(CPUTLBEntry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUTLBEntry__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUTLBEntry__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntry__bindgen_ty_1),
            "::",
            stringify!(addr_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntry__bindgen_ty_1),
            "::",
            stringify!(addr_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_code) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntry__bindgen_ty_1),
            "::",
            stringify!(addr_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addend) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntry__bindgen_ty_1),
            "::",
            stringify!(addend)
        )
    );
}
#[test]
fn bindgen_test_layout_CPUTLBEntry() {
    const UNINIT: ::core::mem::MaybeUninit<CPUTLBEntry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUTLBEntry>(),
        32usize,
        concat!("Size of: ", stringify!(CPUTLBEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUTLBEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUTLBEntry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_idx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntry),
            "::",
            stringify!(addr_idx)
        )
    );
}
impl Default for CPUTLBEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUTLBEntry {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "CPUTLBEntry {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUTLBDescFast {
    pub mask: usize,
    pub table: *mut CPUTLBEntry,
}
#[test]
fn bindgen_test_layout_CPUTLBDescFast() {
    const UNINIT: ::core::mem::MaybeUninit<CPUTLBDescFast> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUTLBDescFast>(),
        16usize,
        concat!("Size of: ", stringify!(CPUTLBDescFast))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUTLBDescFast>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUTLBDescFast))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBDescFast),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBDescFast),
            "::",
            stringify!(table)
        )
    );
}
impl Default for CPUTLBDescFast {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const IoOperationType_IO_OPERATION_TYPE_READ: IoOperationType = 0;
pub const IoOperationType_IO_OPERATION_TYPE_WRITE: IoOperationType = 1;
pub const IoOperationType_IO_OPERATION_TYPE__MAX: IoOperationType = 2;
pub type IoOperationType = core::ffi::c_uint;
pub const OnOffAuto_ON_OFF_AUTO_AUTO: OnOffAuto = 0;
pub const OnOffAuto_ON_OFF_AUTO_ON: OnOffAuto = 1;
pub const OnOffAuto_ON_OFF_AUTO_OFF: OnOffAuto = 2;
pub const OnOffAuto_ON_OFF_AUTO__MAX: OnOffAuto = 3;
pub type OnOffAuto = core::ffi::c_uint;
pub const OnOffSplit_ON_OFF_SPLIT_ON: OnOffSplit = 0;
pub const OnOffSplit_ON_OFF_SPLIT_OFF: OnOffSplit = 1;
pub const OnOffSplit_ON_OFF_SPLIT_SPLIT: OnOffSplit = 2;
pub const OnOffSplit_ON_OFF_SPLIT__MAX: OnOffSplit = 3;
pub type OnOffSplit = core::ffi::c_uint;
pub const OffAutoPCIBAR_OFF_AUTOPCIBAR_OFF: OffAutoPCIBAR = 0;
pub const OffAutoPCIBAR_OFF_AUTOPCIBAR_AUTO: OffAutoPCIBAR = 1;
pub const OffAutoPCIBAR_OFF_AUTOPCIBAR_BAR0: OffAutoPCIBAR = 2;
pub const OffAutoPCIBAR_OFF_AUTOPCIBAR_BAR1: OffAutoPCIBAR = 3;
pub const OffAutoPCIBAR_OFF_AUTOPCIBAR_BAR2: OffAutoPCIBAR = 4;
pub const OffAutoPCIBAR_OFF_AUTOPCIBAR_BAR3: OffAutoPCIBAR = 5;
pub const OffAutoPCIBAR_OFF_AUTOPCIBAR_BAR4: OffAutoPCIBAR = 6;
pub const OffAutoPCIBAR_OFF_AUTOPCIBAR_BAR5: OffAutoPCIBAR = 7;
pub const OffAutoPCIBAR_OFF_AUTOPCIBAR__MAX: OffAutoPCIBAR = 8;
pub type OffAutoPCIBAR = core::ffi::c_uint;
pub const PCIELinkSpeed_PCIE_LINK_SPEED_2_5: PCIELinkSpeed = 0;
pub const PCIELinkSpeed_PCIE_LINK_SPEED_5: PCIELinkSpeed = 1;
pub const PCIELinkSpeed_PCIE_LINK_SPEED_8: PCIELinkSpeed = 2;
pub const PCIELinkSpeed_PCIE_LINK_SPEED_16: PCIELinkSpeed = 3;
pub const PCIELinkSpeed_PCIE_LINK_SPEED_32: PCIELinkSpeed = 4;
pub const PCIELinkSpeed_PCIE_LINK_SPEED_64: PCIELinkSpeed = 5;
pub const PCIELinkSpeed_PCIE_LINK_SPEED__MAX: PCIELinkSpeed = 6;
pub type PCIELinkSpeed = core::ffi::c_uint;
pub const PCIELinkWidth_PCIE_LINK_WIDTH_1: PCIELinkWidth = 0;
pub const PCIELinkWidth_PCIE_LINK_WIDTH_2: PCIELinkWidth = 1;
pub const PCIELinkWidth_PCIE_LINK_WIDTH_4: PCIELinkWidth = 2;
pub const PCIELinkWidth_PCIE_LINK_WIDTH_8: PCIELinkWidth = 3;
pub const PCIELinkWidth_PCIE_LINK_WIDTH_12: PCIELinkWidth = 4;
pub const PCIELinkWidth_PCIE_LINK_WIDTH_16: PCIELinkWidth = 5;
pub const PCIELinkWidth_PCIE_LINK_WIDTH_32: PCIELinkWidth = 6;
pub const PCIELinkWidth_PCIE_LINK_WIDTH__MAX: PCIELinkWidth = 7;
pub type PCIELinkWidth = core::ffi::c_uint;
pub const HostMemPolicy_HOST_MEM_POLICY_DEFAULT: HostMemPolicy = 0;
pub const HostMemPolicy_HOST_MEM_POLICY_PREFERRED: HostMemPolicy = 1;
pub const HostMemPolicy_HOST_MEM_POLICY_BIND: HostMemPolicy = 2;
pub const HostMemPolicy_HOST_MEM_POLICY_INTERLEAVE: HostMemPolicy = 3;
pub const HostMemPolicy_HOST_MEM_POLICY__MAX: HostMemPolicy = 4;
pub type HostMemPolicy = core::ffi::c_uint;
pub const NetFilterDirection_NET_FILTER_DIRECTION_ALL: NetFilterDirection = 0;
pub const NetFilterDirection_NET_FILTER_DIRECTION_RX: NetFilterDirection = 1;
pub const NetFilterDirection_NET_FILTER_DIRECTION_TX: NetFilterDirection = 2;
pub const NetFilterDirection_NET_FILTER_DIRECTION__MAX: NetFilterDirection = 3;
pub type NetFilterDirection = core::ffi::c_uint;
pub const GrabToggleKeys_GRAB_TOGGLE_KEYS_CTRL_CTRL: GrabToggleKeys = 0;
pub const GrabToggleKeys_GRAB_TOGGLE_KEYS_ALT_ALT: GrabToggleKeys = 1;
pub const GrabToggleKeys_GRAB_TOGGLE_KEYS_SHIFT_SHIFT: GrabToggleKeys = 2;
pub const GrabToggleKeys_GRAB_TOGGLE_KEYS_META_META: GrabToggleKeys = 3;
pub const GrabToggleKeys_GRAB_TOGGLE_KEYS_SCROLLLOCK: GrabToggleKeys = 4;
pub const GrabToggleKeys_GRAB_TOGGLE_KEYS_CTRL_SCROLLLOCK: GrabToggleKeys = 5;
pub const GrabToggleKeys_GRAB_TOGGLE_KEYS__MAX: GrabToggleKeys = 6;
pub type GrabToggleKeys = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct StrOrNull {
    pub type_: QType,
    pub u: StrOrNull__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union StrOrNull__bindgen_ty_1 {
    pub s: *mut core::ffi::c_char,
    pub n: *mut QNull,
}
#[test]
fn bindgen_test_layout_StrOrNull__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<StrOrNull__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<StrOrNull__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(StrOrNull__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<StrOrNull__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(StrOrNull__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StrOrNull__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StrOrNull__bindgen_ty_1),
            "::",
            stringify!(n)
        )
    );
}
impl Default for StrOrNull__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for StrOrNull__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "StrOrNull__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_StrOrNull() {
    const UNINIT: ::core::mem::MaybeUninit<StrOrNull> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<StrOrNull>(),
        16usize,
        concat!("Size of: ", stringify!(StrOrNull))
    );
    assert_eq!(
        ::core::mem::align_of::<StrOrNull>(),
        8usize,
        concat!("Alignment of ", stringify!(StrOrNull))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StrOrNull),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StrOrNull),
            "::",
            stringify!(u)
        )
    );
}
impl Default for StrOrNull {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for StrOrNull {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "StrOrNull {{ type: {:?}, u: {:?} }}", self.type_, self.u)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HumanReadableText {
    pub human_readable_text: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_HumanReadableText() {
    const UNINIT: ::core::mem::MaybeUninit<HumanReadableText> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HumanReadableText>(),
        8usize,
        concat!("Size of: ", stringify!(HumanReadableText))
    );
    assert_eq!(
        ::core::mem::align_of::<HumanReadableText>(),
        8usize,
        concat!("Alignment of ", stringify!(HumanReadableText))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).human_readable_text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HumanReadableText),
            "::",
            stringify!(human_readable_text)
        )
    );
}
impl Default for HumanReadableText {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const CpuS390Entitlement_S390_CPU_ENTITLEMENT_AUTO: CpuS390Entitlement = 0;
pub const CpuS390Entitlement_S390_CPU_ENTITLEMENT_LOW: CpuS390Entitlement = 1;
pub const CpuS390Entitlement_S390_CPU_ENTITLEMENT_MEDIUM: CpuS390Entitlement = 2;
pub const CpuS390Entitlement_S390_CPU_ENTITLEMENT_HIGH: CpuS390Entitlement = 3;
pub const CpuS390Entitlement_S390_CPU_ENTITLEMENT__MAX: CpuS390Entitlement = 4;
pub type CpuS390Entitlement = core::ffi::c_uint;
pub const SysEmuTarget_SYS_EMU_TARGET_AARCH64: SysEmuTarget = 0;
pub const SysEmuTarget_SYS_EMU_TARGET_ALPHA: SysEmuTarget = 1;
pub const SysEmuTarget_SYS_EMU_TARGET_ARM: SysEmuTarget = 2;
pub const SysEmuTarget_SYS_EMU_TARGET_AVR: SysEmuTarget = 3;
pub const SysEmuTarget_SYS_EMU_TARGET_CRIS: SysEmuTarget = 4;
pub const SysEmuTarget_SYS_EMU_TARGET_HPPA: SysEmuTarget = 5;
pub const SysEmuTarget_SYS_EMU_TARGET_I386: SysEmuTarget = 6;
pub const SysEmuTarget_SYS_EMU_TARGET_LOONGARCH64: SysEmuTarget = 7;
pub const SysEmuTarget_SYS_EMU_TARGET_M68K: SysEmuTarget = 8;
pub const SysEmuTarget_SYS_EMU_TARGET_MICROBLAZE: SysEmuTarget = 9;
pub const SysEmuTarget_SYS_EMU_TARGET_MICROBLAZEEL: SysEmuTarget = 10;
pub const SysEmuTarget_SYS_EMU_TARGET_MIPS: SysEmuTarget = 11;
pub const SysEmuTarget_SYS_EMU_TARGET_MIPS64: SysEmuTarget = 12;
pub const SysEmuTarget_SYS_EMU_TARGET_MIPS64EL: SysEmuTarget = 13;
pub const SysEmuTarget_SYS_EMU_TARGET_MIPSEL: SysEmuTarget = 14;
pub const SysEmuTarget_SYS_EMU_TARGET_OR1K: SysEmuTarget = 15;
pub const SysEmuTarget_SYS_EMU_TARGET_PPC: SysEmuTarget = 16;
pub const SysEmuTarget_SYS_EMU_TARGET_PPC64: SysEmuTarget = 17;
pub const SysEmuTarget_SYS_EMU_TARGET_RISCV32: SysEmuTarget = 18;
pub const SysEmuTarget_SYS_EMU_TARGET_RISCV64: SysEmuTarget = 19;
pub const SysEmuTarget_SYS_EMU_TARGET_RX: SysEmuTarget = 20;
pub const SysEmuTarget_SYS_EMU_TARGET_S390X: SysEmuTarget = 21;
pub const SysEmuTarget_SYS_EMU_TARGET_SH4: SysEmuTarget = 22;
pub const SysEmuTarget_SYS_EMU_TARGET_SH4EB: SysEmuTarget = 23;
pub const SysEmuTarget_SYS_EMU_TARGET_SPARC: SysEmuTarget = 24;
pub const SysEmuTarget_SYS_EMU_TARGET_SPARC64: SysEmuTarget = 25;
pub const SysEmuTarget_SYS_EMU_TARGET_TRICORE: SysEmuTarget = 26;
pub const SysEmuTarget_SYS_EMU_TARGET_X86_64: SysEmuTarget = 27;
pub const SysEmuTarget_SYS_EMU_TARGET_XTENSA: SysEmuTarget = 28;
pub const SysEmuTarget_SYS_EMU_TARGET_XTENSAEB: SysEmuTarget = 29;
pub const SysEmuTarget_SYS_EMU_TARGET__MAX: SysEmuTarget = 30;
pub type SysEmuTarget = core::ffi::c_uint;
pub const CpuS390State_S390_CPU_STATE_UNINITIALIZED: CpuS390State = 0;
pub const CpuS390State_S390_CPU_STATE_STOPPED: CpuS390State = 1;
pub const CpuS390State_S390_CPU_STATE_CHECK_STOP: CpuS390State = 2;
pub const CpuS390State_S390_CPU_STATE_OPERATING: CpuS390State = 3;
pub const CpuS390State_S390_CPU_STATE_LOAD: CpuS390State = 4;
pub const CpuS390State_S390_CPU_STATE__MAX: CpuS390State = 5;
pub type CpuS390State = core::ffi::c_uint;
pub const LostTickPolicy_LOST_TICK_POLICY_DISCARD: LostTickPolicy = 0;
pub const LostTickPolicy_LOST_TICK_POLICY_DELAY: LostTickPolicy = 1;
pub const LostTickPolicy_LOST_TICK_POLICY_SLEW: LostTickPolicy = 2;
pub const LostTickPolicy_LOST_TICK_POLICY__MAX: LostTickPolicy = 3;
pub type LostTickPolicy = core::ffi::c_uint;
pub const NumaOptionsType_NUMA_OPTIONS_TYPE_NODE: NumaOptionsType = 0;
pub const NumaOptionsType_NUMA_OPTIONS_TYPE_DIST: NumaOptionsType = 1;
pub const NumaOptionsType_NUMA_OPTIONS_TYPE_CPU: NumaOptionsType = 2;
pub const NumaOptionsType_NUMA_OPTIONS_TYPE_HMAT_LB: NumaOptionsType = 3;
pub const NumaOptionsType_NUMA_OPTIONS_TYPE_HMAT_CACHE: NumaOptionsType = 4;
pub const NumaOptionsType_NUMA_OPTIONS_TYPE__MAX: NumaOptionsType = 5;
pub type NumaOptionsType = core::ffi::c_uint;
pub const X86CPURegister32_X86_CPU_REGISTER32_EAX: X86CPURegister32 = 0;
pub const X86CPURegister32_X86_CPU_REGISTER32_EBX: X86CPURegister32 = 1;
pub const X86CPURegister32_X86_CPU_REGISTER32_ECX: X86CPURegister32 = 2;
pub const X86CPURegister32_X86_CPU_REGISTER32_EDX: X86CPURegister32 = 3;
pub const X86CPURegister32_X86_CPU_REGISTER32_ESP: X86CPURegister32 = 4;
pub const X86CPURegister32_X86_CPU_REGISTER32_EBP: X86CPURegister32 = 5;
pub const X86CPURegister32_X86_CPU_REGISTER32_ESI: X86CPURegister32 = 6;
pub const X86CPURegister32_X86_CPU_REGISTER32_EDI: X86CPURegister32 = 7;
pub const X86CPURegister32_X86_CPU_REGISTER32__MAX: X86CPURegister32 = 8;
pub type X86CPURegister32 = core::ffi::c_uint;
pub const HmatLBMemoryHierarchy_HMATLB_MEMORY_HIERARCHY_MEMORY: HmatLBMemoryHierarchy = 0;
pub const HmatLBMemoryHierarchy_HMATLB_MEMORY_HIERARCHY_FIRST_LEVEL: HmatLBMemoryHierarchy = 1;
pub const HmatLBMemoryHierarchy_HMATLB_MEMORY_HIERARCHY_SECOND_LEVEL: HmatLBMemoryHierarchy = 2;
pub const HmatLBMemoryHierarchy_HMATLB_MEMORY_HIERARCHY_THIRD_LEVEL: HmatLBMemoryHierarchy = 3;
pub const HmatLBMemoryHierarchy_HMATLB_MEMORY_HIERARCHY__MAX: HmatLBMemoryHierarchy = 4;
pub type HmatLBMemoryHierarchy = core::ffi::c_uint;
pub const HmatLBDataType_HMATLB_DATA_TYPE_ACCESS_LATENCY: HmatLBDataType = 0;
pub const HmatLBDataType_HMATLB_DATA_TYPE_READ_LATENCY: HmatLBDataType = 1;
pub const HmatLBDataType_HMATLB_DATA_TYPE_WRITE_LATENCY: HmatLBDataType = 2;
pub const HmatLBDataType_HMATLB_DATA_TYPE_ACCESS_BANDWIDTH: HmatLBDataType = 3;
pub const HmatLBDataType_HMATLB_DATA_TYPE_READ_BANDWIDTH: HmatLBDataType = 4;
pub const HmatLBDataType_HMATLB_DATA_TYPE_WRITE_BANDWIDTH: HmatLBDataType = 5;
pub const HmatLBDataType_HMATLB_DATA_TYPE__MAX: HmatLBDataType = 6;
pub type HmatLBDataType = core::ffi::c_uint;
pub const HmatCacheAssociativity_HMAT_CACHE_ASSOCIATIVITY_NONE: HmatCacheAssociativity = 0;
pub const HmatCacheAssociativity_HMAT_CACHE_ASSOCIATIVITY_DIRECT: HmatCacheAssociativity = 1;
pub const HmatCacheAssociativity_HMAT_CACHE_ASSOCIATIVITY_COMPLEX: HmatCacheAssociativity = 2;
pub const HmatCacheAssociativity_HMAT_CACHE_ASSOCIATIVITY__MAX: HmatCacheAssociativity = 3;
pub type HmatCacheAssociativity = core::ffi::c_uint;
pub const HmatCacheWritePolicy_HMAT_CACHE_WRITE_POLICY_NONE: HmatCacheWritePolicy = 0;
pub const HmatCacheWritePolicy_HMAT_CACHE_WRITE_POLICY_WRITE_BACK: HmatCacheWritePolicy = 1;
pub const HmatCacheWritePolicy_HMAT_CACHE_WRITE_POLICY_WRITE_THROUGH: HmatCacheWritePolicy = 2;
pub const HmatCacheWritePolicy_HMAT_CACHE_WRITE_POLICY__MAX: HmatCacheWritePolicy = 3;
pub type HmatCacheWritePolicy = core::ffi::c_uint;
pub const MemoryDeviceInfoKind_MEMORY_DEVICE_INFO_KIND_DIMM: MemoryDeviceInfoKind = 0;
pub const MemoryDeviceInfoKind_MEMORY_DEVICE_INFO_KIND_NVDIMM: MemoryDeviceInfoKind = 1;
pub const MemoryDeviceInfoKind_MEMORY_DEVICE_INFO_KIND_VIRTIO_PMEM: MemoryDeviceInfoKind = 2;
pub const MemoryDeviceInfoKind_MEMORY_DEVICE_INFO_KIND_VIRTIO_MEM: MemoryDeviceInfoKind = 3;
pub const MemoryDeviceInfoKind_MEMORY_DEVICE_INFO_KIND_SGX_EPC: MemoryDeviceInfoKind = 4;
pub const MemoryDeviceInfoKind_MEMORY_DEVICE_INFO_KIND_HV_BALLOON: MemoryDeviceInfoKind = 5;
pub const MemoryDeviceInfoKind_MEMORY_DEVICE_INFO_KIND__MAX: MemoryDeviceInfoKind = 6;
pub type MemoryDeviceInfoKind = core::ffi::c_uint;
pub const SmbiosEntryPointType_SMBIOS_ENTRY_POINT_TYPE_32: SmbiosEntryPointType = 0;
pub const SmbiosEntryPointType_SMBIOS_ENTRY_POINT_TYPE_64: SmbiosEntryPointType = 1;
pub const SmbiosEntryPointType_SMBIOS_ENTRY_POINT_TYPE_AUTO: SmbiosEntryPointType = 2;
pub const SmbiosEntryPointType_SMBIOS_ENTRY_POINT_TYPE__MAX: SmbiosEntryPointType = 3;
pub type SmbiosEntryPointType = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CpuInfoS390 {
    pub cpu_state: CpuS390State,
    pub has_dedicated: bool,
    pub dedicated: bool,
    pub has_entitlement: bool,
    pub entitlement: CpuS390Entitlement,
}
#[test]
fn bindgen_test_layout_CpuInfoS390() {
    const UNINIT: ::core::mem::MaybeUninit<CpuInfoS390> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CpuInfoS390>(),
        12usize,
        concat!("Size of: ", stringify!(CpuInfoS390))
    );
    assert_eq!(
        ::core::mem::align_of::<CpuInfoS390>(),
        4usize,
        concat!("Alignment of ", stringify!(CpuInfoS390))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoS390),
            "::",
            stringify!(cpu_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_dedicated) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoS390),
            "::",
            stringify!(has_dedicated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dedicated) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoS390),
            "::",
            stringify!(dedicated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_entitlement) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoS390),
            "::",
            stringify!(has_entitlement)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entitlement) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoS390),
            "::",
            stringify!(entitlement)
        )
    );
}
impl Default for CpuInfoS390 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_CpuInfoFast_base {
    pub cpu_index: i64,
    pub qom_path: *mut core::ffi::c_char,
    pub thread_id: i64,
    pub props: *mut CpuInstanceProperties,
    pub target: SysEmuTarget,
}
#[test]
fn bindgen_test_layout_q_obj_CpuInfoFast_base() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_CpuInfoFast_base> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_CpuInfoFast_base>(),
        40usize,
        concat!("Size of: ", stringify!(q_obj_CpuInfoFast_base))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_CpuInfoFast_base>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_CpuInfoFast_base))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_CpuInfoFast_base),
            "::",
            stringify!(cpu_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qom_path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_CpuInfoFast_base),
            "::",
            stringify!(qom_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_CpuInfoFast_base),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).props) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_CpuInfoFast_base),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_CpuInfoFast_base),
            "::",
            stringify!(target)
        )
    );
}
impl Default for q_obj_CpuInfoFast_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CpuInfoFast {
    pub cpu_index: i64,
    pub qom_path: *mut core::ffi::c_char,
    pub thread_id: i64,
    pub props: *mut CpuInstanceProperties,
    pub target: SysEmuTarget,
    pub u: CpuInfoFast__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CpuInfoFast__bindgen_ty_1 {
    pub s390x: CpuInfoS390,
}
#[test]
fn bindgen_test_layout_CpuInfoFast__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CpuInfoFast__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CpuInfoFast__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(CpuInfoFast__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CpuInfoFast__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CpuInfoFast__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s390x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoFast__bindgen_ty_1),
            "::",
            stringify!(s390x)
        )
    );
}
impl Default for CpuInfoFast__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CpuInfoFast__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "CpuInfoFast__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_CpuInfoFast() {
    const UNINIT: ::core::mem::MaybeUninit<CpuInfoFast> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CpuInfoFast>(),
        48usize,
        concat!("Size of: ", stringify!(CpuInfoFast))
    );
    assert_eq!(
        ::core::mem::align_of::<CpuInfoFast>(),
        8usize,
        concat!("Alignment of ", stringify!(CpuInfoFast))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoFast),
            "::",
            stringify!(cpu_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qom_path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoFast),
            "::",
            stringify!(qom_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoFast),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).props) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoFast),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoFast),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoFast),
            "::",
            stringify!(u)
        )
    );
}
impl Default for CpuInfoFast {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CpuInfoFast {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "CpuInfoFast {{ cpu_index: {:?}, qom_path: {:?}, thread_id: {:?}, props: {:?}, target: {:?}, u: {:?} }}" , self . cpu_index , self . qom_path , self . thread_id , self . props , self . target , self . u)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CpuInfoFastList {
    pub next: *mut CpuInfoFastList,
    pub value: *mut CpuInfoFast,
}
#[test]
fn bindgen_test_layout_CpuInfoFastList() {
    const UNINIT: ::core::mem::MaybeUninit<CpuInfoFastList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CpuInfoFastList>(),
        16usize,
        concat!("Size of: ", stringify!(CpuInfoFastList))
    );
    assert_eq!(
        ::core::mem::align_of::<CpuInfoFastList>(),
        8usize,
        concat!("Alignment of ", stringify!(CpuInfoFastList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoFastList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInfoFastList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for CpuInfoFastList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompatProperty {
    pub qom_type: *mut core::ffi::c_char,
    pub property: *mut core::ffi::c_char,
    pub value: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_CompatProperty() {
    const UNINIT: ::core::mem::MaybeUninit<CompatProperty> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CompatProperty>(),
        24usize,
        concat!("Size of: ", stringify!(CompatProperty))
    );
    assert_eq!(
        ::core::mem::align_of::<CompatProperty>(),
        8usize,
        concat!("Alignment of ", stringify!(CompatProperty))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qom_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CompatProperty),
            "::",
            stringify!(qom_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CompatProperty),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CompatProperty),
            "::",
            stringify!(value)
        )
    );
}
impl Default for CompatProperty {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CompatPropertyList {
    pub next: *mut CompatPropertyList,
    pub value: *mut CompatProperty,
}
#[test]
fn bindgen_test_layout_CompatPropertyList() {
    const UNINIT: ::core::mem::MaybeUninit<CompatPropertyList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CompatPropertyList>(),
        16usize,
        concat!("Size of: ", stringify!(CompatPropertyList))
    );
    assert_eq!(
        ::core::mem::align_of::<CompatPropertyList>(),
        8usize,
        concat!("Alignment of ", stringify!(CompatPropertyList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CompatPropertyList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CompatPropertyList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for CompatPropertyList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachineInfo {
    pub name: *mut core::ffi::c_char,
    pub alias: *mut core::ffi::c_char,
    pub has_is_default: bool,
    pub is_default: bool,
    pub cpu_max: i64,
    pub hotpluggable_cpus: bool,
    pub numa_mem_supported: bool,
    pub deprecated: bool,
    pub default_cpu_type: *mut core::ffi::c_char,
    pub default_ram_id: *mut core::ffi::c_char,
    pub acpi: bool,
    pub has_compat_props: bool,
    pub compat_props: *mut CompatPropertyList,
}
#[test]
fn bindgen_test_layout_MachineInfo() {
    const UNINIT: ::core::mem::MaybeUninit<MachineInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MachineInfo>(),
        72usize,
        concat!("Size of: ", stringify!(MachineInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<MachineInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MachineInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_is_default) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(has_is_default)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_default) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(is_default)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_max) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(cpu_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hotpluggable_cpus) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(hotpluggable_cpus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numa_mem_supported) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(numa_mem_supported)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deprecated) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(deprecated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_cpu_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(default_cpu_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_ram_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(default_ram_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acpi) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(acpi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_compat_props) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(has_compat_props)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compat_props) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfo),
            "::",
            stringify!(compat_props)
        )
    );
}
impl Default for MachineInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct q_obj_query_machines_arg {
    pub has_compat_props: bool,
    pub compat_props: bool,
}
#[test]
fn bindgen_test_layout_q_obj_query_machines_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_query_machines_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_query_machines_arg>(),
        2usize,
        concat!("Size of: ", stringify!(q_obj_query_machines_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_query_machines_arg>(),
        1usize,
        concat!("Alignment of ", stringify!(q_obj_query_machines_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_compat_props) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_query_machines_arg),
            "::",
            stringify!(has_compat_props)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compat_props) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_query_machines_arg),
            "::",
            stringify!(compat_props)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MachineInfoList {
    pub next: *mut MachineInfoList,
    pub value: *mut MachineInfo,
}
#[test]
fn bindgen_test_layout_MachineInfoList() {
    const UNINIT: ::core::mem::MaybeUninit<MachineInfoList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MachineInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(MachineInfoList))
    );
    assert_eq!(
        ::core::mem::align_of::<MachineInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(MachineInfoList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfoList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MachineInfoList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for MachineInfoList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CurrentMachineParams {
    pub wakeup_suspend_support: bool,
}
#[test]
fn bindgen_test_layout_CurrentMachineParams() {
    const UNINIT: ::core::mem::MaybeUninit<CurrentMachineParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CurrentMachineParams>(),
        1usize,
        concat!("Size of: ", stringify!(CurrentMachineParams))
    );
    assert_eq!(
        ::core::mem::align_of::<CurrentMachineParams>(),
        1usize,
        concat!("Alignment of ", stringify!(CurrentMachineParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wakeup_suspend_support) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CurrentMachineParams),
            "::",
            stringify!(wakeup_suspend_support)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TargetInfo {
    pub arch: SysEmuTarget,
}
#[test]
fn bindgen_test_layout_TargetInfo() {
    const UNINIT: ::core::mem::MaybeUninit<TargetInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TargetInfo>(),
        4usize,
        concat!("Size of: ", stringify!(TargetInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<TargetInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(TargetInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TargetInfo),
            "::",
            stringify!(arch)
        )
    );
}
impl Default for TargetInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UuidInfo {
    pub UUID: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_UuidInfo() {
    const UNINIT: ::core::mem::MaybeUninit<UuidInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<UuidInfo>(),
        8usize,
        concat!("Size of: ", stringify!(UuidInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<UuidInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(UuidInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UUID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UuidInfo),
            "::",
            stringify!(UUID)
        )
    );
}
impl Default for UuidInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GuidInfo {
    pub guid: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_GuidInfo() {
    const UNINIT: ::core::mem::MaybeUninit<GuidInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GuidInfo>(),
        8usize,
        concat!("Size of: ", stringify!(GuidInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<GuidInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(GuidInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).guid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GuidInfo),
            "::",
            stringify!(guid)
        )
    );
}
impl Default for GuidInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct KvmInfo {
    pub enabled: bool,
    pub present: bool,
}
#[test]
fn bindgen_test_layout_KvmInfo() {
    const UNINIT: ::core::mem::MaybeUninit<KvmInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<KvmInfo>(),
        2usize,
        concat!("Size of: ", stringify!(KvmInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<KvmInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(KvmInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(KvmInfo),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).present) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(KvmInfo),
            "::",
            stringify!(present)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_NumaOptions_base {
    pub type_: NumaOptionsType,
}
#[test]
fn bindgen_test_layout_q_obj_NumaOptions_base() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_NumaOptions_base> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_NumaOptions_base>(),
        4usize,
        concat!("Size of: ", stringify!(q_obj_NumaOptions_base))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_NumaOptions_base>(),
        4usize,
        concat!("Alignment of ", stringify!(q_obj_NumaOptions_base))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_NumaOptions_base),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for q_obj_NumaOptions_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumaNodeOptions {
    pub has_nodeid: bool,
    pub nodeid: u16,
    pub has_cpus: bool,
    pub cpus: *mut uint16List,
    pub has_mem: bool,
    pub mem: u64,
    pub memdev: *mut core::ffi::c_char,
    pub has_initiator: bool,
    pub initiator: u16,
}
#[test]
fn bindgen_test_layout_NumaNodeOptions() {
    const UNINIT: ::core::mem::MaybeUninit<NumaNodeOptions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NumaNodeOptions>(),
        48usize,
        concat!("Size of: ", stringify!(NumaNodeOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<NumaNodeOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(NumaNodeOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_nodeid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaNodeOptions),
            "::",
            stringify!(has_nodeid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nodeid) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaNodeOptions),
            "::",
            stringify!(nodeid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_cpus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaNodeOptions),
            "::",
            stringify!(has_cpus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaNodeOptions),
            "::",
            stringify!(cpus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_mem) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaNodeOptions),
            "::",
            stringify!(has_mem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaNodeOptions),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memdev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaNodeOptions),
            "::",
            stringify!(memdev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_initiator) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaNodeOptions),
            "::",
            stringify!(has_initiator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initiator) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaNodeOptions),
            "::",
            stringify!(initiator)
        )
    );
}
impl Default for NumaNodeOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NumaDistOptions {
    pub src: u16,
    pub dst: u16,
    pub val: u8,
}
#[test]
fn bindgen_test_layout_NumaDistOptions() {
    const UNINIT: ::core::mem::MaybeUninit<NumaDistOptions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NumaDistOptions>(),
        6usize,
        concat!("Size of: ", stringify!(NumaDistOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<NumaDistOptions>(),
        2usize,
        concat!("Alignment of ", stringify!(NumaDistOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaDistOptions),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaDistOptions),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaDistOptions),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NumaCpuOptions {
    pub has_node_id: bool,
    pub node_id: i64,
    pub has_drawer_id: bool,
    pub drawer_id: i64,
    pub has_book_id: bool,
    pub book_id: i64,
    pub has_socket_id: bool,
    pub socket_id: i64,
    pub has_die_id: bool,
    pub die_id: i64,
    pub has_cluster_id: bool,
    pub cluster_id: i64,
    pub has_module_id: bool,
    pub module_id: i64,
    pub has_core_id: bool,
    pub core_id: i64,
    pub has_thread_id: bool,
    pub thread_id: i64,
}
#[test]
fn bindgen_test_layout_NumaCpuOptions() {
    const UNINIT: ::core::mem::MaybeUninit<NumaCpuOptions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NumaCpuOptions>(),
        144usize,
        concat!("Size of: ", stringify!(NumaCpuOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<NumaCpuOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(NumaCpuOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_node_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(has_node_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_drawer_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(has_drawer_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drawer_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(drawer_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_book_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(has_book_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).book_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(book_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_socket_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(has_socket_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).socket_id) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_die_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(has_die_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).die_id) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(die_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_cluster_id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(has_cluster_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cluster_id) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(cluster_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_module_id) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(has_module_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module_id) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(module_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_core_id) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(has_core_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).core_id) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_thread_id) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(has_thread_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaCpuOptions),
            "::",
            stringify!(thread_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumaHmatLBOptions {
    pub initiator: u16,
    pub target: u16,
    pub hierarchy: HmatLBMemoryHierarchy,
    pub data_type: HmatLBDataType,
    pub has_latency: bool,
    pub latency: u64,
    pub has_bandwidth: bool,
    pub bandwidth: u64,
}
#[test]
fn bindgen_test_layout_NumaHmatLBOptions() {
    const UNINIT: ::core::mem::MaybeUninit<NumaHmatLBOptions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NumaHmatLBOptions>(),
        40usize,
        concat!("Size of: ", stringify!(NumaHmatLBOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<NumaHmatLBOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(NumaHmatLBOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initiator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatLBOptions),
            "::",
            stringify!(initiator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatLBOptions),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hierarchy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatLBOptions),
            "::",
            stringify!(hierarchy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatLBOptions),
            "::",
            stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_latency) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatLBOptions),
            "::",
            stringify!(has_latency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).latency) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatLBOptions),
            "::",
            stringify!(latency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_bandwidth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatLBOptions),
            "::",
            stringify!(has_bandwidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bandwidth) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatLBOptions),
            "::",
            stringify!(bandwidth)
        )
    );
}
impl Default for NumaHmatLBOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NumaHmatCacheOptions {
    pub node_id: u32,
    pub size: u64,
    pub level: u8,
    pub associativity: HmatCacheAssociativity,
    pub policy: HmatCacheWritePolicy,
    pub line: u16,
}
#[test]
fn bindgen_test_layout_NumaHmatCacheOptions() {
    const UNINIT: ::core::mem::MaybeUninit<NumaHmatCacheOptions> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NumaHmatCacheOptions>(),
        32usize,
        concat!("Size of: ", stringify!(NumaHmatCacheOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<NumaHmatCacheOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(NumaHmatCacheOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatCacheOptions),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatCacheOptions),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatCacheOptions),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).associativity) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatCacheOptions),
            "::",
            stringify!(associativity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).policy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatCacheOptions),
            "::",
            stringify!(policy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaHmatCacheOptions),
            "::",
            stringify!(line)
        )
    );
}
impl Default for NumaHmatCacheOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NumaOptions {
    pub type_: NumaOptionsType,
    pub u: NumaOptions__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NumaOptions__bindgen_ty_1 {
    pub node: NumaNodeOptions,
    pub dist: NumaDistOptions,
    pub cpu: NumaCpuOptions,
    pub hmat_lb: NumaHmatLBOptions,
    pub hmat_cache: NumaHmatCacheOptions,
}
#[test]
fn bindgen_test_layout_NumaOptions__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<NumaOptions__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NumaOptions__bindgen_ty_1>(),
        144usize,
        concat!("Size of: ", stringify!(NumaOptions__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NumaOptions__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(NumaOptions__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaOptions__bindgen_ty_1),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dist) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaOptions__bindgen_ty_1),
            "::",
            stringify!(dist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaOptions__bindgen_ty_1),
            "::",
            stringify!(cpu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hmat_lb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaOptions__bindgen_ty_1),
            "::",
            stringify!(hmat_lb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hmat_cache) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaOptions__bindgen_ty_1),
            "::",
            stringify!(hmat_cache)
        )
    );
}
impl Default for NumaOptions__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for NumaOptions__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "NumaOptions__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_NumaOptions() {
    const UNINIT: ::core::mem::MaybeUninit<NumaOptions> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NumaOptions>(),
        152usize,
        concat!("Size of: ", stringify!(NumaOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<NumaOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(NumaOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaOptions),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NumaOptions),
            "::",
            stringify!(u)
        )
    );
}
impl Default for NumaOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for NumaOptions {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "NumaOptions {{ type: {:?}, u: {:?} }}",
            self.type_, self.u
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXLFixedMemoryWindowOptions {
    pub size: u64,
    pub has_interleave_granularity: bool,
    pub interleave_granularity: u64,
    pub targets: *mut strList,
}
#[test]
fn bindgen_test_layout_CXLFixedMemoryWindowOptions() {
    const UNINIT: ::core::mem::MaybeUninit<CXLFixedMemoryWindowOptions> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CXLFixedMemoryWindowOptions>(),
        32usize,
        concat!("Size of: ", stringify!(CXLFixedMemoryWindowOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<CXLFixedMemoryWindowOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(CXLFixedMemoryWindowOptions))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXLFixedMemoryWindowOptions),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_interleave_granularity) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXLFixedMemoryWindowOptions),
            "::",
            stringify!(has_interleave_granularity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interleave_granularity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CXLFixedMemoryWindowOptions),
            "::",
            stringify!(interleave_granularity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).targets) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CXLFixedMemoryWindowOptions),
            "::",
            stringify!(targets)
        )
    );
}
impl Default for CXLFixedMemoryWindowOptions {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXLFixedMemoryWindowOptionsList {
    pub next: *mut CXLFixedMemoryWindowOptionsList,
    pub value: *mut CXLFixedMemoryWindowOptions,
}
#[test]
fn bindgen_test_layout_CXLFixedMemoryWindowOptionsList() {
    const UNINIT: ::core::mem::MaybeUninit<CXLFixedMemoryWindowOptionsList> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CXLFixedMemoryWindowOptionsList>(),
        16usize,
        concat!("Size of: ", stringify!(CXLFixedMemoryWindowOptionsList))
    );
    assert_eq!(
        ::core::mem::align_of::<CXLFixedMemoryWindowOptionsList>(),
        8usize,
        concat!("Alignment of ", stringify!(CXLFixedMemoryWindowOptionsList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXLFixedMemoryWindowOptionsList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CXLFixedMemoryWindowOptionsList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for CXLFixedMemoryWindowOptionsList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CXLFMWProperties {
    pub cxl_fmw: *mut CXLFixedMemoryWindowOptionsList,
}
#[test]
fn bindgen_test_layout_CXLFMWProperties() {
    const UNINIT: ::core::mem::MaybeUninit<CXLFMWProperties> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CXLFMWProperties>(),
        8usize,
        concat!("Size of: ", stringify!(CXLFMWProperties))
    );
    assert_eq!(
        ::core::mem::align_of::<CXLFMWProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(CXLFMWProperties))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cxl_fmw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CXLFMWProperties),
            "::",
            stringify!(cxl_fmw)
        )
    );
}
impl Default for CXLFMWProperties {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X86CPUFeatureWordInfo {
    pub cpuid_input_eax: i64,
    pub has_cpuid_input_ecx: bool,
    pub cpuid_input_ecx: i64,
    pub cpuid_register: X86CPURegister32,
    pub features: i64,
}
#[test]
fn bindgen_test_layout_X86CPUFeatureWordInfo() {
    const UNINIT: ::core::mem::MaybeUninit<X86CPUFeatureWordInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<X86CPUFeatureWordInfo>(),
        40usize,
        concat!("Size of: ", stringify!(X86CPUFeatureWordInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<X86CPUFeatureWordInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(X86CPUFeatureWordInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpuid_input_eax) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X86CPUFeatureWordInfo),
            "::",
            stringify!(cpuid_input_eax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_cpuid_input_ecx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X86CPUFeatureWordInfo),
            "::",
            stringify!(has_cpuid_input_ecx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpuid_input_ecx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(X86CPUFeatureWordInfo),
            "::",
            stringify!(cpuid_input_ecx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpuid_register) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(X86CPUFeatureWordInfo),
            "::",
            stringify!(cpuid_register)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(X86CPUFeatureWordInfo),
            "::",
            stringify!(features)
        )
    );
}
impl Default for X86CPUFeatureWordInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct X86CPUFeatureWordInfoList {
    pub next: *mut X86CPUFeatureWordInfoList,
    pub value: *mut X86CPUFeatureWordInfo,
}
#[test]
fn bindgen_test_layout_X86CPUFeatureWordInfoList() {
    const UNINIT: ::core::mem::MaybeUninit<X86CPUFeatureWordInfoList> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<X86CPUFeatureWordInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(X86CPUFeatureWordInfoList))
    );
    assert_eq!(
        ::core::mem::align_of::<X86CPUFeatureWordInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(X86CPUFeatureWordInfoList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(X86CPUFeatureWordInfoList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(X86CPUFeatureWordInfoList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for X86CPUFeatureWordInfoList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DummyForceArrays {
    pub unused: *mut X86CPUFeatureWordInfoList,
}
#[test]
fn bindgen_test_layout_DummyForceArrays() {
    const UNINIT: ::core::mem::MaybeUninit<DummyForceArrays> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DummyForceArrays>(),
        8usize,
        concat!("Size of: ", stringify!(DummyForceArrays))
    );
    assert_eq!(
        ::core::mem::align_of::<DummyForceArrays>(),
        8usize,
        concat!("Alignment of ", stringify!(DummyForceArrays))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DummyForceArrays),
            "::",
            stringify!(unused)
        )
    );
}
impl Default for DummyForceArrays {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_memsave_arg {
    pub val: i64,
    pub size: i64,
    pub filename: *mut core::ffi::c_char,
    pub has_cpu_index: bool,
    pub cpu_index: i64,
}
#[test]
fn bindgen_test_layout_q_obj_memsave_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_memsave_arg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_memsave_arg>(),
        40usize,
        concat!("Size of: ", stringify!(q_obj_memsave_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_memsave_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_memsave_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_memsave_arg),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_memsave_arg),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_memsave_arg),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_cpu_index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_memsave_arg),
            "::",
            stringify!(has_cpu_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_index) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_memsave_arg),
            "::",
            stringify!(cpu_index)
        )
    );
}
impl Default for q_obj_memsave_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_pmemsave_arg {
    pub val: i64,
    pub size: i64,
    pub filename: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_q_obj_pmemsave_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_pmemsave_arg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_pmemsave_arg>(),
        24usize,
        concat!("Size of: ", stringify!(q_obj_pmemsave_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_pmemsave_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_pmemsave_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_pmemsave_arg),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_pmemsave_arg),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_pmemsave_arg),
            "::",
            stringify!(filename)
        )
    );
}
impl Default for q_obj_pmemsave_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Memdev {
    pub id: *mut core::ffi::c_char,
    pub size: u64,
    pub merge: bool,
    pub dump: bool,
    pub prealloc: bool,
    pub share: bool,
    pub has_reserve: bool,
    pub reserve: bool,
    pub host_nodes: *mut uint16List,
    pub policy: HostMemPolicy,
}
#[test]
fn bindgen_test_layout_Memdev() {
    const UNINIT: ::core::mem::MaybeUninit<Memdev> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Memdev>(),
        40usize,
        concat!("Size of: ", stringify!(Memdev))
    );
    assert_eq!(
        ::core::mem::align_of::<Memdev>(),
        8usize,
        concat!("Alignment of ", stringify!(Memdev))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Memdev),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Memdev),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).merge) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Memdev),
            "::",
            stringify!(merge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dump) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(Memdev),
            "::",
            stringify!(dump)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prealloc) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(Memdev),
            "::",
            stringify!(prealloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).share) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(Memdev),
            "::",
            stringify!(share)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_reserve) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Memdev),
            "::",
            stringify!(has_reserve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserve) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(Memdev),
            "::",
            stringify!(reserve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_nodes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Memdev),
            "::",
            stringify!(host_nodes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).policy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Memdev),
            "::",
            stringify!(policy)
        )
    );
}
impl Default for Memdev {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemdevList {
    pub next: *mut MemdevList,
    pub value: *mut Memdev,
}
#[test]
fn bindgen_test_layout_MemdevList() {
    const UNINIT: ::core::mem::MaybeUninit<MemdevList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemdevList>(),
        16usize,
        concat!("Size of: ", stringify!(MemdevList))
    );
    assert_eq!(
        ::core::mem::align_of::<MemdevList>(),
        8usize,
        concat!("Alignment of ", stringify!(MemdevList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemdevList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemdevList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for MemdevList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CpuInstanceProperties {
    pub has_node_id: bool,
    pub node_id: i64,
    pub has_drawer_id: bool,
    pub drawer_id: i64,
    pub has_book_id: bool,
    pub book_id: i64,
    pub has_socket_id: bool,
    pub socket_id: i64,
    pub has_die_id: bool,
    pub die_id: i64,
    pub has_cluster_id: bool,
    pub cluster_id: i64,
    pub has_module_id: bool,
    pub module_id: i64,
    pub has_core_id: bool,
    pub core_id: i64,
    pub has_thread_id: bool,
    pub thread_id: i64,
}
#[test]
fn bindgen_test_layout_CpuInstanceProperties() {
    const UNINIT: ::core::mem::MaybeUninit<CpuInstanceProperties> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CpuInstanceProperties>(),
        144usize,
        concat!("Size of: ", stringify!(CpuInstanceProperties))
    );
    assert_eq!(
        ::core::mem::align_of::<CpuInstanceProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(CpuInstanceProperties))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_node_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(has_node_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_drawer_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(has_drawer_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drawer_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(drawer_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_book_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(has_book_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).book_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(book_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_socket_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(has_socket_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).socket_id) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_die_id) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(has_die_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).die_id) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(die_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_cluster_id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(has_cluster_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cluster_id) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(cluster_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_module_id) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(has_module_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).module_id) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(module_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_core_id) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(has_core_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).core_id) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(core_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_thread_id) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(has_thread_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuInstanceProperties),
            "::",
            stringify!(thread_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HotpluggableCPU {
    pub type_: *mut core::ffi::c_char,
    pub vcpus_count: i64,
    pub props: *mut CpuInstanceProperties,
    pub qom_path: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_HotpluggableCPU() {
    const UNINIT: ::core::mem::MaybeUninit<HotpluggableCPU> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HotpluggableCPU>(),
        32usize,
        concat!("Size of: ", stringify!(HotpluggableCPU))
    );
    assert_eq!(
        ::core::mem::align_of::<HotpluggableCPU>(),
        8usize,
        concat!("Alignment of ", stringify!(HotpluggableCPU))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HotpluggableCPU),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vcpus_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HotpluggableCPU),
            "::",
            stringify!(vcpus_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).props) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HotpluggableCPU),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qom_path) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HotpluggableCPU),
            "::",
            stringify!(qom_path)
        )
    );
}
impl Default for HotpluggableCPU {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HotpluggableCPUList {
    pub next: *mut HotpluggableCPUList,
    pub value: *mut HotpluggableCPU,
}
#[test]
fn bindgen_test_layout_HotpluggableCPUList() {
    const UNINIT: ::core::mem::MaybeUninit<HotpluggableCPUList> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HotpluggableCPUList>(),
        16usize,
        concat!("Size of: ", stringify!(HotpluggableCPUList))
    );
    assert_eq!(
        ::core::mem::align_of::<HotpluggableCPUList>(),
        8usize,
        concat!("Alignment of ", stringify!(HotpluggableCPUList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HotpluggableCPUList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HotpluggableCPUList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for HotpluggableCPUList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct q_obj_balloon_arg {
    pub value: i64,
}
#[test]
fn bindgen_test_layout_q_obj_balloon_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_balloon_arg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_balloon_arg>(),
        8usize,
        concat!("Size of: ", stringify!(q_obj_balloon_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_balloon_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_balloon_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_balloon_arg),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BalloonInfo {
    pub actual: i64,
}
#[test]
fn bindgen_test_layout_BalloonInfo() {
    const UNINIT: ::core::mem::MaybeUninit<BalloonInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BalloonInfo>(),
        8usize,
        concat!("Size of: ", stringify!(BalloonInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<BalloonInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(BalloonInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).actual) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BalloonInfo),
            "::",
            stringify!(actual)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct q_obj_BALLOON_CHANGE_arg {
    pub actual: i64,
}
#[test]
fn bindgen_test_layout_q_obj_BALLOON_CHANGE_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_BALLOON_CHANGE_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_BALLOON_CHANGE_arg>(),
        8usize,
        concat!("Size of: ", stringify!(q_obj_BALLOON_CHANGE_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_BALLOON_CHANGE_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_BALLOON_CHANGE_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).actual) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_BALLOON_CHANGE_arg),
            "::",
            stringify!(actual)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HvBalloonInfo {
    pub committed: u64,
    pub available: u64,
}
#[test]
fn bindgen_test_layout_HvBalloonInfo() {
    const UNINIT: ::core::mem::MaybeUninit<HvBalloonInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HvBalloonInfo>(),
        16usize,
        concat!("Size of: ", stringify!(HvBalloonInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<HvBalloonInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(HvBalloonInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).committed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HvBalloonInfo),
            "::",
            stringify!(committed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).available) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HvBalloonInfo),
            "::",
            stringify!(available)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoryInfo {
    pub base_memory: u64,
    pub has_plugged_memory: bool,
    pub plugged_memory: u64,
}
#[test]
fn bindgen_test_layout_MemoryInfo() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryInfo>(),
        24usize,
        concat!("Size of: ", stringify!(MemoryInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base_memory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(base_memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_plugged_memory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(has_plugged_memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plugged_memory) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryInfo),
            "::",
            stringify!(plugged_memory)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCDIMMDeviceInfo {
    pub id: *mut core::ffi::c_char,
    pub addr: i64,
    pub size: i64,
    pub slot: i64,
    pub node: i64,
    pub memdev: *mut core::ffi::c_char,
    pub hotplugged: bool,
    pub hotpluggable: bool,
}
#[test]
fn bindgen_test_layout_PCDIMMDeviceInfo() {
    const UNINIT: ::core::mem::MaybeUninit<PCDIMMDeviceInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PCDIMMDeviceInfo>(),
        56usize,
        concat!("Size of: ", stringify!(PCDIMMDeviceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<PCDIMMDeviceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PCDIMMDeviceInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PCDIMMDeviceInfo),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PCDIMMDeviceInfo),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PCDIMMDeviceInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slot) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PCDIMMDeviceInfo),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PCDIMMDeviceInfo),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memdev) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PCDIMMDeviceInfo),
            "::",
            stringify!(memdev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hotplugged) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PCDIMMDeviceInfo),
            "::",
            stringify!(hotplugged)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hotpluggable) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(PCDIMMDeviceInfo),
            "::",
            stringify!(hotpluggable)
        )
    );
}
impl Default for PCDIMMDeviceInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtioPMEMDeviceInfo {
    pub id: *mut core::ffi::c_char,
    pub memaddr: u64,
    pub size: u64,
    pub memdev: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_VirtioPMEMDeviceInfo() {
    const UNINIT: ::core::mem::MaybeUninit<VirtioPMEMDeviceInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VirtioPMEMDeviceInfo>(),
        32usize,
        concat!("Size of: ", stringify!(VirtioPMEMDeviceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<VirtioPMEMDeviceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VirtioPMEMDeviceInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioPMEMDeviceInfo),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioPMEMDeviceInfo),
            "::",
            stringify!(memaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioPMEMDeviceInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memdev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioPMEMDeviceInfo),
            "::",
            stringify!(memdev)
        )
    );
}
impl Default for VirtioPMEMDeviceInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtioMEMDeviceInfo {
    pub id: *mut core::ffi::c_char,
    pub memaddr: u64,
    pub requested_size: u64,
    pub size: u64,
    pub max_size: u64,
    pub block_size: u64,
    pub node: i64,
    pub memdev: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_VirtioMEMDeviceInfo() {
    const UNINIT: ::core::mem::MaybeUninit<VirtioMEMDeviceInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VirtioMEMDeviceInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VirtioMEMDeviceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<VirtioMEMDeviceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VirtioMEMDeviceInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioMEMDeviceInfo),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioMEMDeviceInfo),
            "::",
            stringify!(memaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).requested_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioMEMDeviceInfo),
            "::",
            stringify!(requested_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioMEMDeviceInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioMEMDeviceInfo),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioMEMDeviceInfo),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioMEMDeviceInfo),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memdev) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioMEMDeviceInfo),
            "::",
            stringify!(memdev)
        )
    );
}
impl Default for VirtioMEMDeviceInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SgxEPCDeviceInfo {
    pub id: *mut core::ffi::c_char,
    pub memaddr: u64,
    pub size: u64,
    pub node: i64,
    pub memdev: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_SgxEPCDeviceInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SgxEPCDeviceInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SgxEPCDeviceInfo>(),
        40usize,
        concat!("Size of: ", stringify!(SgxEPCDeviceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SgxEPCDeviceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SgxEPCDeviceInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SgxEPCDeviceInfo),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SgxEPCDeviceInfo),
            "::",
            stringify!(memaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SgxEPCDeviceInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SgxEPCDeviceInfo),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memdev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SgxEPCDeviceInfo),
            "::",
            stringify!(memdev)
        )
    );
}
impl Default for SgxEPCDeviceInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HvBalloonDeviceInfo {
    pub id: *mut core::ffi::c_char,
    pub has_memaddr: bool,
    pub memaddr: u64,
    pub max_size: u64,
    pub memdev: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_HvBalloonDeviceInfo() {
    const UNINIT: ::core::mem::MaybeUninit<HvBalloonDeviceInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HvBalloonDeviceInfo>(),
        40usize,
        concat!("Size of: ", stringify!(HvBalloonDeviceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<HvBalloonDeviceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(HvBalloonDeviceInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HvBalloonDeviceInfo),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_memaddr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HvBalloonDeviceInfo),
            "::",
            stringify!(has_memaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memaddr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HvBalloonDeviceInfo),
            "::",
            stringify!(memaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HvBalloonDeviceInfo),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memdev) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HvBalloonDeviceInfo),
            "::",
            stringify!(memdev)
        )
    );
}
impl Default for HvBalloonDeviceInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PCDIMMDeviceInfoWrapper {
    pub data: *mut PCDIMMDeviceInfo,
}
#[test]
fn bindgen_test_layout_PCDIMMDeviceInfoWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<PCDIMMDeviceInfoWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PCDIMMDeviceInfoWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(PCDIMMDeviceInfoWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<PCDIMMDeviceInfoWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(PCDIMMDeviceInfoWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PCDIMMDeviceInfoWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for PCDIMMDeviceInfoWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtioPMEMDeviceInfoWrapper {
    pub data: *mut VirtioPMEMDeviceInfo,
}
#[test]
fn bindgen_test_layout_VirtioPMEMDeviceInfoWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<VirtioPMEMDeviceInfoWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VirtioPMEMDeviceInfoWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(VirtioPMEMDeviceInfoWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<VirtioPMEMDeviceInfoWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(VirtioPMEMDeviceInfoWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioPMEMDeviceInfoWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for VirtioPMEMDeviceInfoWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VirtioMEMDeviceInfoWrapper {
    pub data: *mut VirtioMEMDeviceInfo,
}
#[test]
fn bindgen_test_layout_VirtioMEMDeviceInfoWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<VirtioMEMDeviceInfoWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VirtioMEMDeviceInfoWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(VirtioMEMDeviceInfoWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<VirtioMEMDeviceInfoWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(VirtioMEMDeviceInfoWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VirtioMEMDeviceInfoWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for VirtioMEMDeviceInfoWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SgxEPCDeviceInfoWrapper {
    pub data: *mut SgxEPCDeviceInfo,
}
#[test]
fn bindgen_test_layout_SgxEPCDeviceInfoWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<SgxEPCDeviceInfoWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SgxEPCDeviceInfoWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(SgxEPCDeviceInfoWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<SgxEPCDeviceInfoWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(SgxEPCDeviceInfoWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SgxEPCDeviceInfoWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for SgxEPCDeviceInfoWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HvBalloonDeviceInfoWrapper {
    pub data: *mut HvBalloonDeviceInfo,
}
#[test]
fn bindgen_test_layout_HvBalloonDeviceInfoWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<HvBalloonDeviceInfoWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HvBalloonDeviceInfoWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(HvBalloonDeviceInfoWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<HvBalloonDeviceInfoWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(HvBalloonDeviceInfoWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HvBalloonDeviceInfoWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for HvBalloonDeviceInfoWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_MemoryDeviceInfo_base {
    pub type_: MemoryDeviceInfoKind,
}
#[test]
fn bindgen_test_layout_q_obj_MemoryDeviceInfo_base() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_MemoryDeviceInfo_base> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_MemoryDeviceInfo_base>(),
        4usize,
        concat!("Size of: ", stringify!(q_obj_MemoryDeviceInfo_base))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_MemoryDeviceInfo_base>(),
        4usize,
        concat!("Alignment of ", stringify!(q_obj_MemoryDeviceInfo_base))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_MemoryDeviceInfo_base),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for q_obj_MemoryDeviceInfo_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryDeviceInfo {
    pub type_: MemoryDeviceInfoKind,
    pub u: MemoryDeviceInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryDeviceInfo__bindgen_ty_1 {
    pub dimm: PCDIMMDeviceInfoWrapper,
    pub nvdimm: PCDIMMDeviceInfoWrapper,
    pub virtio_pmem: VirtioPMEMDeviceInfoWrapper,
    pub virtio_mem: VirtioMEMDeviceInfoWrapper,
    pub sgx_epc: SgxEPCDeviceInfoWrapper,
    pub hv_balloon: HvBalloonDeviceInfoWrapper,
}
#[test]
fn bindgen_test_layout_MemoryDeviceInfo__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryDeviceInfo__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryDeviceInfo__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(MemoryDeviceInfo__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryDeviceInfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryDeviceInfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dimm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryDeviceInfo__bindgen_ty_1),
            "::",
            stringify!(dimm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvdimm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryDeviceInfo__bindgen_ty_1),
            "::",
            stringify!(nvdimm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).virtio_pmem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryDeviceInfo__bindgen_ty_1),
            "::",
            stringify!(virtio_pmem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).virtio_mem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryDeviceInfo__bindgen_ty_1),
            "::",
            stringify!(virtio_mem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sgx_epc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryDeviceInfo__bindgen_ty_1),
            "::",
            stringify!(sgx_epc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hv_balloon) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryDeviceInfo__bindgen_ty_1),
            "::",
            stringify!(hv_balloon)
        )
    );
}
impl Default for MemoryDeviceInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for MemoryDeviceInfo__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "MemoryDeviceInfo__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_MemoryDeviceInfo() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryDeviceInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryDeviceInfo>(),
        16usize,
        concat!("Size of: ", stringify!(MemoryDeviceInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryDeviceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryDeviceInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryDeviceInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryDeviceInfo),
            "::",
            stringify!(u)
        )
    );
}
impl Default for MemoryDeviceInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for MemoryDeviceInfo {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "MemoryDeviceInfo {{ type: {:?}, u: {:?} }}",
            self.type_, self.u
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SgxEPC {
    pub memdev: *mut core::ffi::c_char,
    pub node: i64,
}
#[test]
fn bindgen_test_layout_SgxEPC() {
    const UNINIT: ::core::mem::MaybeUninit<SgxEPC> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SgxEPC>(),
        16usize,
        concat!("Size of: ", stringify!(SgxEPC))
    );
    assert_eq!(
        ::core::mem::align_of::<SgxEPC>(),
        8usize,
        concat!("Alignment of ", stringify!(SgxEPC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memdev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SgxEPC),
            "::",
            stringify!(memdev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SgxEPC),
            "::",
            stringify!(node)
        )
    );
}
impl Default for SgxEPC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SgxEPCList {
    pub next: *mut SgxEPCList,
    pub value: *mut SgxEPC,
}
#[test]
fn bindgen_test_layout_SgxEPCList() {
    const UNINIT: ::core::mem::MaybeUninit<SgxEPCList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SgxEPCList>(),
        16usize,
        concat!("Size of: ", stringify!(SgxEPCList))
    );
    assert_eq!(
        ::core::mem::align_of::<SgxEPCList>(),
        8usize,
        concat!("Alignment of ", stringify!(SgxEPCList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SgxEPCList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SgxEPCList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for SgxEPCList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SgxEPCProperties {
    pub sgx_epc: *mut SgxEPCList,
}
#[test]
fn bindgen_test_layout_SgxEPCProperties() {
    const UNINIT: ::core::mem::MaybeUninit<SgxEPCProperties> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SgxEPCProperties>(),
        8usize,
        concat!("Size of: ", stringify!(SgxEPCProperties))
    );
    assert_eq!(
        ::core::mem::align_of::<SgxEPCProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(SgxEPCProperties))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sgx_epc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SgxEPCProperties),
            "::",
            stringify!(sgx_epc)
        )
    );
}
impl Default for SgxEPCProperties {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryDeviceInfoList {
    pub next: *mut MemoryDeviceInfoList,
    pub value: *mut MemoryDeviceInfo,
}
#[test]
fn bindgen_test_layout_MemoryDeviceInfoList() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryDeviceInfoList> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryDeviceInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(MemoryDeviceInfoList))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryDeviceInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryDeviceInfoList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryDeviceInfoList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryDeviceInfoList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for MemoryDeviceInfoList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg {
    pub id: *mut core::ffi::c_char,
    pub size: u64,
    pub qom_path: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg>(),
        24usize,
        concat!("Size of: ", stringify!(q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qom_path) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg),
            "::",
            stringify!(qom_path)
        )
    );
}
impl Default for q_obj_MEMORY_DEVICE_SIZE_CHANGE_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_MEM_UNPLUG_ERROR_arg {
    pub device: *mut core::ffi::c_char,
    pub msg: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_q_obj_MEM_UNPLUG_ERROR_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_MEM_UNPLUG_ERROR_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_MEM_UNPLUG_ERROR_arg>(),
        16usize,
        concat!("Size of: ", stringify!(q_obj_MEM_UNPLUG_ERROR_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_MEM_UNPLUG_ERROR_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_MEM_UNPLUG_ERROR_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_MEM_UNPLUG_ERROR_arg),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_MEM_UNPLUG_ERROR_arg),
            "::",
            stringify!(msg)
        )
    );
}
impl Default for q_obj_MEM_UNPLUG_ERROR_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BootConfiguration {
    pub order: *mut core::ffi::c_char,
    pub once: *mut core::ffi::c_char,
    pub has_menu: bool,
    pub menu: bool,
    pub splash: *mut core::ffi::c_char,
    pub has_splash_time: bool,
    pub splash_time: i64,
    pub has_reboot_timeout: bool,
    pub reboot_timeout: i64,
    pub has_strict: bool,
    pub strict: bool,
}
#[test]
fn bindgen_test_layout_BootConfiguration() {
    const UNINIT: ::core::mem::MaybeUninit<BootConfiguration> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BootConfiguration>(),
        72usize,
        concat!("Size of: ", stringify!(BootConfiguration))
    );
    assert_eq!(
        ::core::mem::align_of::<BootConfiguration>(),
        8usize,
        concat!("Alignment of ", stringify!(BootConfiguration))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).order) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BootConfiguration),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).once) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BootConfiguration),
            "::",
            stringify!(once)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_menu) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BootConfiguration),
            "::",
            stringify!(has_menu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).menu) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(BootConfiguration),
            "::",
            stringify!(menu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).splash) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BootConfiguration),
            "::",
            stringify!(splash)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_splash_time) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BootConfiguration),
            "::",
            stringify!(has_splash_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).splash_time) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BootConfiguration),
            "::",
            stringify!(splash_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_reboot_timeout) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BootConfiguration),
            "::",
            stringify!(has_reboot_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reboot_timeout) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BootConfiguration),
            "::",
            stringify!(reboot_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_strict) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BootConfiguration),
            "::",
            stringify!(has_strict)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).strict) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(BootConfiguration),
            "::",
            stringify!(strict)
        )
    );
}
impl Default for BootConfiguration {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SMPConfiguration {
    pub has_cpus: bool,
    pub cpus: i64,
    pub has_drawers: bool,
    pub drawers: i64,
    pub has_books: bool,
    pub books: i64,
    pub has_sockets: bool,
    pub sockets: i64,
    pub has_dies: bool,
    pub dies: i64,
    pub has_clusters: bool,
    pub clusters: i64,
    pub has_modules: bool,
    pub modules: i64,
    pub has_cores: bool,
    pub cores: i64,
    pub has_threads: bool,
    pub threads: i64,
    pub has_maxcpus: bool,
    pub maxcpus: i64,
}
#[test]
fn bindgen_test_layout_SMPConfiguration() {
    const UNINIT: ::core::mem::MaybeUninit<SMPConfiguration> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SMPConfiguration>(),
        160usize,
        concat!("Size of: ", stringify!(SMPConfiguration))
    );
    assert_eq!(
        ::core::mem::align_of::<SMPConfiguration>(),
        8usize,
        concat!("Alignment of ", stringify!(SMPConfiguration))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_cpus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(has_cpus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpus) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(cpus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_drawers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(has_drawers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drawers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(drawers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_books) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(has_books)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).books) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(books)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_sockets) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(has_sockets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sockets) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(sockets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_dies) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(has_dies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dies) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(dies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_clusters) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(has_clusters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clusters) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(clusters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_modules) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(has_modules)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modules) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(modules)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_cores) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(has_cores)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cores) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(cores)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_threads) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(has_threads)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).threads) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(threads)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_maxcpus) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(has_maxcpus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).maxcpus) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(SMPConfiguration),
            "::",
            stringify!(maxcpus)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemorySizeConfiguration {
    pub has_size: bool,
    pub size: u64,
    pub has_max_size: bool,
    pub max_size: u64,
    pub has_slots: bool,
    pub slots: u64,
}
#[test]
fn bindgen_test_layout_MemorySizeConfiguration() {
    const UNINIT: ::core::mem::MaybeUninit<MemorySizeConfiguration> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemorySizeConfiguration>(),
        48usize,
        concat!("Size of: ", stringify!(MemorySizeConfiguration))
    );
    assert_eq!(
        ::core::mem::align_of::<MemorySizeConfiguration>(),
        8usize,
        concat!("Alignment of ", stringify!(MemorySizeConfiguration))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemorySizeConfiguration),
            "::",
            stringify!(has_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemorySizeConfiguration),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_max_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemorySizeConfiguration),
            "::",
            stringify!(has_max_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MemorySizeConfiguration),
            "::",
            stringify!(max_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_slots) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MemorySizeConfiguration),
            "::",
            stringify!(has_slots)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slots) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MemorySizeConfiguration),
            "::",
            stringify!(slots)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_dumpdtb_arg {
    pub filename: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_q_obj_dumpdtb_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_dumpdtb_arg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_dumpdtb_arg>(),
        8usize,
        concat!("Size of: ", stringify!(q_obj_dumpdtb_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_dumpdtb_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_dumpdtb_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_dumpdtb_arg),
            "::",
            stringify!(filename)
        )
    );
}
impl Default for q_obj_dumpdtb_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RunState_RUN_STATE_DEBUG: RunState = 0;
pub const RunState_RUN_STATE_INMIGRATE: RunState = 1;
pub const RunState_RUN_STATE_INTERNAL_ERROR: RunState = 2;
pub const RunState_RUN_STATE_IO_ERROR: RunState = 3;
pub const RunState_RUN_STATE_PAUSED: RunState = 4;
pub const RunState_RUN_STATE_POSTMIGRATE: RunState = 5;
pub const RunState_RUN_STATE_PRELAUNCH: RunState = 6;
pub const RunState_RUN_STATE_FINISH_MIGRATE: RunState = 7;
pub const RunState_RUN_STATE_RESTORE_VM: RunState = 8;
pub const RunState_RUN_STATE_RUNNING: RunState = 9;
pub const RunState_RUN_STATE_SAVE_VM: RunState = 10;
pub const RunState_RUN_STATE_SHUTDOWN: RunState = 11;
pub const RunState_RUN_STATE_SUSPENDED: RunState = 12;
pub const RunState_RUN_STATE_WATCHDOG: RunState = 13;
pub const RunState_RUN_STATE_GUEST_PANICKED: RunState = 14;
pub const RunState_RUN_STATE_COLO: RunState = 15;
pub const RunState_RUN_STATE__MAX: RunState = 16;
pub type RunState = core::ffi::c_uint;
pub const ShutdownCause_SHUTDOWN_CAUSE_NONE: ShutdownCause = 0;
pub const ShutdownCause_SHUTDOWN_CAUSE_HOST_ERROR: ShutdownCause = 1;
pub const ShutdownCause_SHUTDOWN_CAUSE_HOST_QMP_QUIT: ShutdownCause = 2;
pub const ShutdownCause_SHUTDOWN_CAUSE_HOST_QMP_SYSTEM_RESET: ShutdownCause = 3;
pub const ShutdownCause_SHUTDOWN_CAUSE_HOST_SIGNAL: ShutdownCause = 4;
pub const ShutdownCause_SHUTDOWN_CAUSE_HOST_UI: ShutdownCause = 5;
pub const ShutdownCause_SHUTDOWN_CAUSE_GUEST_SHUTDOWN: ShutdownCause = 6;
pub const ShutdownCause_SHUTDOWN_CAUSE_GUEST_RESET: ShutdownCause = 7;
pub const ShutdownCause_SHUTDOWN_CAUSE_GUEST_PANIC: ShutdownCause = 8;
pub const ShutdownCause_SHUTDOWN_CAUSE_SUBSYSTEM_RESET: ShutdownCause = 9;
pub const ShutdownCause_SHUTDOWN_CAUSE_SNAPSHOT_LOAD: ShutdownCause = 10;
pub const ShutdownCause_SHUTDOWN_CAUSE__MAX: ShutdownCause = 11;
pub type ShutdownCause = core::ffi::c_uint;
pub const WatchdogAction_WATCHDOG_ACTION_RESET: WatchdogAction = 0;
pub const WatchdogAction_WATCHDOG_ACTION_SHUTDOWN: WatchdogAction = 1;
pub const WatchdogAction_WATCHDOG_ACTION_POWEROFF: WatchdogAction = 2;
pub const WatchdogAction_WATCHDOG_ACTION_PAUSE: WatchdogAction = 3;
pub const WatchdogAction_WATCHDOG_ACTION_DEBUG: WatchdogAction = 4;
pub const WatchdogAction_WATCHDOG_ACTION_NONE: WatchdogAction = 5;
pub const WatchdogAction_WATCHDOG_ACTION_INJECT_NMI: WatchdogAction = 6;
pub const WatchdogAction_WATCHDOG_ACTION__MAX: WatchdogAction = 7;
pub type WatchdogAction = core::ffi::c_uint;
pub const RebootAction_REBOOT_ACTION_RESET: RebootAction = 0;
pub const RebootAction_REBOOT_ACTION_SHUTDOWN: RebootAction = 1;
pub const RebootAction_REBOOT_ACTION__MAX: RebootAction = 2;
pub type RebootAction = core::ffi::c_uint;
pub const ShutdownAction_SHUTDOWN_ACTION_POWEROFF: ShutdownAction = 0;
pub const ShutdownAction_SHUTDOWN_ACTION_PAUSE: ShutdownAction = 1;
pub const ShutdownAction_SHUTDOWN_ACTION__MAX: ShutdownAction = 2;
pub type ShutdownAction = core::ffi::c_uint;
pub const PanicAction_PANIC_ACTION_PAUSE: PanicAction = 0;
pub const PanicAction_PANIC_ACTION_SHUTDOWN: PanicAction = 1;
pub const PanicAction_PANIC_ACTION_EXIT_FAILURE: PanicAction = 2;
pub const PanicAction_PANIC_ACTION_NONE: PanicAction = 3;
pub const PanicAction_PANIC_ACTION__MAX: PanicAction = 4;
pub type PanicAction = core::ffi::c_uint;
pub const GuestPanicAction_GUEST_PANIC_ACTION_PAUSE: GuestPanicAction = 0;
pub const GuestPanicAction_GUEST_PANIC_ACTION_POWEROFF: GuestPanicAction = 1;
pub const GuestPanicAction_GUEST_PANIC_ACTION_RUN: GuestPanicAction = 2;
pub const GuestPanicAction_GUEST_PANIC_ACTION__MAX: GuestPanicAction = 3;
pub type GuestPanicAction = core::ffi::c_uint;
pub const GuestPanicInformationType_GUEST_PANIC_INFORMATION_TYPE_HYPER_V:
    GuestPanicInformationType = 0;
pub const GuestPanicInformationType_GUEST_PANIC_INFORMATION_TYPE_S390: GuestPanicInformationType =
    1;
pub const GuestPanicInformationType_GUEST_PANIC_INFORMATION_TYPE__MAX: GuestPanicInformationType =
    2;
pub type GuestPanicInformationType = core::ffi::c_uint;
pub const S390CrashReason_S390_CRASH_REASON_UNKNOWN: S390CrashReason = 0;
pub const S390CrashReason_S390_CRASH_REASON_DISABLED_WAIT: S390CrashReason = 1;
pub const S390CrashReason_S390_CRASH_REASON_EXTINT_LOOP: S390CrashReason = 2;
pub const S390CrashReason_S390_CRASH_REASON_PGMINT_LOOP: S390CrashReason = 3;
pub const S390CrashReason_S390_CRASH_REASON_OPINT_LOOP: S390CrashReason = 4;
pub const S390CrashReason_S390_CRASH_REASON__MAX: S390CrashReason = 5;
pub type S390CrashReason = core::ffi::c_uint;
pub const MemoryFailureRecipient_MEMORY_FAILURE_RECIPIENT_HYPERVISOR: MemoryFailureRecipient = 0;
pub const MemoryFailureRecipient_MEMORY_FAILURE_RECIPIENT_GUEST: MemoryFailureRecipient = 1;
pub const MemoryFailureRecipient_MEMORY_FAILURE_RECIPIENT__MAX: MemoryFailureRecipient = 2;
pub type MemoryFailureRecipient = core::ffi::c_uint;
pub const MemoryFailureAction_MEMORY_FAILURE_ACTION_IGNORE: MemoryFailureAction = 0;
pub const MemoryFailureAction_MEMORY_FAILURE_ACTION_INJECT: MemoryFailureAction = 1;
pub const MemoryFailureAction_MEMORY_FAILURE_ACTION_FATAL: MemoryFailureAction = 2;
pub const MemoryFailureAction_MEMORY_FAILURE_ACTION_RESET: MemoryFailureAction = 3;
pub const MemoryFailureAction_MEMORY_FAILURE_ACTION__MAX: MemoryFailureAction = 4;
pub type MemoryFailureAction = core::ffi::c_uint;
pub const NotifyVmexitOption_NOTIFY_VMEXIT_OPTION_RUN: NotifyVmexitOption = 0;
pub const NotifyVmexitOption_NOTIFY_VMEXIT_OPTION_INTERNAL_ERROR: NotifyVmexitOption = 1;
pub const NotifyVmexitOption_NOTIFY_VMEXIT_OPTION_DISABLE: NotifyVmexitOption = 2;
pub const NotifyVmexitOption_NOTIFY_VMEXIT_OPTION__MAX: NotifyVmexitOption = 3;
pub type NotifyVmexitOption = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StatusInfo {
    pub running: bool,
    pub status: RunState,
}
#[test]
fn bindgen_test_layout_StatusInfo() {
    const UNINIT: ::core::mem::MaybeUninit<StatusInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<StatusInfo>(),
        8usize,
        concat!("Size of: ", stringify!(StatusInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<StatusInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(StatusInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).running) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StatusInfo),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(StatusInfo),
            "::",
            stringify!(status)
        )
    );
}
impl Default for StatusInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_SHUTDOWN_arg {
    pub guest: bool,
    pub reason: ShutdownCause,
}
#[test]
fn bindgen_test_layout_q_obj_SHUTDOWN_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_SHUTDOWN_arg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_SHUTDOWN_arg>(),
        8usize,
        concat!("Size of: ", stringify!(q_obj_SHUTDOWN_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_SHUTDOWN_arg>(),
        4usize,
        concat!("Alignment of ", stringify!(q_obj_SHUTDOWN_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).guest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_SHUTDOWN_arg),
            "::",
            stringify!(guest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_SHUTDOWN_arg),
            "::",
            stringify!(reason)
        )
    );
}
impl Default for q_obj_SHUTDOWN_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_RESET_arg {
    pub guest: bool,
    pub reason: ShutdownCause,
}
#[test]
fn bindgen_test_layout_q_obj_RESET_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_RESET_arg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_RESET_arg>(),
        8usize,
        concat!("Size of: ", stringify!(q_obj_RESET_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_RESET_arg>(),
        4usize,
        concat!("Alignment of ", stringify!(q_obj_RESET_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).guest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_RESET_arg),
            "::",
            stringify!(guest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_RESET_arg),
            "::",
            stringify!(reason)
        )
    );
}
impl Default for q_obj_RESET_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_WATCHDOG_arg {
    pub action: WatchdogAction,
}
#[test]
fn bindgen_test_layout_q_obj_WATCHDOG_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_WATCHDOG_arg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_WATCHDOG_arg>(),
        4usize,
        concat!("Size of: ", stringify!(q_obj_WATCHDOG_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_WATCHDOG_arg>(),
        4usize,
        concat!("Alignment of ", stringify!(q_obj_WATCHDOG_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_WATCHDOG_arg),
            "::",
            stringify!(action)
        )
    );
}
impl Default for q_obj_WATCHDOG_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_watchdog_set_action_arg {
    pub action: WatchdogAction,
}
#[test]
fn bindgen_test_layout_q_obj_watchdog_set_action_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_watchdog_set_action_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_watchdog_set_action_arg>(),
        4usize,
        concat!("Size of: ", stringify!(q_obj_watchdog_set_action_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_watchdog_set_action_arg>(),
        4usize,
        concat!("Alignment of ", stringify!(q_obj_watchdog_set_action_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_watchdog_set_action_arg),
            "::",
            stringify!(action)
        )
    );
}
impl Default for q_obj_watchdog_set_action_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_set_action_arg {
    pub has_reboot: bool,
    pub reboot: RebootAction,
    pub has_shutdown: bool,
    pub shutdown: ShutdownAction,
    pub has_panic: bool,
    pub panic: PanicAction,
    pub has_watchdog: bool,
    pub watchdog: WatchdogAction,
}
#[test]
fn bindgen_test_layout_q_obj_set_action_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_set_action_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_set_action_arg>(),
        32usize,
        concat!("Size of: ", stringify!(q_obj_set_action_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_set_action_arg>(),
        4usize,
        concat!("Alignment of ", stringify!(q_obj_set_action_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_reboot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_set_action_arg),
            "::",
            stringify!(has_reboot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reboot) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_set_action_arg),
            "::",
            stringify!(reboot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_shutdown) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_set_action_arg),
            "::",
            stringify!(has_shutdown)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_set_action_arg),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_panic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_set_action_arg),
            "::",
            stringify!(has_panic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).panic) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_set_action_arg),
            "::",
            stringify!(panic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_watchdog) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_set_action_arg),
            "::",
            stringify!(has_watchdog)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).watchdog) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_set_action_arg),
            "::",
            stringify!(watchdog)
        )
    );
}
impl Default for q_obj_set_action_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_GUEST_PANICKED_arg {
    pub action: GuestPanicAction,
    pub info: *mut GuestPanicInformation,
}
#[test]
fn bindgen_test_layout_q_obj_GUEST_PANICKED_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_GUEST_PANICKED_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_GUEST_PANICKED_arg>(),
        16usize,
        concat!("Size of: ", stringify!(q_obj_GUEST_PANICKED_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_GUEST_PANICKED_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_GUEST_PANICKED_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_GUEST_PANICKED_arg),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_GUEST_PANICKED_arg),
            "::",
            stringify!(info)
        )
    );
}
impl Default for q_obj_GUEST_PANICKED_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_GUEST_CRASHLOADED_arg {
    pub action: GuestPanicAction,
    pub info: *mut GuestPanicInformation,
}
#[test]
fn bindgen_test_layout_q_obj_GUEST_CRASHLOADED_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_GUEST_CRASHLOADED_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_GUEST_CRASHLOADED_arg>(),
        16usize,
        concat!("Size of: ", stringify!(q_obj_GUEST_CRASHLOADED_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_GUEST_CRASHLOADED_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_GUEST_CRASHLOADED_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_GUEST_CRASHLOADED_arg),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_GUEST_CRASHLOADED_arg),
            "::",
            stringify!(info)
        )
    );
}
impl Default for q_obj_GUEST_CRASHLOADED_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_GuestPanicInformation_base {
    pub type_: GuestPanicInformationType,
}
#[test]
fn bindgen_test_layout_q_obj_GuestPanicInformation_base() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_GuestPanicInformation_base> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_GuestPanicInformation_base>(),
        4usize,
        concat!("Size of: ", stringify!(q_obj_GuestPanicInformation_base))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_GuestPanicInformation_base>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(q_obj_GuestPanicInformation_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_GuestPanicInformation_base),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for q_obj_GuestPanicInformation_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GuestPanicInformationHyperV {
    pub arg1: u64,
    pub arg2: u64,
    pub arg3: u64,
    pub arg4: u64,
    pub arg5: u64,
}
#[test]
fn bindgen_test_layout_GuestPanicInformationHyperV() {
    const UNINIT: ::core::mem::MaybeUninit<GuestPanicInformationHyperV> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GuestPanicInformationHyperV>(),
        40usize,
        concat!("Size of: ", stringify!(GuestPanicInformationHyperV))
    );
    assert_eq!(
        ::core::mem::align_of::<GuestPanicInformationHyperV>(),
        8usize,
        concat!("Alignment of ", stringify!(GuestPanicInformationHyperV))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformationHyperV),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformationHyperV),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformationHyperV),
            "::",
            stringify!(arg3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg4) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformationHyperV),
            "::",
            stringify!(arg4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg5) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformationHyperV),
            "::",
            stringify!(arg5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GuestPanicInformationS390 {
    pub core: u32,
    pub psw_mask: u64,
    pub psw_addr: u64,
    pub reason: S390CrashReason,
}
#[test]
fn bindgen_test_layout_GuestPanicInformationS390() {
    const UNINIT: ::core::mem::MaybeUninit<GuestPanicInformationS390> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GuestPanicInformationS390>(),
        32usize,
        concat!("Size of: ", stringify!(GuestPanicInformationS390))
    );
    assert_eq!(
        ::core::mem::align_of::<GuestPanicInformationS390>(),
        8usize,
        concat!("Alignment of ", stringify!(GuestPanicInformationS390))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).core) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformationS390),
            "::",
            stringify!(core)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).psw_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformationS390),
            "::",
            stringify!(psw_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).psw_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformationS390),
            "::",
            stringify!(psw_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformationS390),
            "::",
            stringify!(reason)
        )
    );
}
impl Default for GuestPanicInformationS390 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GuestPanicInformation {
    pub type_: GuestPanicInformationType,
    pub u: GuestPanicInformation__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GuestPanicInformation__bindgen_ty_1 {
    pub hyper_v: GuestPanicInformationHyperV,
    pub s390: GuestPanicInformationS390,
}
#[test]
fn bindgen_test_layout_GuestPanicInformation__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<GuestPanicInformation__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GuestPanicInformation__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(GuestPanicInformation__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GuestPanicInformation__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(GuestPanicInformation__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hyper_v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformation__bindgen_ty_1),
            "::",
            stringify!(hyper_v)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s390) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformation__bindgen_ty_1),
            "::",
            stringify!(s390)
        )
    );
}
impl Default for GuestPanicInformation__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for GuestPanicInformation__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "GuestPanicInformation__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_GuestPanicInformation() {
    const UNINIT: ::core::mem::MaybeUninit<GuestPanicInformation> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GuestPanicInformation>(),
        48usize,
        concat!("Size of: ", stringify!(GuestPanicInformation))
    );
    assert_eq!(
        ::core::mem::align_of::<GuestPanicInformation>(),
        8usize,
        concat!("Alignment of ", stringify!(GuestPanicInformation))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformation),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GuestPanicInformation),
            "::",
            stringify!(u)
        )
    );
}
impl Default for GuestPanicInformation {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for GuestPanicInformation {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "GuestPanicInformation {{ type: {:?}, u: {:?} }}",
            self.type_, self.u
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_MEMORY_FAILURE_arg {
    pub recipient: MemoryFailureRecipient,
    pub action: MemoryFailureAction,
    pub flags: *mut MemoryFailureFlags,
}
#[test]
fn bindgen_test_layout_q_obj_MEMORY_FAILURE_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_MEMORY_FAILURE_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_MEMORY_FAILURE_arg>(),
        16usize,
        concat!("Size of: ", stringify!(q_obj_MEMORY_FAILURE_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_MEMORY_FAILURE_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_MEMORY_FAILURE_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recipient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_MEMORY_FAILURE_arg),
            "::",
            stringify!(recipient)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).action) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_MEMORY_FAILURE_arg),
            "::",
            stringify!(action)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_MEMORY_FAILURE_arg),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for q_obj_MEMORY_FAILURE_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoryFailureFlags {
    pub action_required: bool,
    pub recursive: bool,
}
#[test]
fn bindgen_test_layout_MemoryFailureFlags() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryFailureFlags> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryFailureFlags>(),
        2usize,
        concat!("Size of: ", stringify!(MemoryFailureFlags))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryFailureFlags>(),
        1usize,
        concat!("Alignment of ", stringify!(MemoryFailureFlags))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).action_required) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryFailureFlags),
            "::",
            stringify!(action_required)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recursive) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryFailureFlags),
            "::",
            stringify!(recursive)
        )
    );
}
pub type WriteCoreDumpFunction = ::core::option::Option<
    unsafe extern "C" fn(
        buf: *const core::ffi::c_void,
        size: usize,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUAddressSpace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUJumpCache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelCPUClass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysemuCPUOps {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUClass {
    pub parent_class: DeviceClass,
    pub class_by_name: ::core::option::Option<
        unsafe extern "C" fn(cpu_model: *const core::ffi::c_char) -> *mut ObjectClass,
    >,
    pub parse_features: ::core::option::Option<
        unsafe extern "C" fn(
            typename: *const core::ffi::c_char,
            str_: *mut core::ffi::c_char,
            errp: *mut *mut Error,
        ),
    >,
    pub has_work: ::core::option::Option<unsafe extern "C" fn(cpu: *mut CPUState) -> bool>,
    pub mmu_index: ::core::option::Option<
        unsafe extern "C" fn(cpu: *mut CPUState, ifetch: bool) -> core::ffi::c_int,
    >,
    pub memory_rw_debug: ::core::option::Option<
        unsafe extern "C" fn(
            cpu: *mut CPUState,
            addr: vaddr,
            buf: *mut u8,
            len: core::ffi::c_int,
            is_write: bool,
        ) -> core::ffi::c_int,
    >,
    pub dump_state: ::core::option::Option<
        unsafe extern "C" fn(cpu: *mut CPUState, arg1: *mut FILE, flags: core::ffi::c_int),
    >,
    pub query_cpu_fast:
        ::core::option::Option<unsafe extern "C" fn(cpu: *mut CPUState, value: *mut CpuInfoFast)>,
    pub get_arch_id: ::core::option::Option<unsafe extern "C" fn(cpu: *mut CPUState) -> i64>,
    pub set_pc: ::core::option::Option<unsafe extern "C" fn(cpu: *mut CPUState, value: vaddr)>,
    pub get_pc: ::core::option::Option<unsafe extern "C" fn(cpu: *mut CPUState) -> vaddr>,
    pub gdb_read_register: ::core::option::Option<
        unsafe extern "C" fn(
            cpu: *mut CPUState,
            buf: *mut GByteArray,
            reg: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub gdb_write_register: ::core::option::Option<
        unsafe extern "C" fn(
            cpu: *mut CPUState,
            buf: *mut u8,
            reg: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub gdb_adjust_breakpoint:
        ::core::option::Option<unsafe extern "C" fn(cpu: *mut CPUState, addr: vaddr) -> vaddr>,
    pub gdb_core_xml_file: *const core::ffi::c_char,
    pub gdb_arch_name:
        ::core::option::Option<unsafe extern "C" fn(cpu: *mut CPUState) -> *const gchar>,
    pub disas_set_info: ::core::option::Option<
        unsafe extern "C" fn(cpu: *mut CPUState, info: *mut disassemble_info),
    >,
    pub deprecation_note: *const core::ffi::c_char,
    pub accel_cpu: *mut AccelCPUClass,
    pub sysemu_ops: *const SysemuCPUOps,
    pub tcg_ops: *const TCGCPUOps,
    pub init_accel_cpu: ::core::option::Option<
        unsafe extern "C" fn(accel_cpu: *mut AccelCPUClass, cc: *mut CPUClass),
    >,
    pub reset_dump_flags: core::ffi::c_int,
    pub gdb_num_core_regs: core::ffi::c_int,
    pub gdb_stop_before_watchpoint: bool,
}
#[test]
fn bindgen_test_layout_CPUClass() {
    const UNINIT: ::core::mem::MaybeUninit<CPUClass> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUClass>(),
        360usize,
        concat!("Size of: ", stringify!(CPUClass))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUClass>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class_by_name) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(class_by_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parse_features) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(parse_features)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_work) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(has_work)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mmu_index) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(mmu_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory_rw_debug) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(memory_rw_debug)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dump_state) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(dump_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).query_cpu_fast) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(query_cpu_fast)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_arch_id) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(get_arch_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_pc) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(set_pc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_pc) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(get_pc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gdb_read_register) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(gdb_read_register)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gdb_write_register) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(gdb_write_register)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gdb_adjust_breakpoint) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(gdb_adjust_breakpoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gdb_core_xml_file) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(gdb_core_xml_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gdb_arch_name) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(gdb_arch_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disas_set_info) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(disas_set_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deprecation_note) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(deprecation_note)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accel_cpu) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(accel_cpu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sysemu_ops) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(sysemu_ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcg_ops) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(tcg_ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_accel_cpu) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(init_accel_cpu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset_dump_flags) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(reset_dump_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gdb_num_core_regs) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(gdb_num_core_regs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gdb_stop_before_watchpoint) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUClass),
            "::",
            stringify!(gdb_stop_before_watchpoint)
        )
    );
}
impl Default for CPUClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPUTLBEntryFull {
    pub xlat_section: hwaddr,
    pub phys_addr: hwaddr,
    pub attrs: MemTxAttrs,
    pub prot: u8,
    pub lg_page_size: u8,
    pub tlb_fill_flags: u8,
    pub slow_flags: [u8; 3usize],
    pub extra: CPUTLBEntryFull__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUTLBEntryFull__bindgen_ty_1 {
    pub arm: CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1 {
    pub pte_attrs: u8,
    pub shareability: u8,
    pub guarded: bool,
}
#[test]
fn bindgen_test_layout_CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1>(),
        3usize,
        concat!(
            "Size of: ",
            stringify!(CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pte_attrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(pte_attrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shareability) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(shareability)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).guarded) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(guarded)
        )
    );
}
#[test]
fn bindgen_test_layout_CPUTLBEntryFull__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CPUTLBEntryFull__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUTLBEntryFull__bindgen_ty_1>(),
        3usize,
        concat!("Size of: ", stringify!(CPUTLBEntryFull__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUTLBEntryFull__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(CPUTLBEntryFull__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull__bindgen_ty_1),
            "::",
            stringify!(arm)
        )
    );
}
impl Default for CPUTLBEntryFull__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUTLBEntryFull__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "CPUTLBEntryFull__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_CPUTLBEntryFull() {
    const UNINIT: ::core::mem::MaybeUninit<CPUTLBEntryFull> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUTLBEntryFull>(),
        32usize,
        concat!("Size of: ", stringify!(CPUTLBEntryFull))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUTLBEntryFull>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUTLBEntryFull))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xlat_section) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull),
            "::",
            stringify!(xlat_section)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phys_addr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attrs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull),
            "::",
            stringify!(attrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prot) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull),
            "::",
            stringify!(prot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lg_page_size) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull),
            "::",
            stringify!(lg_page_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tlb_fill_flags) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull),
            "::",
            stringify!(tlb_fill_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slow_flags) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull),
            "::",
            stringify!(slow_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBEntryFull),
            "::",
            stringify!(extra)
        )
    );
}
impl Default for CPUTLBEntryFull {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUTLBEntryFull {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "CPUTLBEntryFull {{ xlat_section: {:?}, phys_addr: {:?}, attrs: {:?}, prot: {:?}, lg_page_size: {:?}, tlb_fill_flags: {:?}, slow_flags: {:?}, extra: {:?} }}" , self . xlat_section , self . phys_addr , self . attrs , self . prot , self . lg_page_size , self . tlb_fill_flags , self . slow_flags , self . extra)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CPUTLBDesc {
    pub large_page_addr: vaddr,
    pub large_page_mask: vaddr,
    pub window_begin_ns: i64,
    pub window_max_entries: usize,
    pub n_used_entries: usize,
    pub vindex: usize,
    pub vtable: [CPUTLBEntry; 8usize],
    pub vfulltlb: [CPUTLBEntryFull; 8usize],
    pub fulltlb: *mut CPUTLBEntryFull,
}
#[test]
fn bindgen_test_layout_CPUTLBDesc() {
    const UNINIT: ::core::mem::MaybeUninit<CPUTLBDesc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUTLBDesc>(),
        568usize,
        concat!("Size of: ", stringify!(CPUTLBDesc))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUTLBDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUTLBDesc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).large_page_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBDesc),
            "::",
            stringify!(large_page_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).large_page_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBDesc),
            "::",
            stringify!(large_page_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window_begin_ns) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBDesc),
            "::",
            stringify!(window_begin_ns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window_max_entries) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBDesc),
            "::",
            stringify!(window_max_entries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_used_entries) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBDesc),
            "::",
            stringify!(n_used_entries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vindex) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBDesc),
            "::",
            stringify!(vindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vtable) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBDesc),
            "::",
            stringify!(vtable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vfulltlb) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBDesc),
            "::",
            stringify!(vfulltlb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fulltlb) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBDesc),
            "::",
            stringify!(fulltlb)
        )
    );
}
impl Default for CPUTLBDesc {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUTLBDesc {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "CPUTLBDesc {{ large_page_addr: {:?}, large_page_mask: {:?}, window_begin_ns: {:?}, window_max_entries: {:?}, n_used_entries: {:?}, vindex: {:?}, vtable: {:?}, vfulltlb: {:?}, fulltlb: {:?} }}" , self . large_page_addr , self . large_page_mask , self . window_begin_ns , self . window_max_entries , self . n_used_entries , self . vindex , self . vtable , self . vfulltlb , self . fulltlb)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CPUTLBCommon {
    pub lock: QemuSpin,
    pub dirty: u16,
    pub full_flush_count: usize,
    pub part_flush_count: usize,
    pub elide_flush_count: usize,
}
#[test]
fn bindgen_test_layout_CPUTLBCommon() {
    const UNINIT: ::core::mem::MaybeUninit<CPUTLBCommon> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUTLBCommon>(),
        32usize,
        concat!("Size of: ", stringify!(CPUTLBCommon))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUTLBCommon>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUTLBCommon))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBCommon),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dirty) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBCommon),
            "::",
            stringify!(dirty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).full_flush_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBCommon),
            "::",
            stringify!(full_flush_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).part_flush_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBCommon),
            "::",
            stringify!(part_flush_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).elide_flush_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTLBCommon),
            "::",
            stringify!(elide_flush_count)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct CPUTLB {
    pub c: CPUTLBCommon,
    pub d: [CPUTLBDesc; 16usize],
    pub f: [CPUTLBDescFast; 16usize],
}
#[test]
fn bindgen_test_layout_CPUTLB() {
    const UNINIT: ::core::mem::MaybeUninit<CPUTLB> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUTLB>(),
        9376usize,
        concat!("Size of: ", stringify!(CPUTLB))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUTLB>(),
        16usize,
        concat!("Alignment of ", stringify!(CPUTLB))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(CPUTLB), "::", stringify!(c))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        32usize,
        concat!("Offset of field: ", stringify!(CPUTLB), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        9120usize,
        concat!("Offset of field: ", stringify!(CPUTLB), "::", stringify!(f))
    );
}
impl Default for CPUTLB {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUTLB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "CPUTLB {{ c: {:?}, d: {:?}, f: {:?} }}",
            self.c, self.d, self.f
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IcountDecr {
    pub u32_: u32,
    pub u16_: IcountDecr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct IcountDecr__bindgen_ty_1 {
    pub low: u16,
    pub high: u16,
}
#[test]
fn bindgen_test_layout_IcountDecr__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<IcountDecr__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IcountDecr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IcountDecr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<IcountDecr__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(IcountDecr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IcountDecr__bindgen_ty_1),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).high) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IcountDecr__bindgen_ty_1),
            "::",
            stringify!(high)
        )
    );
}
#[test]
fn bindgen_test_layout_IcountDecr() {
    const UNINIT: ::core::mem::MaybeUninit<IcountDecr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IcountDecr>(),
        4usize,
        concat!("Size of: ", stringify!(IcountDecr))
    );
    assert_eq!(
        ::core::mem::align_of::<IcountDecr>(),
        4usize,
        concat!("Alignment of ", stringify!(IcountDecr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IcountDecr),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IcountDecr),
            "::",
            stringify!(u16_)
        )
    );
}
impl Default for IcountDecr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for IcountDecr {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "IcountDecr {{ union }}")
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct CPUNegativeOffsetState {
    pub tlb: CPUTLB,
    pub plugin_mem_cbs: *mut GArray,
    pub icount_decr: IcountDecr,
    pub can_do_io: bool,
}
#[test]
fn bindgen_test_layout_CPUNegativeOffsetState() {
    const UNINIT: ::core::mem::MaybeUninit<CPUNegativeOffsetState> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUNegativeOffsetState>(),
        9392usize,
        concat!("Size of: ", stringify!(CPUNegativeOffsetState))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUNegativeOffsetState>(),
        16usize,
        concat!("Alignment of ", stringify!(CPUNegativeOffsetState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tlb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUNegativeOffsetState),
            "::",
            stringify!(tlb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plugin_mem_cbs) as usize - ptr as usize },
        9376usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUNegativeOffsetState),
            "::",
            stringify!(plugin_mem_cbs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icount_decr) as usize - ptr as usize },
        9384usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUNegativeOffsetState),
            "::",
            stringify!(icount_decr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).can_do_io) as usize - ptr as usize },
        9388usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUNegativeOffsetState),
            "::",
            stringify!(can_do_io)
        )
    );
}
impl Default for CPUNegativeOffsetState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUNegativeOffsetState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "CPUNegativeOffsetState {{ tlb: {:?}, plugin_mem_cbs: {:?}, icount_decr: {:?}, can_do_io: {:?} }}" , self . tlb , self . plugin_mem_cbs , self . icount_decr , self . can_do_io)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KVMState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kvm_run {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union run_on_cpu_data {
    pub host_int: core::ffi::c_int,
    pub host_ulong: core::ffi::c_ulong,
    pub host_ptr: *mut core::ffi::c_void,
    pub target_ptr: vaddr,
}
#[test]
fn bindgen_test_layout_run_on_cpu_data() {
    const UNINIT: ::core::mem::MaybeUninit<run_on_cpu_data> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<run_on_cpu_data>(),
        8usize,
        concat!("Size of: ", stringify!(run_on_cpu_data))
    );
    assert_eq!(
        ::core::mem::align_of::<run_on_cpu_data>(),
        8usize,
        concat!("Alignment of ", stringify!(run_on_cpu_data))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(run_on_cpu_data),
            "::",
            stringify!(host_int)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_ulong) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(run_on_cpu_data),
            "::",
            stringify!(host_ulong)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(run_on_cpu_data),
            "::",
            stringify!(host_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(run_on_cpu_data),
            "::",
            stringify!(target_ptr)
        )
    );
}
impl Default for run_on_cpu_data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for run_on_cpu_data {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "run_on_cpu_data {{ union }}")
    }
}
pub type run_on_cpu_func =
    ::core::option::Option<unsafe extern "C" fn(cpu: *mut CPUState, data: run_on_cpu_data)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_work_item {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(16))]
pub struct CPUState {
    pub parent_obj: DeviceState,
    pub cc: *mut CPUClass,
    pub nr_cores: core::ffi::c_int,
    pub nr_threads: core::ffi::c_int,
    pub thread: *mut QemuThread,
    pub thread_id: core::ffi::c_int,
    pub running: bool,
    pub has_waiter: bool,
    pub halt_cond: *mut QemuCond,
    pub thread_kicked: bool,
    pub created: bool,
    pub stop: bool,
    pub stopped: bool,
    pub start_powered_off: bool,
    pub unplug: bool,
    pub crash_occurred: bool,
    pub exit_request: bool,
    pub exclusive_context_count: core::ffi::c_int,
    pub cflags_next_tb: u32,
    pub interrupt_request: u32,
    pub singlestep_enabled: core::ffi::c_int,
    pub icount_budget: i64,
    pub icount_extra: i64,
    pub random_seed: u64,
    pub jmp_env: sigjmp_buf,
    pub work_mutex: QemuMutex,
    pub work_list: CPUState__bindgen_ty_1,
    pub cpu_ases: *mut CPUAddressSpace,
    pub num_ases: core::ffi::c_int,
    pub as_: *mut AddressSpace,
    pub memory: *mut MemoryRegion,
    pub tb_jmp_cache: *mut CPUJumpCache,
    pub gdb_regs: *mut GArray,
    pub gdb_num_regs: core::ffi::c_int,
    pub gdb_num_g_regs: core::ffi::c_int,
    pub node: CPUState__bindgen_ty_2,
    pub breakpoints: CPUState__bindgen_ty_3,
    pub watchpoints: CPUState__bindgen_ty_4,
    pub watchpoint_hit: *mut CPUWatchpoint,
    pub opaque: *mut core::ffi::c_void,
    pub mem_io_pc: usize,
    pub kvm_fd: core::ffi::c_int,
    pub kvm_state: *mut KVMState,
    pub kvm_run: *mut kvm_run,
    pub kvm_dirty_gfns: *mut kvm_dirty_gfn,
    pub kvm_fetch_index: u32,
    pub dirty_pages: u64,
    pub kvm_vcpu_stats_fd: core::ffi::c_int,
    pub vcpu_dirty: bool,
    pub in_ioctl_lock: QemuLockCnt,
    pub plugin_state: *mut CPUPluginState,
    pub cpu_index: core::ffi::c_int,
    pub cluster_index: core::ffi::c_int,
    pub tcg_cflags: u32,
    pub halted: u32,
    pub exception_index: i32,
    pub accel: *mut AccelCPUState,
    pub throttle_thread_scheduled: bool,
    pub throttle_us_per_full: i64,
    pub ignore_memory_transaction_failures: bool,
    pub prctl_unalign_sigbus: bool,
    pub iommu_notifiers: *mut GArray,
    pub neg_align: __IncompleteArrayField<core::ffi::c_char>,
    pub neg: CPUNegativeOffsetState,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPUState__bindgen_ty_1 {
    pub sqh_first: *mut qemu_work_item,
    pub sqh_last: *mut *mut qemu_work_item,
}
#[test]
fn bindgen_test_layout_CPUState__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<CPUState__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUState__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(CPUState__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUState__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUState__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState__bindgen_ty_1),
            "::",
            stringify!(sqh_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState__bindgen_ty_1),
            "::",
            stringify!(sqh_last)
        )
    );
}
impl Default for CPUState__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUState__bindgen_ty_2 {
    pub tqe_next: *mut CPUState,
    pub tqe_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_CPUState__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<CPUState__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUState__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(CPUState__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUState__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUState__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState__bindgen_ty_2),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState__bindgen_ty_2),
            "::",
            stringify!(tqe_circ)
        )
    );
}
impl Default for CPUState__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUState__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "CPUState__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUState__bindgen_ty_3 {
    pub tqh_first: *mut CPUBreakpoint,
    pub tqh_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_CPUState__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<CPUState__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUState__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(CPUState__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUState__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUState__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState__bindgen_ty_3),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState__bindgen_ty_3),
            "::",
            stringify!(tqh_circ)
        )
    );
}
impl Default for CPUState__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUState__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "CPUState__bindgen_ty_3 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUState__bindgen_ty_4 {
    pub tqh_first: *mut CPUWatchpoint,
    pub tqh_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_CPUState__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<CPUState__bindgen_ty_4> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUState__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(CPUState__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUState__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUState__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState__bindgen_ty_4),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState__bindgen_ty_4),
            "::",
            stringify!(tqh_circ)
        )
    );
}
impl Default for CPUState__bindgen_ty_4 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUState__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "CPUState__bindgen_ty_4 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_CPUState() {
    const UNINIT: ::core::mem::MaybeUninit<CPUState> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUState>(),
        10176usize,
        concat!("Size of: ", stringify!(CPUState))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUState>(),
        16usize,
        concat!("Alignment of ", stringify!(CPUState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(parent_obj)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cc) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(cc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nr_cores) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(nr_cores)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nr_threads) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(nr_threads)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(thread_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).running) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(running)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_waiter) as usize - ptr as usize },
        189usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(has_waiter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halt_cond) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(halt_cond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_kicked) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(thread_kicked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).created) as usize - ptr as usize },
        201usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(created)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        202usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stopped) as usize - ptr as usize },
        203usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(stopped)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_powered_off) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(start_powered_off)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unplug) as usize - ptr as usize },
        205usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(unplug)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crash_occurred) as usize - ptr as usize },
        206usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(crash_occurred)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exit_request) as usize - ptr as usize },
        207usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(exit_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exclusive_context_count) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(exclusive_context_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cflags_next_tb) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(cflags_next_tb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interrupt_request) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(interrupt_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).singlestep_enabled) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(singlestep_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icount_budget) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(icount_budget)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icount_extra) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(icount_extra)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).random_seed) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(random_seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jmp_env) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(jmp_env)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_mutex) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(work_mutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_list) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(work_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_ases) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(cpu_ases)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_ases) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(num_ases)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).as_) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(as_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tb_jmp_cache) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(tb_jmp_cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gdb_regs) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(gdb_regs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gdb_num_regs) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(gdb_num_regs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gdb_num_g_regs) as usize - ptr as usize },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(gdb_num_g_regs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).breakpoints) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(breakpoints)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).watchpoints) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(watchpoints)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).watchpoint_hit) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(watchpoint_hit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem_io_pc) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(mem_io_pc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kvm_fd) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(kvm_fd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kvm_state) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(kvm_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kvm_run) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(kvm_run)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kvm_dirty_gfns) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(kvm_dirty_gfns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kvm_fetch_index) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(kvm_fetch_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dirty_pages) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(dirty_pages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kvm_vcpu_stats_fd) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(kvm_vcpu_stats_fd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vcpu_dirty) as usize - ptr as usize },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(vcpu_dirty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_ioctl_lock) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(in_ioctl_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plugin_state) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(plugin_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpu_index) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(cpu_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cluster_index) as usize - ptr as usize },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(cluster_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcg_cflags) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(tcg_cflags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).halted) as usize - ptr as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(halted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exception_index) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(exception_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accel) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(accel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).throttle_thread_scheduled) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(throttle_thread_scheduled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).throttle_us_per_full) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(throttle_us_per_full)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ignore_memory_transaction_failures) as usize - ptr as usize
        },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(ignore_memory_transaction_failures)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prctl_unalign_sigbus) as usize - ptr as usize },
        769usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(prctl_unalign_sigbus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iommu_notifiers) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(iommu_notifiers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).neg_align) as usize - ptr as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(neg_align)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).neg) as usize - ptr as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUState),
            "::",
            stringify!(neg)
        )
    );
}
impl Default for CPUState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "CPUState {{ parent_obj: {:?}, cc: {:?}, nr_cores: {:?}, nr_threads: {:?}, thread: {:?}, thread_id: {:?}, running: {:?}, has_waiter: {:?}, halt_cond: {:?}, thread_kicked: {:?}, created: {:?}, stop: {:?}, stopped: {:?}, start_powered_off: {:?}, unplug: {:?}, crash_occurred: {:?}, exit_request: {:?}, exclusive_context_count: {:?}, cflags_next_tb: {:?}, interrupt_request: {:?}, singlestep_enabled: {:?}, icount_budget: {:?}, icount_extra: {:?}, random_seed: {:?}, jmp_env: {:?}, work_mutex: {:?}, work_list: {:?}, cpu_ases: {:?}, num_ases: {:?}, as: {:?}, memory: {:?}, tb_jmp_cache: {:?}, gdb_regs: {:?}, gdb_num_regs: {:?}, gdb_num_g_regs: {:?}, node: {:?}, breakpoints: {:?}, watchpoints: {:?}, watchpoint_hit: {:?}, opaque: {:?}, kvm_fd: {:?}, kvm_state: {:?}, kvm_run: {:?}, kvm_dirty_gfns: {:?}, kvm_fetch_index: {:?}, dirty_pages: {:?}, kvm_vcpu_stats_fd: {:?}, vcpu_dirty: {:?}, in_ioctl_lock: {:?}, plugin_state: {:?}, cpu_index: {:?}, cluster_index: {:?}, tcg_cflags: {:?}, halted: {:?}, exception_index: {:?}, accel: {:?}, throttle_thread_scheduled: {:?}, throttle_us_per_full: {:?}, ignore_memory_transaction_failures: {:?}, prctl_unalign_sigbus: {:?}, iommu_notifiers: {:?}, neg_align: {:?}, neg: {:?} }}" , self . parent_obj , self . cc , self . nr_cores , self . nr_threads , self . thread , self . thread_id , self . running , self . has_waiter , self . halt_cond , self . thread_kicked , self . created , self . stop , self . stopped , self . start_powered_off , self . unplug , self . crash_occurred , self . exit_request , self . exclusive_context_count , self . cflags_next_tb , self . interrupt_request , self . singlestep_enabled , self . icount_budget , self . icount_extra , self . random_seed , self . jmp_env , self . work_mutex , self . work_list , self . cpu_ases , self . num_ases , self . as_ , self . memory , self . tb_jmp_cache , self . gdb_regs , self . gdb_num_regs , self . gdb_num_g_regs , self . node , self . breakpoints , self . watchpoints , self . watchpoint_hit , self . opaque , self . kvm_fd , self . kvm_state , self . kvm_run , self . kvm_dirty_gfns , self . kvm_fetch_index , self . dirty_pages , self . kvm_vcpu_stats_fd , self . vcpu_dirty , self . in_ioctl_lock , self . plugin_state , self . cpu_index , self . cluster_index , self . tcg_cflags , self . halted , self . exception_index , self . accel , self . throttle_thread_scheduled , self . throttle_us_per_full , self . ignore_memory_transaction_failures , self . prctl_unalign_sigbus , self . iommu_notifiers , self . neg_align , self . neg)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CPUTailQ {
    pub tqh_first: *mut CPUState,
    pub tqh_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_CPUTailQ() {
    const UNINIT: ::core::mem::MaybeUninit<CPUTailQ> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CPUTailQ>(),
        16usize,
        concat!("Size of: ", stringify!(CPUTailQ))
    );
    assert_eq!(
        ::core::mem::align_of::<CPUTailQ>(),
        8usize,
        concat!("Alignment of ", stringify!(CPUTailQ))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTailQ),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPUTailQ),
            "::",
            stringify!(tqh_circ)
        )
    );
}
impl Default for CPUTailQ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for CPUTailQ {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "CPUTailQ {{ union }}")
    }
}
pub const CPUDumpFlags_CPU_DUMP_CODE: CPUDumpFlags = 65536;
pub const CPUDumpFlags_CPU_DUMP_FPU: CPUDumpFlags = 131072;
pub const CPUDumpFlags_CPU_DUMP_CCOP: CPUDumpFlags = 262144;
pub const CPUDumpFlags_CPU_DUMP_VPU: CPUDumpFlags = 524288;
pub type CPUDumpFlags = core::ffi::c_uint;
pub const device_endian_DEVICE_NATIVE_ENDIAN: device_endian = 0;
pub const device_endian_DEVICE_BIG_ENDIAN: device_endian = 1;
pub const device_endian_DEVICE_LITTLE_ENDIAN: device_endian = 2;
pub type device_endian = core::ffi::c_uint;
pub type ram_addr_t = u64;
pub type RAMBlockIterFunc = ::core::option::Option<
    unsafe extern "C" fn(rb: *mut RAMBlock, opaque: *mut core::ffi::c_void) -> core::ffi::c_int,
>;
pub const MemOp_MO_8: MemOp = 0;
pub const MemOp_MO_16: MemOp = 1;
pub const MemOp_MO_32: MemOp = 2;
pub const MemOp_MO_64: MemOp = 3;
pub const MemOp_MO_128: MemOp = 4;
pub const MemOp_MO_256: MemOp = 5;
pub const MemOp_MO_512: MemOp = 6;
pub const MemOp_MO_1024: MemOp = 7;
pub const MemOp_MO_SIZE: MemOp = 7;
pub const MemOp_MO_SIGN: MemOp = 8;
pub const MemOp_MO_BSWAP: MemOp = 16;
pub const MemOp_MO_LE: MemOp = 0;
pub const MemOp_MO_BE: MemOp = 16;
pub const MemOp_MO_TE: MemOp = 0;
pub const MemOp_MO_ASHIFT: MemOp = 5;
pub const MemOp_MO_AMASK: MemOp = 224;
pub const MemOp_MO_UNALN: MemOp = 0;
pub const MemOp_MO_ALIGN_2: MemOp = 32;
pub const MemOp_MO_ALIGN_4: MemOp = 64;
pub const MemOp_MO_ALIGN_8: MemOp = 96;
pub const MemOp_MO_ALIGN_16: MemOp = 128;
pub const MemOp_MO_ALIGN_32: MemOp = 160;
pub const MemOp_MO_ALIGN_64: MemOp = 192;
pub const MemOp_MO_ALIGN: MemOp = 224;
pub const MemOp_MO_ATOM_SHIFT: MemOp = 8;
pub const MemOp_MO_ATOM_IFALIGN: MemOp = 0;
pub const MemOp_MO_ATOM_IFALIGN_PAIR: MemOp = 256;
pub const MemOp_MO_ATOM_WITHIN16: MemOp = 512;
pub const MemOp_MO_ATOM_WITHIN16_PAIR: MemOp = 768;
pub const MemOp_MO_ATOM_SUBALIGN: MemOp = 1024;
pub const MemOp_MO_ATOM_NONE: MemOp = 1280;
pub const MemOp_MO_ATOM_MASK: MemOp = 1792;
pub const MemOp_MO_UB: MemOp = 0;
pub const MemOp_MO_UW: MemOp = 1;
pub const MemOp_MO_UL: MemOp = 2;
pub const MemOp_MO_UQ: MemOp = 3;
pub const MemOp_MO_UO: MemOp = 4;
pub const MemOp_MO_SB: MemOp = 8;
pub const MemOp_MO_SW: MemOp = 9;
pub const MemOp_MO_SL: MemOp = 10;
pub const MemOp_MO_SQ: MemOp = 11;
pub const MemOp_MO_SO: MemOp = 12;
pub const MemOp_MO_LEUW: MemOp = 1;
pub const MemOp_MO_LEUL: MemOp = 2;
pub const MemOp_MO_LEUQ: MemOp = 3;
pub const MemOp_MO_LESW: MemOp = 9;
pub const MemOp_MO_LESL: MemOp = 10;
pub const MemOp_MO_LESQ: MemOp = 11;
pub const MemOp_MO_BEUW: MemOp = 17;
pub const MemOp_MO_BEUL: MemOp = 18;
pub const MemOp_MO_BEUQ: MemOp = 19;
pub const MemOp_MO_BESW: MemOp = 25;
pub const MemOp_MO_BESL: MemOp = 26;
pub const MemOp_MO_BESQ: MemOp = 27;
pub const MemOp_MO_TEUW: MemOp = 1;
pub const MemOp_MO_TEUL: MemOp = 2;
pub const MemOp_MO_TEUQ: MemOp = 3;
pub const MemOp_MO_TEUO: MemOp = 4;
pub const MemOp_MO_TESW: MemOp = 9;
pub const MemOp_MO_TESL: MemOp = 10;
pub const MemOp_MO_TESQ: MemOp = 11;
pub const MemOp_MO_SSIZE: MemOp = 15;
pub type MemOp = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct DirtyMemoryBlocks {
    pub rcu: rcu_head,
    pub blocks: __IncompleteArrayField<*mut core::ffi::c_ulong>,
}
#[test]
fn bindgen_test_layout_DirtyMemoryBlocks() {
    const UNINIT: ::core::mem::MaybeUninit<DirtyMemoryBlocks> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DirtyMemoryBlocks>(),
        16usize,
        concat!("Size of: ", stringify!(DirtyMemoryBlocks))
    );
    assert_eq!(
        ::core::mem::align_of::<DirtyMemoryBlocks>(),
        8usize,
        concat!("Alignment of ", stringify!(DirtyMemoryBlocks))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DirtyMemoryBlocks),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blocks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DirtyMemoryBlocks),
            "::",
            stringify!(blocks)
        )
    );
}
impl Default for DirtyMemoryBlocks {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RAMList {
    pub mutex: QemuMutex,
    pub mru_block: *mut RAMBlock,
    pub blocks: RAMList__bindgen_ty_1,
    pub dirty_memory: [*mut DirtyMemoryBlocks; 3usize],
    pub version: u32,
    pub ramblock_notifiers: RAMList__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RAMList__bindgen_ty_1 {
    pub lh_first: *mut RAMBlock,
}
#[test]
fn bindgen_test_layout_RAMList__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<RAMList__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RAMList__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(RAMList__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RAMList__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(RAMList__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMList__bindgen_ty_1),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for RAMList__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RAMList__bindgen_ty_2 {
    pub lh_first: *mut RAMBlockNotifier,
}
#[test]
fn bindgen_test_layout_RAMList__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<RAMList__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RAMList__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(RAMList__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<RAMList__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(RAMList__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMList__bindgen_ty_2),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for RAMList__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_RAMList() {
    const UNINIT: ::core::mem::MaybeUninit<RAMList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RAMList>(),
        112usize,
        concat!("Size of: ", stringify!(RAMList))
    );
    assert_eq!(
        ::core::mem::align_of::<RAMList>(),
        8usize,
        concat!("Alignment of ", stringify!(RAMList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMList),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mru_block) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMList),
            "::",
            stringify!(mru_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blocks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMList),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dirty_memory) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMList),
            "::",
            stringify!(dirty_memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMList),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ramblock_notifiers) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMList),
            "::",
            stringify!(ramblock_notifiers)
        )
    );
}
impl Default for RAMList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for RAMList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "RAMList {{ mutex: {:?}, mru_block: {:?}, blocks: {:?}, dirty_memory: {:?}, version: {:?}, ramblock_notifiers: {:?} }}" , self . mutex , self . mru_block , self . blocks , self . dirty_memory , self . version , self . ramblock_notifiers)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RAMBlockNotifier {
    pub ram_block_added: ::core::option::Option<
        unsafe extern "C" fn(
            n: *mut RAMBlockNotifier,
            host: *mut core::ffi::c_void,
            size: usize,
            max_size: usize,
        ),
    >,
    pub ram_block_removed: ::core::option::Option<
        unsafe extern "C" fn(
            n: *mut RAMBlockNotifier,
            host: *mut core::ffi::c_void,
            size: usize,
            max_size: usize,
        ),
    >,
    pub ram_block_resized: ::core::option::Option<
        unsafe extern "C" fn(
            n: *mut RAMBlockNotifier,
            host: *mut core::ffi::c_void,
            old_size: usize,
            new_size: usize,
        ),
    >,
    pub next: RAMBlockNotifier__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RAMBlockNotifier__bindgen_ty_1 {
    pub le_next: *mut RAMBlockNotifier,
    pub le_prev: *mut *mut RAMBlockNotifier,
}
#[test]
fn bindgen_test_layout_RAMBlockNotifier__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<RAMBlockNotifier__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RAMBlockNotifier__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(RAMBlockNotifier__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RAMBlockNotifier__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(RAMBlockNotifier__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMBlockNotifier__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMBlockNotifier__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
impl Default for RAMBlockNotifier__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_RAMBlockNotifier() {
    const UNINIT: ::core::mem::MaybeUninit<RAMBlockNotifier> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RAMBlockNotifier>(),
        40usize,
        concat!("Size of: ", stringify!(RAMBlockNotifier))
    );
    assert_eq!(
        ::core::mem::align_of::<RAMBlockNotifier>(),
        8usize,
        concat!("Alignment of ", stringify!(RAMBlockNotifier))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ram_block_added) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMBlockNotifier),
            "::",
            stringify!(ram_block_added)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ram_block_removed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMBlockNotifier),
            "::",
            stringify!(ram_block_removed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ram_block_resized) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMBlockNotifier),
            "::",
            stringify!(ram_block_resized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RAMBlockNotifier),
            "::",
            stringify!(next)
        )
    );
}
impl Default for RAMBlockNotifier {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Range {
    pub lob: u64,
    pub upb: u64,
}
#[test]
fn bindgen_test_layout_Range() {
    const UNINIT: ::core::mem::MaybeUninit<Range> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Range>(),
        16usize,
        concat!("Size of: ", stringify!(Range))
    );
    assert_eq!(
        ::core::mem::align_of::<Range>(),
        8usize,
        concat!("Alignment of ", stringify!(Range))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lob) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Range),
            "::",
            stringify!(lob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).upb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Range),
            "::",
            stringify!(upb)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RamDiscardManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ReservedRegion {
    pub range: Range,
    pub type_: core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_ReservedRegion() {
    const UNINIT: ::core::mem::MaybeUninit<ReservedRegion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ReservedRegion>(),
        24usize,
        concat!("Size of: ", stringify!(ReservedRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<ReservedRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(ReservedRegion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ReservedRegion),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ReservedRegion),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionSection {
    pub size: Int128,
    pub mr: *mut MemoryRegion,
    pub fv: *mut FlatView,
    pub offset_within_region: hwaddr,
    pub offset_within_address_space: hwaddr,
    pub readonly: bool,
    pub nonvolatile: bool,
    pub unmergeable: bool,
}
#[test]
fn bindgen_test_layout_MemoryRegionSection() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryRegionSection> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryRegionSection>(),
        64usize,
        concat!("Size of: ", stringify!(MemoryRegionSection))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryRegionSection>(),
        16usize,
        concat!("Alignment of ", stringify!(MemoryRegionSection))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionSection),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionSection),
            "::",
            stringify!(mr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fv) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionSection),
            "::",
            stringify!(fv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset_within_region) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionSection),
            "::",
            stringify!(offset_within_region)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).offset_within_address_space) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionSection),
            "::",
            stringify!(offset_within_address_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readonly) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionSection),
            "::",
            stringify!(readonly)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nonvolatile) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionSection),
            "::",
            stringify!(nonvolatile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unmergeable) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionSection),
            "::",
            stringify!(unmergeable)
        )
    );
}
impl Default for MemoryRegionSection {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const IOMMUAccessFlags_IOMMU_NONE: IOMMUAccessFlags = 0;
pub const IOMMUAccessFlags_IOMMU_RO: IOMMUAccessFlags = 1;
pub const IOMMUAccessFlags_IOMMU_WO: IOMMUAccessFlags = 2;
pub const IOMMUAccessFlags_IOMMU_RW: IOMMUAccessFlags = 3;
pub type IOMMUAccessFlags = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUTLBEntry {
    pub target_as: *mut AddressSpace,
    pub iova: hwaddr,
    pub translated_addr: hwaddr,
    pub addr_mask: hwaddr,
    pub perm: IOMMUAccessFlags,
}
#[test]
fn bindgen_test_layout_IOMMUTLBEntry() {
    const UNINIT: ::core::mem::MaybeUninit<IOMMUTLBEntry> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IOMMUTLBEntry>(),
        40usize,
        concat!("Size of: ", stringify!(IOMMUTLBEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<IOMMUTLBEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(IOMMUTLBEntry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target_as) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUTLBEntry),
            "::",
            stringify!(target_as)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iova) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUTLBEntry),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).translated_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUTLBEntry),
            "::",
            stringify!(translated_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_mask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUTLBEntry),
            "::",
            stringify!(addr_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).perm) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUTLBEntry),
            "::",
            stringify!(perm)
        )
    );
}
impl Default for IOMMUTLBEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const IOMMUNotifierFlag_IOMMU_NOTIFIER_NONE: IOMMUNotifierFlag = 0;
pub const IOMMUNotifierFlag_IOMMU_NOTIFIER_UNMAP: IOMMUNotifierFlag = 1;
pub const IOMMUNotifierFlag_IOMMU_NOTIFIER_MAP: IOMMUNotifierFlag = 2;
pub const IOMMUNotifierFlag_IOMMU_NOTIFIER_DEVIOTLB_UNMAP: IOMMUNotifierFlag = 4;
pub type IOMMUNotifierFlag = core::ffi::c_uint;
pub type IOMMUNotify = ::core::option::Option<
    unsafe extern "C" fn(notifier: *mut IOMMUNotifier, data: *mut IOMMUTLBEntry),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUNotifier {
    pub notify: IOMMUNotify,
    pub notifier_flags: IOMMUNotifierFlag,
    pub start: hwaddr,
    pub end: hwaddr,
    pub iommu_idx: core::ffi::c_int,
    pub node: IOMMUNotifier__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUNotifier__bindgen_ty_1 {
    pub le_next: *mut IOMMUNotifier,
    pub le_prev: *mut *mut IOMMUNotifier,
}
#[test]
fn bindgen_test_layout_IOMMUNotifier__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<IOMMUNotifier__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IOMMUNotifier__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(IOMMUNotifier__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<IOMMUNotifier__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(IOMMUNotifier__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUNotifier__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUNotifier__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
impl Default for IOMMUNotifier__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_IOMMUNotifier() {
    const UNINIT: ::core::mem::MaybeUninit<IOMMUNotifier> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IOMMUNotifier>(),
        56usize,
        concat!("Size of: ", stringify!(IOMMUNotifier))
    );
    assert_eq!(
        ::core::mem::align_of::<IOMMUNotifier>(),
        8usize,
        concat!("Alignment of ", stringify!(IOMMUNotifier))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUNotifier),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notifier_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUNotifier),
            "::",
            stringify!(notifier_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUNotifier),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUNotifier),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iommu_idx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUNotifier),
            "::",
            stringify!(iommu_idx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUNotifier),
            "::",
            stringify!(node)
        )
    );
}
impl Default for IOMMUNotifier {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUTLBEvent {
    pub type_: IOMMUNotifierFlag,
    pub entry: IOMMUTLBEntry,
}
#[test]
fn bindgen_test_layout_IOMMUTLBEvent() {
    const UNINIT: ::core::mem::MaybeUninit<IOMMUTLBEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IOMMUTLBEvent>(),
        48usize,
        concat!("Size of: ", stringify!(IOMMUTLBEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<IOMMUTLBEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(IOMMUTLBEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUTLBEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUTLBEvent),
            "::",
            stringify!(entry)
        )
    );
}
impl Default for IOMMUTLBEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionOps {
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            opaque: *mut core::ffi::c_void,
            addr: hwaddr,
            size: core::ffi::c_uint,
        ) -> u64,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            opaque: *mut core::ffi::c_void,
            addr: hwaddr,
            data: u64,
            size: core::ffi::c_uint,
        ),
    >,
    pub read_with_attrs: ::core::option::Option<
        unsafe extern "C" fn(
            opaque: *mut core::ffi::c_void,
            addr: hwaddr,
            data: *mut u64,
            size: core::ffi::c_uint,
            attrs: MemTxAttrs,
        ) -> MemTxResult,
    >,
    pub write_with_attrs: ::core::option::Option<
        unsafe extern "C" fn(
            opaque: *mut core::ffi::c_void,
            addr: hwaddr,
            data: u64,
            size: core::ffi::c_uint,
            attrs: MemTxAttrs,
        ) -> MemTxResult,
    >,
    pub endianness: device_endian,
    pub valid: MemoryRegionOps__bindgen_ty_1,
    pub impl_: MemoryRegionOps__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoryRegionOps__bindgen_ty_1 {
    pub min_access_size: core::ffi::c_uint,
    pub max_access_size: core::ffi::c_uint,
    pub unaligned: bool,
    pub accepts: ::core::option::Option<
        unsafe extern "C" fn(
            opaque: *mut core::ffi::c_void,
            addr: hwaddr,
            size: core::ffi::c_uint,
            is_write: bool,
            attrs: MemTxAttrs,
        ) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_MemoryRegionOps__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryRegionOps__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryRegionOps__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(MemoryRegionOps__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryRegionOps__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryRegionOps__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_access_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps__bindgen_ty_1),
            "::",
            stringify!(min_access_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_access_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps__bindgen_ty_1),
            "::",
            stringify!(max_access_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unaligned) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps__bindgen_ty_1),
            "::",
            stringify!(unaligned)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accepts) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps__bindgen_ty_1),
            "::",
            stringify!(accepts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemoryRegionOps__bindgen_ty_2 {
    pub min_access_size: core::ffi::c_uint,
    pub max_access_size: core::ffi::c_uint,
    pub unaligned: bool,
}
#[test]
fn bindgen_test_layout_MemoryRegionOps__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryRegionOps__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryRegionOps__bindgen_ty_2>(),
        12usize,
        concat!("Size of: ", stringify!(MemoryRegionOps__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryRegionOps__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(MemoryRegionOps__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_access_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps__bindgen_ty_2),
            "::",
            stringify!(min_access_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_access_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps__bindgen_ty_2),
            "::",
            stringify!(max_access_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unaligned) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps__bindgen_ty_2),
            "::",
            stringify!(unaligned)
        )
    );
}
#[test]
fn bindgen_test_layout_MemoryRegionOps() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryRegionOps> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryRegionOps>(),
        80usize,
        concat!("Size of: ", stringify!(MemoryRegionOps))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryRegionOps>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryRegionOps))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_with_attrs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps),
            "::",
            stringify!(read_with_attrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_with_attrs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps),
            "::",
            stringify!(write_with_attrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).endianness) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps),
            "::",
            stringify!(endianness)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).impl_) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionOps),
            "::",
            stringify!(impl_)
        )
    );
}
impl Default for MemoryRegionOps {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionClass {
    pub parent_class: ObjectClass,
}
#[test]
fn bindgen_test_layout_MemoryRegionClass() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryRegionClass> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryRegionClass>(),
        96usize,
        concat!("Size of: ", stringify!(MemoryRegionClass))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryRegionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryRegionClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
impl Default for MemoryRegionClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const IOMMUMemoryRegionAttr_IOMMU_ATTR_SPAPR_TCE_FD: IOMMUMemoryRegionAttr = 0;
pub type IOMMUMemoryRegionAttr = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUMemoryRegionClass {
    pub parent_class: MemoryRegionClass,
    pub translate: ::core::option::Option<
        unsafe extern "C" fn(
            iommu: *mut IOMMUMemoryRegion,
            addr: hwaddr,
            flag: IOMMUAccessFlags,
            iommu_idx: core::ffi::c_int,
        ) -> IOMMUTLBEntry,
    >,
    pub get_min_page_size:
        ::core::option::Option<unsafe extern "C" fn(iommu: *mut IOMMUMemoryRegion) -> u64>,
    pub notify_flag_changed: ::core::option::Option<
        unsafe extern "C" fn(
            iommu: *mut IOMMUMemoryRegion,
            old_flags: IOMMUNotifierFlag,
            new_flags: IOMMUNotifierFlag,
            errp: *mut *mut Error,
        ) -> core::ffi::c_int,
    >,
    pub replay: ::core::option::Option<
        unsafe extern "C" fn(iommu: *mut IOMMUMemoryRegion, notifier: *mut IOMMUNotifier),
    >,
    pub get_attr: ::core::option::Option<
        unsafe extern "C" fn(
            iommu: *mut IOMMUMemoryRegion,
            attr: IOMMUMemoryRegionAttr,
            data: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub attrs_to_index: ::core::option::Option<
        unsafe extern "C" fn(iommu: *mut IOMMUMemoryRegion, attrs: MemTxAttrs) -> core::ffi::c_int,
    >,
    pub num_indexes: ::core::option::Option<
        unsafe extern "C" fn(iommu: *mut IOMMUMemoryRegion) -> core::ffi::c_int,
    >,
    pub iommu_set_page_size_mask: ::core::option::Option<
        unsafe extern "C" fn(
            iommu: *mut IOMMUMemoryRegion,
            page_size_mask: u64,
            errp: *mut *mut Error,
        ) -> core::ffi::c_int,
    >,
    pub iommu_set_iova_ranges: ::core::option::Option<
        unsafe extern "C" fn(
            iommu: *mut IOMMUMemoryRegion,
            iova_ranges: *mut GList,
            errp: *mut *mut Error,
        ) -> core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout_IOMMUMemoryRegionClass() {
    const UNINIT: ::core::mem::MaybeUninit<IOMMUMemoryRegionClass> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IOMMUMemoryRegionClass>(),
        168usize,
        concat!("Size of: ", stringify!(IOMMUMemoryRegionClass))
    );
    assert_eq!(
        ::core::mem::align_of::<IOMMUMemoryRegionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(IOMMUMemoryRegionClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).translate) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegionClass),
            "::",
            stringify!(translate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_min_page_size) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegionClass),
            "::",
            stringify!(get_min_page_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify_flag_changed) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegionClass),
            "::",
            stringify!(notify_flag_changed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).replay) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegionClass),
            "::",
            stringify!(replay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_attr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegionClass),
            "::",
            stringify!(get_attr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attrs_to_index) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegionClass),
            "::",
            stringify!(attrs_to_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_indexes) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegionClass),
            "::",
            stringify!(num_indexes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iommu_set_page_size_mask) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegionClass),
            "::",
            stringify!(iommu_set_page_size_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iommu_set_iova_ranges) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegionClass),
            "::",
            stringify!(iommu_set_iova_ranges)
        )
    );
}
impl Default for IOMMUMemoryRegionClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type NotifyRamPopulate = ::core::option::Option<
    unsafe extern "C" fn(
        rdl: *mut RamDiscardListener,
        section: *mut MemoryRegionSection,
    ) -> core::ffi::c_int,
>;
pub type NotifyRamDiscard = ::core::option::Option<
    unsafe extern "C" fn(rdl: *mut RamDiscardListener, section: *mut MemoryRegionSection),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RamDiscardListener {
    pub notify_populate: NotifyRamPopulate,
    pub notify_discard: NotifyRamDiscard,
    pub double_discard_supported: bool,
    pub section: *mut MemoryRegionSection,
    pub next: RamDiscardListener__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RamDiscardListener__bindgen_ty_1 {
    pub le_next: *mut RamDiscardListener,
    pub le_prev: *mut *mut RamDiscardListener,
}
#[test]
fn bindgen_test_layout_RamDiscardListener__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<RamDiscardListener__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RamDiscardListener__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(RamDiscardListener__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RamDiscardListener__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RamDiscardListener__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardListener__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardListener__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
impl Default for RamDiscardListener__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_RamDiscardListener() {
    const UNINIT: ::core::mem::MaybeUninit<RamDiscardListener> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RamDiscardListener>(),
        48usize,
        concat!("Size of: ", stringify!(RamDiscardListener))
    );
    assert_eq!(
        ::core::mem::align_of::<RamDiscardListener>(),
        8usize,
        concat!("Alignment of ", stringify!(RamDiscardListener))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify_populate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardListener),
            "::",
            stringify!(notify_populate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify_discard) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardListener),
            "::",
            stringify!(notify_discard)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).double_discard_supported) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardListener),
            "::",
            stringify!(double_discard_supported)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).section) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardListener),
            "::",
            stringify!(section)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardListener),
            "::",
            stringify!(next)
        )
    );
}
impl Default for RamDiscardListener {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ReplayRamPopulate = ::core::option::Option<
    unsafe extern "C" fn(
        section: *mut MemoryRegionSection,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
pub type ReplayRamDiscard = ::core::option::Option<
    unsafe extern "C" fn(section: *mut MemoryRegionSection, opaque: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RamDiscardManagerClass {
    pub parent_class: InterfaceClass,
    pub get_min_granularity: ::core::option::Option<
        unsafe extern "C" fn(rdm: *const RamDiscardManager, mr: *const MemoryRegion) -> u64,
    >,
    pub is_populated: ::core::option::Option<
        unsafe extern "C" fn(
            rdm: *const RamDiscardManager,
            section: *const MemoryRegionSection,
        ) -> bool,
    >,
    pub replay_populated: ::core::option::Option<
        unsafe extern "C" fn(
            rdm: *const RamDiscardManager,
            section: *mut MemoryRegionSection,
            replay_fn: ReplayRamPopulate,
            opaque: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub replay_discarded: ::core::option::Option<
        unsafe extern "C" fn(
            rdm: *const RamDiscardManager,
            section: *mut MemoryRegionSection,
            replay_fn: ReplayRamDiscard,
            opaque: *mut core::ffi::c_void,
        ),
    >,
    pub register_listener: ::core::option::Option<
        unsafe extern "C" fn(
            rdm: *mut RamDiscardManager,
            rdl: *mut RamDiscardListener,
            section: *mut MemoryRegionSection,
        ),
    >,
    pub unregister_listener: ::core::option::Option<
        unsafe extern "C" fn(rdm: *mut RamDiscardManager, rdl: *mut RamDiscardListener),
    >,
}
#[test]
fn bindgen_test_layout_RamDiscardManagerClass() {
    const UNINIT: ::core::mem::MaybeUninit<RamDiscardManagerClass> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RamDiscardManagerClass>(),
        160usize,
        concat!("Size of: ", stringify!(RamDiscardManagerClass))
    );
    assert_eq!(
        ::core::mem::align_of::<RamDiscardManagerClass>(),
        8usize,
        concat!("Alignment of ", stringify!(RamDiscardManagerClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardManagerClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_min_granularity) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardManagerClass),
            "::",
            stringify!(get_min_granularity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_populated) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardManagerClass),
            "::",
            stringify!(is_populated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).replay_populated) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardManagerClass),
            "::",
            stringify!(replay_populated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).replay_discarded) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardManagerClass),
            "::",
            stringify!(replay_discarded)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).register_listener) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardManagerClass),
            "::",
            stringify!(register_listener)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unregister_listener) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(RamDiscardManagerClass),
            "::",
            stringify!(unregister_listener)
        )
    );
}
impl Default for RamDiscardManagerClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoalescedMemoryRange {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionIoeventfd {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct MemoryRegion {
    pub parent_obj: Object,
    pub romd_mode: bool,
    pub ram: bool,
    pub subpage: bool,
    pub readonly: bool,
    pub nonvolatile: bool,
    pub rom_device: bool,
    pub flush_coalesced_mmio: bool,
    pub unmergeable: bool,
    pub dirty_log_mask: u8,
    pub is_iommu: bool,
    pub ram_block: *mut RAMBlock,
    pub owner: *mut Object,
    pub dev: *mut DeviceState,
    pub ops: *const MemoryRegionOps,
    pub opaque: *mut core::ffi::c_void,
    pub container: *mut MemoryRegion,
    pub mapped_via_alias: core::ffi::c_int,
    pub __bindgen_padding_0: [u64; 0usize],
    pub size: Int128,
    pub addr: hwaddr,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(mr: *mut MemoryRegion)>,
    pub align: u64,
    pub terminates: bool,
    pub ram_device: bool,
    pub enabled: bool,
    pub warning_printed: bool,
    pub vga_logging_count: u8,
    pub alias: *mut MemoryRegion,
    pub alias_offset: hwaddr,
    pub priority: i32,
    pub subregions: MemoryRegion__bindgen_ty_1,
    pub subregions_link: MemoryRegion__bindgen_ty_2,
    pub coalesced: MemoryRegion__bindgen_ty_3,
    pub name: *const core::ffi::c_char,
    pub ioeventfd_nb: core::ffi::c_uint,
    pub ioeventfds: *mut MemoryRegionIoeventfd,
    pub rdm: *mut RamDiscardManager,
    pub disable_reentrancy_guard: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryRegion__bindgen_ty_1 {
    pub tqh_first: *mut MemoryRegion,
    pub tqh_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_MemoryRegion__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryRegion__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryRegion__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(MemoryRegion__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryRegion__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryRegion__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion__bindgen_ty_1),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion__bindgen_ty_1),
            "::",
            stringify!(tqh_circ)
        )
    );
}
impl Default for MemoryRegion__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for MemoryRegion__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "MemoryRegion__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryRegion__bindgen_ty_2 {
    pub tqe_next: *mut MemoryRegion,
    pub tqe_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_MemoryRegion__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryRegion__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryRegion__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(MemoryRegion__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryRegion__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryRegion__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion__bindgen_ty_2),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion__bindgen_ty_2),
            "::",
            stringify!(tqe_circ)
        )
    );
}
impl Default for MemoryRegion__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for MemoryRegion__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "MemoryRegion__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryRegion__bindgen_ty_3 {
    pub tqh_first: *mut CoalescedMemoryRange,
    pub tqh_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_MemoryRegion__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryRegion__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryRegion__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(MemoryRegion__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryRegion__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryRegion__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion__bindgen_ty_3),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion__bindgen_ty_3),
            "::",
            stringify!(tqh_circ)
        )
    );
}
impl Default for MemoryRegion__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for MemoryRegion__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "MemoryRegion__bindgen_ty_3 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_MemoryRegion() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryRegion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryRegion>(),
        272usize,
        concat!("Size of: ", stringify!(MemoryRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryRegion>(),
        16usize,
        concat!("Alignment of ", stringify!(MemoryRegion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(parent_obj)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).romd_mode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(romd_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ram) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(ram)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subpage) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(subpage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).readonly) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(readonly)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nonvolatile) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(nonvolatile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rom_device) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(rom_device)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flush_coalesced_mmio) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(flush_coalesced_mmio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unmergeable) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(unmergeable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dirty_log_mask) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(dirty_log_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_iommu) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(is_iommu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ram_block) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(ram_block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).container) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(container)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mapped_via_alias) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(mapped_via_alias)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).destructor) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(destructor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).align) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).terminates) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(terminates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ram_device) as usize - ptr as usize },
        153usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(ram_device)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).warning_printed) as usize - ptr as usize },
        155usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(warning_printed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vga_logging_count) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(vga_logging_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alias) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(alias)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alias_offset) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(alias_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subregions) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(subregions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subregions_link) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(subregions_link)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coalesced) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(coalesced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ioeventfd_nb) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(ioeventfd_nb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ioeventfds) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(ioeventfds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rdm) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(rdm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disable_reentrancy_guard) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegion),
            "::",
            stringify!(disable_reentrancy_guard)
        )
    );
}
impl Default for MemoryRegion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for MemoryRegion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "MemoryRegion {{ parent_obj: {:?}, romd_mode: {:?}, ram: {:?}, subpage: {:?}, readonly: {:?}, nonvolatile: {:?}, rom_device: {:?}, flush_coalesced_mmio: {:?}, unmergeable: {:?}, dirty_log_mask: {:?}, is_iommu: {:?}, ram_block: {:?}, owner: {:?}, dev: {:?}, ops: {:?}, opaque: {:?}, container: {:?}, mapped_via_alias: {:?}, size: {:?}, addr: {:?}, destructor: {:?}, align: {:?}, terminates: {:?}, ram_device: {:?}, enabled: {:?}, warning_printed: {:?}, vga_logging_count: {:?}, alias: {:?}, alias_offset: {:?}, priority: {:?}, subregions: {:?}, subregions_link: {:?}, coalesced: {:?}, name: {:?}, ioeventfd_nb: {:?}, ioeventfds: {:?}, rdm: {:?}, disable_reentrancy_guard: {:?} }}" , self . parent_obj , self . romd_mode , self . ram , self . subpage , self . readonly , self . nonvolatile , self . rom_device , self . flush_coalesced_mmio , self . unmergeable , self . dirty_log_mask , self . is_iommu , self . ram_block , self . owner , self . dev , self . ops , self . opaque , self . container , self . mapped_via_alias , self . size , self . addr , self . destructor , self . align , self . terminates , self . ram_device , self . enabled , self . warning_printed , self . vga_logging_count , self . alias , self . alias_offset , self . priority , self . subregions , self . subregions_link , self . coalesced , self . name , self . ioeventfd_nb , self . ioeventfds , self . rdm , self . disable_reentrancy_guard)
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct IOMMUMemoryRegion {
    pub parent_obj: MemoryRegion,
    pub iommu_notify: IOMMUMemoryRegion__bindgen_ty_1,
    pub iommu_notify_flags: IOMMUNotifierFlag,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IOMMUMemoryRegion__bindgen_ty_1 {
    pub lh_first: *mut IOMMUNotifier,
}
#[test]
fn bindgen_test_layout_IOMMUMemoryRegion__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<IOMMUMemoryRegion__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IOMMUMemoryRegion__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(IOMMUMemoryRegion__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<IOMMUMemoryRegion__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(IOMMUMemoryRegion__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegion__bindgen_ty_1),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for IOMMUMemoryRegion__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_IOMMUMemoryRegion() {
    const UNINIT: ::core::mem::MaybeUninit<IOMMUMemoryRegion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IOMMUMemoryRegion>(),
        288usize,
        concat!("Size of: ", stringify!(IOMMUMemoryRegion))
    );
    assert_eq!(
        ::core::mem::align_of::<IOMMUMemoryRegion>(),
        16usize,
        concat!("Alignment of ", stringify!(IOMMUMemoryRegion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegion),
            "::",
            stringify!(parent_obj)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iommu_notify) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegion),
            "::",
            stringify!(iommu_notify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iommu_notify_flags) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(IOMMUMemoryRegion),
            "::",
            stringify!(iommu_notify_flags)
        )
    );
}
impl Default for IOMMUMemoryRegion {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for IOMMUMemoryRegion {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "IOMMUMemoryRegion {{ parent_obj: {:?}, iommu_notify: {:?}, iommu_notify_flags: {:?} }}" , self . parent_obj , self . iommu_notify , self . iommu_notify_flags)
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MemoryListener {
    pub begin: ::core::option::Option<unsafe extern "C" fn(listener: *mut MemoryListener)>,
    pub commit: ::core::option::Option<unsafe extern "C" fn(listener: *mut MemoryListener)>,
    pub region_add: ::core::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, section: *mut MemoryRegionSection),
    >,
    pub region_del: ::core::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, section: *mut MemoryRegionSection),
    >,
    pub region_nop: ::core::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, section: *mut MemoryRegionSection),
    >,
    pub log_start: ::core::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            old: core::ffi::c_int,
            new: core::ffi::c_int,
        ),
    >,
    pub log_stop: ::core::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            old: core::ffi::c_int,
            new: core::ffi::c_int,
        ),
    >,
    pub log_sync: ::core::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, section: *mut MemoryRegionSection),
    >,
    pub log_sync_global: ::core::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, last_stage: bool),
    >,
    pub log_clear: ::core::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, section: *mut MemoryRegionSection),
    >,
    pub log_global_start: ::core::option::Option<
        unsafe extern "C" fn(listener: *mut MemoryListener, errp: *mut *mut Error) -> bool,
    >,
    pub log_global_stop:
        ::core::option::Option<unsafe extern "C" fn(listener: *mut MemoryListener)>,
    pub log_global_after_sync:
        ::core::option::Option<unsafe extern "C" fn(listener: *mut MemoryListener)>,
    pub eventfd_add: ::core::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            match_data: bool,
            data: u64,
            e: *mut EventNotifier,
        ),
    >,
    pub eventfd_del: ::core::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            match_data: bool,
            data: u64,
            e: *mut EventNotifier,
        ),
    >,
    pub coalesced_io_add: ::core::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            addr: hwaddr,
            len: hwaddr,
        ),
    >,
    pub coalesced_io_del: ::core::option::Option<
        unsafe extern "C" fn(
            listener: *mut MemoryListener,
            section: *mut MemoryRegionSection,
            addr: hwaddr,
            len: hwaddr,
        ),
    >,
    pub priority: core::ffi::c_uint,
    pub name: *const core::ffi::c_char,
    pub address_space: *mut AddressSpace,
    pub link: MemoryListener__bindgen_ty_1,
    pub link_as: MemoryListener__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryListener__bindgen_ty_1 {
    pub tqe_next: *mut MemoryListener,
    pub tqe_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_MemoryListener__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryListener__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryListener__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(MemoryListener__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryListener__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryListener__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener__bindgen_ty_1),
            "::",
            stringify!(tqe_circ)
        )
    );
}
impl Default for MemoryListener__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for MemoryListener__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "MemoryListener__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MemoryListener__bindgen_ty_2 {
    pub tqe_next: *mut MemoryListener,
    pub tqe_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_MemoryListener__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryListener__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryListener__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(MemoryListener__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryListener__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryListener__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener__bindgen_ty_2),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener__bindgen_ty_2),
            "::",
            stringify!(tqe_circ)
        )
    );
}
impl Default for MemoryListener__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for MemoryListener__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "MemoryListener__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_MemoryListener() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryListener> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryListener>(),
        192usize,
        concat!("Size of: ", stringify!(MemoryListener))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryListener>(),
        8usize,
        concat!("Alignment of ", stringify!(MemoryListener))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).commit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(commit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).region_add) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(region_add)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).region_del) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(region_del)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).region_nop) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(region_nop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_start) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(log_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_stop) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(log_stop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_sync) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(log_sync)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_sync_global) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(log_sync_global)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_clear) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(log_clear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_global_start) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(log_global_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_global_stop) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(log_global_stop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_global_after_sync) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(log_global_after_sync)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventfd_add) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(eventfd_add)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventfd_del) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(eventfd_del)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coalesced_io_add) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(coalesced_io_add)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coalesced_io_del) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(coalesced_io_del)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address_space) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(address_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).link_as) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryListener),
            "::",
            stringify!(link_as)
        )
    );
}
impl Default for MemoryListener {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for MemoryListener {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "MemoryListener {{ begin: {:?}, commit: {:?}, region_add: {:?}, region_del: {:?}, region_nop: {:?}, log_start: {:?}, log_stop: {:?}, log_sync: {:?}, log_sync_global: {:?}, log_clear: {:?}, log_global_start: {:?}, log_global_stop: {:?}, log_global_after_sync: {:?}, eventfd_add: {:?}, eventfd_del: {:?}, coalesced_io_add: {:?}, coalesced_io_del: {:?}, priority: {:?}, name: {:?}, address_space: {:?}, link: {:?}, link_as: {:?} }}" , self . begin , self . commit , self . region_add , self . region_del , self . region_nop , self . log_start , self . log_stop , self . log_sync , self . log_sync_global , self . log_clear , self . log_global_start , self . log_global_stop , self . log_global_after_sync , self . eventfd_add , self . eventfd_del , self . coalesced_io_add , self . coalesced_io_del , self . priority , self . name , self . address_space , self . link , self . link_as)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddressSpaceMapClient {
    pub bh: *mut QEMUBH,
    pub link: AddressSpaceMapClient__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddressSpaceMapClient__bindgen_ty_1 {
    pub le_next: *mut AddressSpaceMapClient,
    pub le_prev: *mut *mut AddressSpaceMapClient,
}
#[test]
fn bindgen_test_layout_AddressSpaceMapClient__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<AddressSpaceMapClient__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AddressSpaceMapClient__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(AddressSpaceMapClient__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AddressSpaceMapClient__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(AddressSpaceMapClient__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpaceMapClient__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpaceMapClient__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
impl Default for AddressSpaceMapClient__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_AddressSpaceMapClient() {
    const UNINIT: ::core::mem::MaybeUninit<AddressSpaceMapClient> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AddressSpaceMapClient>(),
        24usize,
        concat!("Size of: ", stringify!(AddressSpaceMapClient))
    );
    assert_eq!(
        ::core::mem::align_of::<AddressSpaceMapClient>(),
        8usize,
        concat!("Alignment of ", stringify!(AddressSpaceMapClient))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpaceMapClient),
            "::",
            stringify!(bh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpaceMapClient),
            "::",
            stringify!(link)
        )
    );
}
impl Default for AddressSpaceMapClient {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BounceBuffer {
    pub mr: *mut MemoryRegion,
    pub buffer: *mut core::ffi::c_void,
    pub addr: hwaddr,
    pub len: hwaddr,
    pub in_use: bool,
}
#[test]
fn bindgen_test_layout_BounceBuffer() {
    const UNINIT: ::core::mem::MaybeUninit<BounceBuffer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BounceBuffer>(),
        40usize,
        concat!("Size of: ", stringify!(BounceBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<BounceBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(BounceBuffer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BounceBuffer),
            "::",
            stringify!(mr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BounceBuffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BounceBuffer),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BounceBuffer),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_use) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BounceBuffer),
            "::",
            stringify!(in_use)
        )
    );
}
impl Default for BounceBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AddressSpace {
    pub rcu: rcu_head,
    pub name: *mut core::ffi::c_char,
    pub root: *mut MemoryRegion,
    pub current_map: *mut FlatView,
    pub ioeventfd_nb: core::ffi::c_int,
    pub ioeventfd_notifiers: core::ffi::c_int,
    pub ioeventfds: *mut MemoryRegionIoeventfd,
    pub listeners: AddressSpace__bindgen_ty_1,
    pub address_spaces_link: AddressSpace__bindgen_ty_2,
    pub bounce: BounceBuffer,
    pub map_client_list_lock: QemuMutex,
    pub map_client_list: AddressSpace__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AddressSpace__bindgen_ty_1 {
    pub tqh_first: *mut MemoryListener,
    pub tqh_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_AddressSpace__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<AddressSpace__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AddressSpace__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(AddressSpace__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AddressSpace__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AddressSpace__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace__bindgen_ty_1),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqh_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace__bindgen_ty_1),
            "::",
            stringify!(tqh_circ)
        )
    );
}
impl Default for AddressSpace__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for AddressSpace__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "AddressSpace__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AddressSpace__bindgen_ty_2 {
    pub tqe_next: *mut AddressSpace,
    pub tqe_circ: QTailQLink,
}
#[test]
fn bindgen_test_layout_AddressSpace__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<AddressSpace__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AddressSpace__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(AddressSpace__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AddressSpace__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(AddressSpace__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace__bindgen_ty_2),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tqe_circ) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace__bindgen_ty_2),
            "::",
            stringify!(tqe_circ)
        )
    );
}
impl Default for AddressSpace__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for AddressSpace__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "AddressSpace__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddressSpace__bindgen_ty_3 {
    pub lh_first: *mut AddressSpaceMapClient,
}
#[test]
fn bindgen_test_layout_AddressSpace__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<AddressSpace__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AddressSpace__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(AddressSpace__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<AddressSpace__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(AddressSpace__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace__bindgen_ty_3),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for AddressSpace__bindgen_ty_3 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_AddressSpace() {
    const UNINIT: ::core::mem::MaybeUninit<AddressSpace> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AddressSpace>(),
        192usize,
        concat!("Size of: ", stringify!(AddressSpace))
    );
    assert_eq!(
        ::core::mem::align_of::<AddressSpace>(),
        8usize,
        concat!("Alignment of ", stringify!(AddressSpace))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_map) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(current_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ioeventfd_nb) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(ioeventfd_nb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ioeventfd_notifiers) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(ioeventfd_notifiers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ioeventfds) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(ioeventfds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).listeners) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(listeners)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address_spaces_link) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(address_spaces_link)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bounce) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(bounce)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).map_client_list_lock) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(map_client_list_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).map_client_list) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AddressSpace),
            "::",
            stringify!(map_client_list)
        )
    );
}
impl Default for AddressSpace {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for AddressSpace {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "AddressSpace {{ rcu: {:?}, name: {:?}, root: {:?}, current_map: {:?}, ioeventfd_nb: {:?}, ioeventfd_notifiers: {:?}, ioeventfds: {:?}, listeners: {:?}, address_spaces_link: {:?}, bounce: {:?}, map_client_list_lock: {:?}, map_client_list: {:?} }}" , self . rcu , self . name , self . root , self . current_map , self . ioeventfd_nb , self . ioeventfd_notifiers , self . ioeventfds , self . listeners , self . address_spaces_link , self . bounce , self . map_client_list_lock , self . map_client_list)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AddressSpaceDispatch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlatRange {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlatView {
    pub rcu: rcu_head,
    pub ref_: core::ffi::c_uint,
    pub ranges: *mut FlatRange,
    pub nr: core::ffi::c_uint,
    pub nr_allocated: core::ffi::c_uint,
    pub dispatch: *mut AddressSpaceDispatch,
    pub root: *mut MemoryRegion,
}
#[test]
fn bindgen_test_layout_FlatView() {
    const UNINIT: ::core::mem::MaybeUninit<FlatView> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FlatView>(),
        56usize,
        concat!("Size of: ", stringify!(FlatView))
    );
    assert_eq!(
        ::core::mem::align_of::<FlatView>(),
        8usize,
        concat!("Alignment of ", stringify!(FlatView))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rcu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FlatView),
            "::",
            stringify!(rcu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FlatView),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ranges) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FlatView),
            "::",
            stringify!(ranges)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FlatView),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nr_allocated) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FlatView),
            "::",
            stringify!(nr_allocated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dispatch) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FlatView),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FlatView),
            "::",
            stringify!(root)
        )
    );
}
impl Default for FlatView {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type flatview_cb = ::core::option::Option<
    unsafe extern "C" fn(
        start: Int128,
        len: Int128,
        mr: *const MemoryRegion,
        offset_in_region: hwaddr,
        opaque: *mut core::ffi::c_void,
    ) -> bool,
>;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct MemoryRegionCache {
    pub ptr: *mut core::ffi::c_void,
    pub xlat: hwaddr,
    pub len: hwaddr,
    pub fv: *mut FlatView,
    pub mrs: MemoryRegionSection,
    pub is_write: bool,
}
#[test]
fn bindgen_test_layout_MemoryRegionCache() {
    const UNINIT: ::core::mem::MaybeUninit<MemoryRegionCache> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MemoryRegionCache>(),
        112usize,
        concat!("Size of: ", stringify!(MemoryRegionCache))
    );
    assert_eq!(
        ::core::mem::align_of::<MemoryRegionCache>(),
        16usize,
        concat!("Alignment of ", stringify!(MemoryRegionCache))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionCache),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xlat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionCache),
            "::",
            stringify!(xlat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionCache),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fv) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionCache),
            "::",
            stringify!(fv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mrs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionCache),
            "::",
            stringify!(mrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_write) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MemoryRegionCache),
            "::",
            stringify!(is_write)
        )
    );
}
impl Default for MemoryRegionCache {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysBusDeviceClass {
    pub parent_class: DeviceClass,
    pub explicit_ofw_unit_address: ::core::option::Option<
        unsafe extern "C" fn(dev: *const SysBusDevice) -> *mut core::ffi::c_char,
    >,
    pub connect_irq_notifier:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut SysBusDevice, irq: qemu_irq)>,
}
#[test]
fn bindgen_test_layout_SysBusDeviceClass() {
    const UNINIT: ::core::mem::MaybeUninit<SysBusDeviceClass> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SysBusDeviceClass>(),
        192usize,
        concat!("Size of: ", stringify!(SysBusDeviceClass))
    );
    assert_eq!(
        ::core::mem::align_of::<SysBusDeviceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(SysBusDeviceClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SysBusDeviceClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).explicit_ofw_unit_address) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SysBusDeviceClass),
            "::",
            stringify!(explicit_ofw_unit_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).connect_irq_notifier) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SysBusDeviceClass),
            "::",
            stringify!(connect_irq_notifier)
        )
    );
}
impl Default for SysBusDeviceClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysBusDevice {
    pub parent_obj: DeviceState,
    pub num_mmio: core::ffi::c_int,
    pub mmio: [SysBusDevice__bindgen_ty_1; 32usize],
    pub num_pio: core::ffi::c_int,
    pub pio: [u32; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysBusDevice__bindgen_ty_1 {
    pub addr: hwaddr,
    pub memory: *mut MemoryRegion,
}
#[test]
fn bindgen_test_layout_SysBusDevice__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SysBusDevice__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SysBusDevice__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(SysBusDevice__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SysBusDevice__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SysBusDevice__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SysBusDevice__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SysBusDevice__bindgen_ty_1),
            "::",
            stringify!(memory)
        )
    );
}
impl Default for SysBusDevice__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_SysBusDevice() {
    const UNINIT: ::core::mem::MaybeUninit<SysBusDevice> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SysBusDevice>(),
        816usize,
        concat!("Size of: ", stringify!(SysBusDevice))
    );
    assert_eq!(
        ::core::mem::align_of::<SysBusDevice>(),
        8usize,
        concat!("Alignment of ", stringify!(SysBusDevice))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SysBusDevice),
            "::",
            stringify!(parent_obj)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_mmio) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SysBusDevice),
            "::",
            stringify!(num_mmio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mmio) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SysBusDevice),
            "::",
            stringify!(mmio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_pio) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(SysBusDevice),
            "::",
            stringify!(num_pio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pio) as usize - ptr as usize },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(SysBusDevice),
            "::",
            stringify!(pio)
        )
    );
}
impl Default for SysBusDevice {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FindSysbusDeviceFunc = ::core::option::Option<
    unsafe extern "C" fn(sbdev: *mut SysBusDevice, opaque: *mut core::ffi::c_void),
>;
pub const NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_IPV4: NetworkAddressFamily = 0;
pub const NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_IPV6: NetworkAddressFamily = 1;
pub const NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_UNIX: NetworkAddressFamily = 2;
pub const NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_VSOCK: NetworkAddressFamily = 3;
pub const NetworkAddressFamily_NETWORK_ADDRESS_FAMILY_UNKNOWN: NetworkAddressFamily = 4;
pub const NetworkAddressFamily_NETWORK_ADDRESS_FAMILY__MAX: NetworkAddressFamily = 5;
pub type NetworkAddressFamily = core::ffi::c_uint;
pub const SocketAddressType_SOCKET_ADDRESS_TYPE_INET: SocketAddressType = 0;
pub const SocketAddressType_SOCKET_ADDRESS_TYPE_UNIX: SocketAddressType = 1;
pub const SocketAddressType_SOCKET_ADDRESS_TYPE_VSOCK: SocketAddressType = 2;
pub const SocketAddressType_SOCKET_ADDRESS_TYPE_FD: SocketAddressType = 3;
pub const SocketAddressType_SOCKET_ADDRESS_TYPE__MAX: SocketAddressType = 4;
pub type SocketAddressType = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InetSocketAddressBase {
    pub host: *mut core::ffi::c_char,
    pub port: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_InetSocketAddressBase() {
    const UNINIT: ::core::mem::MaybeUninit<InetSocketAddressBase> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InetSocketAddressBase>(),
        16usize,
        concat!("Size of: ", stringify!(InetSocketAddressBase))
    );
    assert_eq!(
        ::core::mem::align_of::<InetSocketAddressBase>(),
        8usize,
        concat!("Alignment of ", stringify!(InetSocketAddressBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddressBase),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddressBase),
            "::",
            stringify!(port)
        )
    );
}
impl Default for InetSocketAddressBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InetSocketAddress {
    pub host: *mut core::ffi::c_char,
    pub port: *mut core::ffi::c_char,
    pub has_numeric: bool,
    pub numeric: bool,
    pub has_to: bool,
    pub to: u16,
    pub has_ipv4: bool,
    pub ipv4: bool,
    pub has_ipv6: bool,
    pub ipv6: bool,
    pub has_keep_alive: bool,
    pub keep_alive: bool,
    pub has_mptcp: bool,
    pub mptcp: bool,
}
#[test]
fn bindgen_test_layout_InetSocketAddress() {
    const UNINIT: ::core::mem::MaybeUninit<InetSocketAddress> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InetSocketAddress>(),
        32usize,
        concat!("Size of: ", stringify!(InetSocketAddress))
    );
    assert_eq!(
        ::core::mem::align_of::<InetSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(InetSocketAddress))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_numeric) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(has_numeric)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numeric) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(numeric)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_to) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(has_to)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).to) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(to)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_ipv4) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(has_ipv4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipv4) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_ipv6) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(has_ipv6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipv6) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(ipv6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_keep_alive) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(has_keep_alive)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keep_alive) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(keep_alive)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_mptcp) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(has_mptcp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mptcp) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddress),
            "::",
            stringify!(mptcp)
        )
    );
}
impl Default for InetSocketAddress {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnixSocketAddress {
    pub path: *mut core::ffi::c_char,
    pub has_abstract: bool,
    pub abstract_: bool,
    pub has_tight: bool,
    pub tight: bool,
}
#[test]
fn bindgen_test_layout_UnixSocketAddress() {
    const UNINIT: ::core::mem::MaybeUninit<UnixSocketAddress> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<UnixSocketAddress>(),
        16usize,
        concat!("Size of: ", stringify!(UnixSocketAddress))
    );
    assert_eq!(
        ::core::mem::align_of::<UnixSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(UnixSocketAddress))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UnixSocketAddress),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_abstract) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UnixSocketAddress),
            "::",
            stringify!(has_abstract)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).abstract_) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(UnixSocketAddress),
            "::",
            stringify!(abstract_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_tight) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UnixSocketAddress),
            "::",
            stringify!(has_tight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tight) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(UnixSocketAddress),
            "::",
            stringify!(tight)
        )
    );
}
impl Default for UnixSocketAddress {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VsockSocketAddress {
    pub cid: *mut core::ffi::c_char,
    pub port: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_VsockSocketAddress() {
    const UNINIT: ::core::mem::MaybeUninit<VsockSocketAddress> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VsockSocketAddress>(),
        16usize,
        concat!("Size of: ", stringify!(VsockSocketAddress))
    );
    assert_eq!(
        ::core::mem::align_of::<VsockSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(VsockSocketAddress))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VsockSocketAddress),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VsockSocketAddress),
            "::",
            stringify!(port)
        )
    );
}
impl Default for VsockSocketAddress {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FdSocketAddress {
    pub str_: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_FdSocketAddress() {
    const UNINIT: ::core::mem::MaybeUninit<FdSocketAddress> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FdSocketAddress>(),
        8usize,
        concat!("Size of: ", stringify!(FdSocketAddress))
    );
    assert_eq!(
        ::core::mem::align_of::<FdSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(FdSocketAddress))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FdSocketAddress),
            "::",
            stringify!(str_)
        )
    );
}
impl Default for FdSocketAddress {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InetSocketAddressWrapper {
    pub data: *mut InetSocketAddress,
}
#[test]
fn bindgen_test_layout_InetSocketAddressWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<InetSocketAddressWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InetSocketAddressWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(InetSocketAddressWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<InetSocketAddressWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(InetSocketAddressWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddressWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for InetSocketAddressWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnixSocketAddressWrapper {
    pub data: *mut UnixSocketAddress,
}
#[test]
fn bindgen_test_layout_UnixSocketAddressWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<UnixSocketAddressWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<UnixSocketAddressWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(UnixSocketAddressWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<UnixSocketAddressWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(UnixSocketAddressWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UnixSocketAddressWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for UnixSocketAddressWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VsockSocketAddressWrapper {
    pub data: *mut VsockSocketAddress,
}
#[test]
fn bindgen_test_layout_VsockSocketAddressWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<VsockSocketAddressWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VsockSocketAddressWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(VsockSocketAddressWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<VsockSocketAddressWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(VsockSocketAddressWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VsockSocketAddressWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for VsockSocketAddressWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FdSocketAddressWrapper {
    pub data: *mut FdSocketAddress,
}
#[test]
fn bindgen_test_layout_FdSocketAddressWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<FdSocketAddressWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FdSocketAddressWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(FdSocketAddressWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<FdSocketAddressWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(FdSocketAddressWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FdSocketAddressWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for FdSocketAddressWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_SocketAddressLegacy_base {
    pub type_: SocketAddressType,
}
#[test]
fn bindgen_test_layout_q_obj_SocketAddressLegacy_base() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_SocketAddressLegacy_base> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_SocketAddressLegacy_base>(),
        4usize,
        concat!("Size of: ", stringify!(q_obj_SocketAddressLegacy_base))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_SocketAddressLegacy_base>(),
        4usize,
        concat!("Alignment of ", stringify!(q_obj_SocketAddressLegacy_base))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_SocketAddressLegacy_base),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for q_obj_SocketAddressLegacy_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SocketAddressLegacy {
    pub type_: SocketAddressType,
    pub u: SocketAddressLegacy__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SocketAddressLegacy__bindgen_ty_1 {
    pub inet: InetSocketAddressWrapper,
    pub q_unix: UnixSocketAddressWrapper,
    pub vsock: VsockSocketAddressWrapper,
    pub fd: FdSocketAddressWrapper,
}
#[test]
fn bindgen_test_layout_SocketAddressLegacy__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SocketAddressLegacy__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SocketAddressLegacy__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(SocketAddressLegacy__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SocketAddressLegacy__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SocketAddressLegacy__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inet) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddressLegacy__bindgen_ty_1),
            "::",
            stringify!(inet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q_unix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddressLegacy__bindgen_ty_1),
            "::",
            stringify!(q_unix)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vsock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddressLegacy__bindgen_ty_1),
            "::",
            stringify!(vsock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddressLegacy__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
}
impl Default for SocketAddressLegacy__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for SocketAddressLegacy__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "SocketAddressLegacy__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_SocketAddressLegacy() {
    const UNINIT: ::core::mem::MaybeUninit<SocketAddressLegacy> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SocketAddressLegacy>(),
        16usize,
        concat!("Size of: ", stringify!(SocketAddressLegacy))
    );
    assert_eq!(
        ::core::mem::align_of::<SocketAddressLegacy>(),
        8usize,
        concat!("Alignment of ", stringify!(SocketAddressLegacy))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddressLegacy),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddressLegacy),
            "::",
            stringify!(u)
        )
    );
}
impl Default for SocketAddressLegacy {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for SocketAddressLegacy {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "SocketAddressLegacy {{ type: {:?}, u: {:?} }}",
            self.type_, self.u
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_SocketAddress_base {
    pub type_: SocketAddressType,
}
#[test]
fn bindgen_test_layout_q_obj_SocketAddress_base() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_SocketAddress_base> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_SocketAddress_base>(),
        4usize,
        concat!("Size of: ", stringify!(q_obj_SocketAddress_base))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_SocketAddress_base>(),
        4usize,
        concat!("Alignment of ", stringify!(q_obj_SocketAddress_base))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_SocketAddress_base),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for q_obj_SocketAddress_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SocketAddress {
    pub type_: SocketAddressType,
    pub u: SocketAddress__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SocketAddress__bindgen_ty_1 {
    pub inet: InetSocketAddress,
    pub q_unix: UnixSocketAddress,
    pub vsock: VsockSocketAddress,
    pub fd: FdSocketAddress,
}
#[test]
fn bindgen_test_layout_SocketAddress__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SocketAddress__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SocketAddress__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(SocketAddress__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SocketAddress__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SocketAddress__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inet) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddress__bindgen_ty_1),
            "::",
            stringify!(inet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).q_unix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddress__bindgen_ty_1),
            "::",
            stringify!(q_unix)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vsock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddress__bindgen_ty_1),
            "::",
            stringify!(vsock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddress__bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
}
impl Default for SocketAddress__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for SocketAddress__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "SocketAddress__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_SocketAddress() {
    const UNINIT: ::core::mem::MaybeUninit<SocketAddress> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SocketAddress>(),
        40usize,
        concat!("Size of: ", stringify!(SocketAddress))
    );
    assert_eq!(
        ::core::mem::align_of::<SocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(SocketAddress))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddress),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddress),
            "::",
            stringify!(u)
        )
    );
}
impl Default for SocketAddress {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for SocketAddress {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "SocketAddress {{ type: {:?}, u: {:?} }}",
            self.type_, self.u
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SocketAddressList {
    pub next: *mut SocketAddressList,
    pub value: *mut SocketAddress,
}
#[test]
fn bindgen_test_layout_SocketAddressList() {
    const UNINIT: ::core::mem::MaybeUninit<SocketAddressList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SocketAddressList>(),
        16usize,
        concat!("Size of: ", stringify!(SocketAddressList))
    );
    assert_eq!(
        ::core::mem::align_of::<SocketAddressList>(),
        8usize,
        concat!("Alignment of ", stringify!(SocketAddressList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddressList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SocketAddressList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for SocketAddressList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InetSocketAddressBaseList {
    pub next: *mut InetSocketAddressBaseList,
    pub value: *mut InetSocketAddressBase,
}
#[test]
fn bindgen_test_layout_InetSocketAddressBaseList() {
    const UNINIT: ::core::mem::MaybeUninit<InetSocketAddressBaseList> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<InetSocketAddressBaseList>(),
        16usize,
        concat!("Size of: ", stringify!(InetSocketAddressBaseList))
    );
    assert_eq!(
        ::core::mem::align_of::<InetSocketAddressBaseList>(),
        8usize,
        concat!("Alignment of ", stringify!(InetSocketAddressBaseList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddressBaseList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InetSocketAddressBaseList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for InetSocketAddressBaseList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const DataFormat_DATA_FORMAT_UTF8: DataFormat = 0;
pub const DataFormat_DATA_FORMAT_BASE64: DataFormat = 1;
pub const DataFormat_DATA_FORMAT__MAX: DataFormat = 2;
pub type DataFormat = core::ffi::c_uint;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_FILE: ChardevBackendKind = 0;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_SERIAL: ChardevBackendKind = 1;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_PARALLEL: ChardevBackendKind = 2;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_PIPE: ChardevBackendKind = 3;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_SOCKET: ChardevBackendKind = 4;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_UDP: ChardevBackendKind = 5;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_PTY: ChardevBackendKind = 6;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_NULL: ChardevBackendKind = 7;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_MUX: ChardevBackendKind = 8;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_MSMOUSE: ChardevBackendKind = 9;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_WCTABLET: ChardevBackendKind = 10;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_BRAILLE: ChardevBackendKind = 11;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_TESTDEV: ChardevBackendKind = 12;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_STDIO: ChardevBackendKind = 13;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_DBUS: ChardevBackendKind = 14;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_VC: ChardevBackendKind = 15;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_RINGBUF: ChardevBackendKind = 16;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND_MEMORY: ChardevBackendKind = 17;
pub const ChardevBackendKind_CHARDEV_BACKEND_KIND__MAX: ChardevBackendKind = 18;
pub type ChardevBackendKind = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevInfo {
    pub label: *mut core::ffi::c_char,
    pub filename: *mut core::ffi::c_char,
    pub frontend_open: bool,
}
#[test]
fn bindgen_test_layout_ChardevInfo() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevInfo>(),
        24usize,
        concat!("Size of: ", stringify!(ChardevInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevInfo),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevInfo),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frontend_open) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevInfo),
            "::",
            stringify!(frontend_open)
        )
    );
}
impl Default for ChardevInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevInfoList {
    pub next: *mut ChardevInfoList,
    pub value: *mut ChardevInfo,
}
#[test]
fn bindgen_test_layout_ChardevInfoList() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevInfoList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(ChardevInfoList))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevInfoList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevInfoList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevInfoList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for ChardevInfoList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevBackendInfo {
    pub name: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_ChardevBackendInfo() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevBackendInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevBackendInfo>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevBackendInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevBackendInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevBackendInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackendInfo),
            "::",
            stringify!(name)
        )
    );
}
impl Default for ChardevBackendInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevBackendInfoList {
    pub next: *mut ChardevBackendInfoList,
    pub value: *mut ChardevBackendInfo,
}
#[test]
fn bindgen_test_layout_ChardevBackendInfoList() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevBackendInfoList> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevBackendInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(ChardevBackendInfoList))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevBackendInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevBackendInfoList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackendInfoList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackendInfoList),
            "::",
            stringify!(value)
        )
    );
}
impl Default for ChardevBackendInfoList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_ringbuf_write_arg {
    pub device: *mut core::ffi::c_char,
    pub data: *mut core::ffi::c_char,
    pub has_format: bool,
    pub format: DataFormat,
}
#[test]
fn bindgen_test_layout_q_obj_ringbuf_write_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_ringbuf_write_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_ringbuf_write_arg>(),
        24usize,
        concat!("Size of: ", stringify!(q_obj_ringbuf_write_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_ringbuf_write_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_ringbuf_write_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_ringbuf_write_arg),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_ringbuf_write_arg),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_ringbuf_write_arg),
            "::",
            stringify!(has_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_ringbuf_write_arg),
            "::",
            stringify!(format)
        )
    );
}
impl Default for q_obj_ringbuf_write_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_ringbuf_read_arg {
    pub device: *mut core::ffi::c_char,
    pub size: i64,
    pub has_format: bool,
    pub format: DataFormat,
}
#[test]
fn bindgen_test_layout_q_obj_ringbuf_read_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_ringbuf_read_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_ringbuf_read_arg>(),
        24usize,
        concat!("Size of: ", stringify!(q_obj_ringbuf_read_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_ringbuf_read_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_ringbuf_read_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_ringbuf_read_arg),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_ringbuf_read_arg),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_format) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_ringbuf_read_arg),
            "::",
            stringify!(has_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_ringbuf_read_arg),
            "::",
            stringify!(format)
        )
    );
}
impl Default for q_obj_ringbuf_read_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevCommon {
    pub logfile: *mut core::ffi::c_char,
    pub has_logappend: bool,
    pub logappend: bool,
}
#[test]
fn bindgen_test_layout_ChardevCommon() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevCommon> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevCommon>(),
        16usize,
        concat!("Size of: ", stringify!(ChardevCommon))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevCommon>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevCommon))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevCommon),
            "::",
            stringify!(logfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_logappend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevCommon),
            "::",
            stringify!(has_logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logappend) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevCommon),
            "::",
            stringify!(logappend)
        )
    );
}
impl Default for ChardevCommon {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevFile {
    pub logfile: *mut core::ffi::c_char,
    pub has_logappend: bool,
    pub logappend: bool,
    pub in_: *mut core::ffi::c_char,
    pub out: *mut core::ffi::c_char,
    pub has_append: bool,
    pub append: bool,
}
#[test]
fn bindgen_test_layout_ChardevFile() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevFile> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevFile>(),
        40usize,
        concat!("Size of: ", stringify!(ChardevFile))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevFile>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevFile))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevFile),
            "::",
            stringify!(logfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_logappend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevFile),
            "::",
            stringify!(has_logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logappend) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevFile),
            "::",
            stringify!(logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevFile),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevFile),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_append) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevFile),
            "::",
            stringify!(has_append)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).append) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevFile),
            "::",
            stringify!(append)
        )
    );
}
impl Default for ChardevFile {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevHostdev {
    pub logfile: *mut core::ffi::c_char,
    pub has_logappend: bool,
    pub logappend: bool,
    pub device: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_ChardevHostdev() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevHostdev> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevHostdev>(),
        24usize,
        concat!("Size of: ", stringify!(ChardevHostdev))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevHostdev>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevHostdev))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevHostdev),
            "::",
            stringify!(logfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_logappend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevHostdev),
            "::",
            stringify!(has_logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logappend) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevHostdev),
            "::",
            stringify!(logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevHostdev),
            "::",
            stringify!(device)
        )
    );
}
impl Default for ChardevHostdev {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevSocket {
    pub logfile: *mut core::ffi::c_char,
    pub has_logappend: bool,
    pub logappend: bool,
    pub addr: *mut SocketAddressLegacy,
    pub tls_creds: *mut core::ffi::c_char,
    pub tls_authz: *mut core::ffi::c_char,
    pub has_server: bool,
    pub server: bool,
    pub has_wait: bool,
    pub wait: bool,
    pub has_nodelay: bool,
    pub nodelay: bool,
    pub has_telnet: bool,
    pub telnet: bool,
    pub has_tn3270: bool,
    pub tn3270: bool,
    pub has_websocket: bool,
    pub websocket: bool,
    pub has_reconnect: bool,
    pub reconnect: i64,
}
#[test]
fn bindgen_test_layout_ChardevSocket() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevSocket> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevSocket>(),
        64usize,
        concat!("Size of: ", stringify!(ChardevSocket))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevSocket>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevSocket))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(logfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_logappend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(has_logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logappend) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tls_creds) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(tls_creds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tls_authz) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(tls_authz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_server) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(has_server)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).server) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(server)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_wait) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(has_wait)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_nodelay) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(has_nodelay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nodelay) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(nodelay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_telnet) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(has_telnet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).telnet) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(telnet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_tn3270) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(has_tn3270)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tn3270) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(tn3270)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_websocket) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(has_websocket)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).websocket) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(websocket)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_reconnect) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(has_reconnect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reconnect) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocket),
            "::",
            stringify!(reconnect)
        )
    );
}
impl Default for ChardevSocket {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevUdp {
    pub logfile: *mut core::ffi::c_char,
    pub has_logappend: bool,
    pub logappend: bool,
    pub remote: *mut SocketAddressLegacy,
    pub local: *mut SocketAddressLegacy,
}
#[test]
fn bindgen_test_layout_ChardevUdp() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevUdp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevUdp>(),
        32usize,
        concat!("Size of: ", stringify!(ChardevUdp))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevUdp>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevUdp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevUdp),
            "::",
            stringify!(logfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_logappend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevUdp),
            "::",
            stringify!(has_logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logappend) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevUdp),
            "::",
            stringify!(logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remote) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevUdp),
            "::",
            stringify!(remote)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevUdp),
            "::",
            stringify!(local)
        )
    );
}
impl Default for ChardevUdp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevMux {
    pub logfile: *mut core::ffi::c_char,
    pub has_logappend: bool,
    pub logappend: bool,
    pub chardev: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_ChardevMux() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevMux> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevMux>(),
        24usize,
        concat!("Size of: ", stringify!(ChardevMux))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevMux>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevMux))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevMux),
            "::",
            stringify!(logfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_logappend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevMux),
            "::",
            stringify!(has_logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logappend) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevMux),
            "::",
            stringify!(logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chardev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevMux),
            "::",
            stringify!(chardev)
        )
    );
}
impl Default for ChardevMux {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevStdio {
    pub logfile: *mut core::ffi::c_char,
    pub has_logappend: bool,
    pub logappend: bool,
    pub has_signal: bool,
    pub signal: bool,
}
#[test]
fn bindgen_test_layout_ChardevStdio() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevStdio> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevStdio>(),
        16usize,
        concat!("Size of: ", stringify!(ChardevStdio))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevStdio>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevStdio))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevStdio),
            "::",
            stringify!(logfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_logappend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevStdio),
            "::",
            stringify!(has_logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logappend) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevStdio),
            "::",
            stringify!(logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_signal) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevStdio),
            "::",
            stringify!(has_signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevStdio),
            "::",
            stringify!(signal)
        )
    );
}
impl Default for ChardevStdio {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevDBus {
    pub logfile: *mut core::ffi::c_char,
    pub has_logappend: bool,
    pub logappend: bool,
    pub name: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_ChardevDBus() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevDBus> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevDBus>(),
        24usize,
        concat!("Size of: ", stringify!(ChardevDBus))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevDBus>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevDBus))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevDBus),
            "::",
            stringify!(logfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_logappend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevDBus),
            "::",
            stringify!(has_logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logappend) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevDBus),
            "::",
            stringify!(logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevDBus),
            "::",
            stringify!(name)
        )
    );
}
impl Default for ChardevDBus {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevVC {
    pub logfile: *mut core::ffi::c_char,
    pub has_logappend: bool,
    pub logappend: bool,
    pub has_width: bool,
    pub width: i64,
    pub has_height: bool,
    pub height: i64,
    pub has_cols: bool,
    pub cols: i64,
    pub has_rows: bool,
    pub rows: i64,
}
#[test]
fn bindgen_test_layout_ChardevVC() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevVC> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevVC>(),
        72usize,
        concat!("Size of: ", stringify!(ChardevVC))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevVC>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevVC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVC),
            "::",
            stringify!(logfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_logappend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVC),
            "::",
            stringify!(has_logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logappend) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVC),
            "::",
            stringify!(logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_width) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVC),
            "::",
            stringify!(has_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVC),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVC),
            "::",
            stringify!(has_height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVC),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_cols) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVC),
            "::",
            stringify!(has_cols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cols) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVC),
            "::",
            stringify!(cols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_rows) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVC),
            "::",
            stringify!(has_rows)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rows) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVC),
            "::",
            stringify!(rows)
        )
    );
}
impl Default for ChardevVC {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevRingbuf {
    pub logfile: *mut core::ffi::c_char,
    pub has_logappend: bool,
    pub logappend: bool,
    pub has_size: bool,
    pub size: i64,
}
#[test]
fn bindgen_test_layout_ChardevRingbuf() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevRingbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevRingbuf>(),
        24usize,
        concat!("Size of: ", stringify!(ChardevRingbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevRingbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevRingbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logfile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevRingbuf),
            "::",
            stringify!(logfile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_logappend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevRingbuf),
            "::",
            stringify!(has_logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logappend) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevRingbuf),
            "::",
            stringify!(logappend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_size) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevRingbuf),
            "::",
            stringify!(has_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevRingbuf),
            "::",
            stringify!(size)
        )
    );
}
impl Default for ChardevRingbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevFileWrapper {
    pub data: *mut ChardevFile,
}
#[test]
fn bindgen_test_layout_ChardevFileWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevFileWrapper> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevFileWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevFileWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevFileWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevFileWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevFileWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ChardevFileWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevHostdevWrapper {
    pub data: *mut ChardevHostdev,
}
#[test]
fn bindgen_test_layout_ChardevHostdevWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevHostdevWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevHostdevWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevHostdevWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevHostdevWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevHostdevWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevHostdevWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ChardevHostdevWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevSocketWrapper {
    pub data: *mut ChardevSocket,
}
#[test]
fn bindgen_test_layout_ChardevSocketWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevSocketWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevSocketWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevSocketWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevSocketWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevSocketWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevSocketWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ChardevSocketWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevUdpWrapper {
    pub data: *mut ChardevUdp,
}
#[test]
fn bindgen_test_layout_ChardevUdpWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevUdpWrapper> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevUdpWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevUdpWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevUdpWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevUdpWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevUdpWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ChardevUdpWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevCommonWrapper {
    pub data: *mut ChardevCommon,
}
#[test]
fn bindgen_test_layout_ChardevCommonWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevCommonWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevCommonWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevCommonWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevCommonWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevCommonWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevCommonWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ChardevCommonWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevMuxWrapper {
    pub data: *mut ChardevMux,
}
#[test]
fn bindgen_test_layout_ChardevMuxWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevMuxWrapper> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevMuxWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevMuxWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevMuxWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevMuxWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevMuxWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ChardevMuxWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevStdioWrapper {
    pub data: *mut ChardevStdio,
}
#[test]
fn bindgen_test_layout_ChardevStdioWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevStdioWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevStdioWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevStdioWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevStdioWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevStdioWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevStdioWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ChardevStdioWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevDBusWrapper {
    pub data: *mut ChardevDBus,
}
#[test]
fn bindgen_test_layout_ChardevDBusWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevDBusWrapper> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevDBusWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevDBusWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevDBusWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevDBusWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevDBusWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ChardevDBusWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevVCWrapper {
    pub data: *mut ChardevVC,
}
#[test]
fn bindgen_test_layout_ChardevVCWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevVCWrapper> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevVCWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevVCWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevVCWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevVCWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevVCWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ChardevVCWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevRingbufWrapper {
    pub data: *mut ChardevRingbuf,
}
#[test]
fn bindgen_test_layout_ChardevRingbufWrapper() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevRingbufWrapper> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevRingbufWrapper>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevRingbufWrapper))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevRingbufWrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevRingbufWrapper))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevRingbufWrapper),
            "::",
            stringify!(data)
        )
    );
}
impl Default for ChardevRingbufWrapper {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_ChardevBackend_base {
    pub type_: ChardevBackendKind,
}
#[test]
fn bindgen_test_layout_q_obj_ChardevBackend_base() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_ChardevBackend_base> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_ChardevBackend_base>(),
        4usize,
        concat!("Size of: ", stringify!(q_obj_ChardevBackend_base))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_ChardevBackend_base>(),
        4usize,
        concat!("Alignment of ", stringify!(q_obj_ChardevBackend_base))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_ChardevBackend_base),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for q_obj_ChardevBackend_base {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ChardevBackend {
    pub type_: ChardevBackendKind,
    pub u: ChardevBackend__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ChardevBackend__bindgen_ty_1 {
    pub file: ChardevFileWrapper,
    pub serial: ChardevHostdevWrapper,
    pub parallel: ChardevHostdevWrapper,
    pub pipe: ChardevHostdevWrapper,
    pub socket: ChardevSocketWrapper,
    pub udp: ChardevUdpWrapper,
    pub pty: ChardevCommonWrapper,
    pub null: ChardevCommonWrapper,
    pub mux: ChardevMuxWrapper,
    pub msmouse: ChardevCommonWrapper,
    pub wctablet: ChardevCommonWrapper,
    pub braille: ChardevCommonWrapper,
    pub testdev: ChardevCommonWrapper,
    pub stdio: ChardevStdioWrapper,
    pub dbus: ChardevDBusWrapper,
    pub vc: ChardevVCWrapper,
    pub ringbuf: ChardevRingbufWrapper,
    pub memory: ChardevRingbufWrapper,
}
#[test]
fn bindgen_test_layout_ChardevBackend__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevBackend__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevBackend__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevBackend__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevBackend__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevBackend__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parallel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(parallel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pipe) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(pipe)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).socket) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(socket)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).udp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(udp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pty) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(pty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).null) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(null)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mux) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(mux)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msmouse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(msmouse)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wctablet) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(wctablet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).braille) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(braille)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).testdev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(testdev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stdio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(stdio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dbus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(dbus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(vc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ringbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(ringbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend__bindgen_ty_1),
            "::",
            stringify!(memory)
        )
    );
}
impl Default for ChardevBackend__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for ChardevBackend__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "ChardevBackend__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ChardevBackend() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevBackend> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevBackend>(),
        16usize,
        concat!("Size of: ", stringify!(ChardevBackend))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevBackend>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevBackend))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevBackend),
            "::",
            stringify!(u)
        )
    );
}
impl Default for ChardevBackend {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for ChardevBackend {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "ChardevBackend {{ type: {:?}, u: {:?} }}",
            self.type_, self.u
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevReturn {
    pub pty: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_ChardevReturn() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevReturn> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevReturn>(),
        8usize,
        concat!("Size of: ", stringify!(ChardevReturn))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevReturn>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevReturn))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pty) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevReturn),
            "::",
            stringify!(pty)
        )
    );
}
impl Default for ChardevReturn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_chardev_add_arg {
    pub id: *mut core::ffi::c_char,
    pub backend: *mut ChardevBackend,
}
#[test]
fn bindgen_test_layout_q_obj_chardev_add_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_chardev_add_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_chardev_add_arg>(),
        16usize,
        concat!("Size of: ", stringify!(q_obj_chardev_add_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_chardev_add_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_chardev_add_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_chardev_add_arg),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).backend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_chardev_add_arg),
            "::",
            stringify!(backend)
        )
    );
}
impl Default for q_obj_chardev_add_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_chardev_change_arg {
    pub id: *mut core::ffi::c_char,
    pub backend: *mut ChardevBackend,
}
#[test]
fn bindgen_test_layout_q_obj_chardev_change_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_chardev_change_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_chardev_change_arg>(),
        16usize,
        concat!("Size of: ", stringify!(q_obj_chardev_change_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_chardev_change_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_chardev_change_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_chardev_change_arg),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).backend) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_chardev_change_arg),
            "::",
            stringify!(backend)
        )
    );
}
impl Default for q_obj_chardev_change_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_chardev_remove_arg {
    pub id: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_q_obj_chardev_remove_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_chardev_remove_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_chardev_remove_arg>(),
        8usize,
        concat!("Size of: ", stringify!(q_obj_chardev_remove_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_chardev_remove_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_chardev_remove_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_chardev_remove_arg),
            "::",
            stringify!(id)
        )
    );
}
impl Default for q_obj_chardev_remove_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_chardev_send_break_arg {
    pub id: *mut core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_q_obj_chardev_send_break_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_chardev_send_break_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_chardev_send_break_arg>(),
        8usize,
        concat!("Size of: ", stringify!(q_obj_chardev_send_break_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_chardev_send_break_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_chardev_send_break_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_chardev_send_break_arg),
            "::",
            stringify!(id)
        )
    );
}
impl Default for q_obj_chardev_send_break_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct q_obj_VSERPORT_CHANGE_arg {
    pub id: *mut core::ffi::c_char,
    pub open: bool,
}
#[test]
fn bindgen_test_layout_q_obj_VSERPORT_CHANGE_arg() {
    const UNINIT: ::core::mem::MaybeUninit<q_obj_VSERPORT_CHANGE_arg> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<q_obj_VSERPORT_CHANGE_arg>(),
        16usize,
        concat!("Size of: ", stringify!(q_obj_VSERPORT_CHANGE_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<q_obj_VSERPORT_CHANGE_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(q_obj_VSERPORT_CHANGE_arg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_VSERPORT_CHANGE_arg),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(q_obj_VSERPORT_CHANGE_arg),
            "::",
            stringify!(open)
        )
    );
}
impl Default for q_obj_VSERPORT_CHANGE_arg {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const QEMUChrEvent_CHR_EVENT_BREAK: QEMUChrEvent = 0;
pub const QEMUChrEvent_CHR_EVENT_OPENED: QEMUChrEvent = 1;
pub const QEMUChrEvent_CHR_EVENT_MUX_IN: QEMUChrEvent = 2;
pub const QEMUChrEvent_CHR_EVENT_MUX_OUT: QEMUChrEvent = 3;
pub const QEMUChrEvent_CHR_EVENT_CLOSED: QEMUChrEvent = 4;
pub type QEMUChrEvent = core::ffi::c_uint;
pub const ChardevFeature_QEMU_CHAR_FEATURE_RECONNECTABLE: ChardevFeature = 0;
pub const ChardevFeature_QEMU_CHAR_FEATURE_FD_PASS: ChardevFeature = 1;
pub const ChardevFeature_QEMU_CHAR_FEATURE_REPLAY: ChardevFeature = 2;
pub const ChardevFeature_QEMU_CHAR_FEATURE_GCONTEXT: ChardevFeature = 3;
pub const ChardevFeature_QEMU_CHAR_FEATURE_LAST: ChardevFeature = 4;
pub type ChardevFeature = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Chardev {
    pub parent_obj: Object,
    pub chr_write_lock: QemuMutex,
    pub be: *mut CharBackend,
    pub label: *mut core::ffi::c_char,
    pub filename: *mut core::ffi::c_char,
    pub logfd: core::ffi::c_int,
    pub be_open: core::ffi::c_int,
    pub handover_yank_instance: bool,
    pub gsource: *mut GSource,
    pub gcontext: *mut GMainContext,
    pub features: [core::ffi::c_ulong; 1usize],
}
#[test]
fn bindgen_test_layout_Chardev() {
    const UNINIT: ::core::mem::MaybeUninit<Chardev> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Chardev>(),
        160usize,
        concat!("Size of: ", stringify!(Chardev))
    );
    assert_eq!(
        ::core::mem::align_of::<Chardev>(),
        8usize,
        concat!("Alignment of ", stringify!(Chardev))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Chardev),
            "::",
            stringify!(parent_obj)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_write_lock) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Chardev),
            "::",
            stringify!(chr_write_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).be) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Chardev),
            "::",
            stringify!(be)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).label) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Chardev),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Chardev),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).logfd) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Chardev),
            "::",
            stringify!(logfd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).be_open) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(Chardev),
            "::",
            stringify!(be_open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handover_yank_instance) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Chardev),
            "::",
            stringify!(handover_yank_instance)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gsource) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Chardev),
            "::",
            stringify!(gsource)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gcontext) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Chardev),
            "::",
            stringify!(gcontext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).features) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Chardev),
            "::",
            stringify!(features)
        )
    );
}
impl Default for Chardev {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for Chardev {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "Chardev {{ parent_obj: {:?}, chr_write_lock: {:?}, be: {:?}, label: {:?}, filename: {:?}, logfd: {:?}, be_open: {:?}, handover_yank_instance: {:?}, gsource: {:?}, gcontext: {:?}, features: {:?} }}" , self . parent_obj , self . chr_write_lock , self . be , self . label , self . filename , self . logfd , self . be_open , self . handover_yank_instance , self . gsource , self . gcontext , self . features)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ChardevClass {
    pub parent_class: ObjectClass,
    pub internal: bool,
    pub supports_yank: bool,
    pub parse: ::core::option::Option<
        unsafe extern "C" fn(
            opts: *mut QemuOpts,
            backend: *mut ChardevBackend,
            errp: *mut *mut Error,
        ),
    >,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(
            chr: *mut Chardev,
            backend: *mut ChardevBackend,
            be_opened: *mut bool,
            errp: *mut *mut Error,
        ),
    >,
    pub chr_write: ::core::option::Option<
        unsafe extern "C" fn(
            s: *mut Chardev,
            buf: *const u8,
            len: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub chr_sync_read: ::core::option::Option<
        unsafe extern "C" fn(
            s: *mut Chardev,
            buf: *const u8,
            len: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub chr_add_watch: ::core::option::Option<
        unsafe extern "C" fn(s: *mut Chardev, cond: GIOCondition) -> *mut GSource,
    >,
    pub chr_update_read_handler: ::core::option::Option<unsafe extern "C" fn(s: *mut Chardev)>,
    pub chr_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            s: *mut Chardev,
            cmd: core::ffi::c_int,
            arg: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub get_msgfds: ::core::option::Option<
        unsafe extern "C" fn(
            s: *mut Chardev,
            fds: *mut core::ffi::c_int,
            num: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub set_msgfds: ::core::option::Option<
        unsafe extern "C" fn(
            s: *mut Chardev,
            fds: *mut core::ffi::c_int,
            num: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub chr_add_client: ::core::option::Option<
        unsafe extern "C" fn(chr: *mut Chardev, fd: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub chr_wait_connected: ::core::option::Option<
        unsafe extern "C" fn(chr: *mut Chardev, errp: *mut *mut Error) -> core::ffi::c_int,
    >,
    pub chr_disconnect: ::core::option::Option<unsafe extern "C" fn(chr: *mut Chardev)>,
    pub chr_accept_input: ::core::option::Option<unsafe extern "C" fn(chr: *mut Chardev)>,
    pub chr_set_echo: ::core::option::Option<unsafe extern "C" fn(chr: *mut Chardev, echo: bool)>,
    pub chr_set_fe_open:
        ::core::option::Option<unsafe extern "C" fn(chr: *mut Chardev, fe_open: core::ffi::c_int)>,
    pub chr_be_event:
        ::core::option::Option<unsafe extern "C" fn(s: *mut Chardev, event: QEMUChrEvent)>,
}
#[test]
fn bindgen_test_layout_ChardevClass() {
    const UNINIT: ::core::mem::MaybeUninit<ChardevClass> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ChardevClass>(),
        232usize,
        concat!("Size of: ", stringify!(ChardevClass))
    );
    assert_eq!(
        ::core::mem::align_of::<ChardevClass>(),
        8usize,
        concat!("Alignment of ", stringify!(ChardevClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supports_yank) as usize - ptr as usize },
        97usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(supports_yank)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parse) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_write) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_sync_read) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_sync_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_add_watch) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_add_watch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_update_read_handler) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_update_read_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_ioctl) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_ioctl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_msgfds) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(get_msgfds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_msgfds) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(set_msgfds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_add_client) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_add_client)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_wait_connected) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_wait_connected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_disconnect) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_disconnect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_accept_input) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_accept_input)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_set_echo) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_set_echo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_set_fe_open) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_set_fe_open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_be_event) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ChardevClass),
            "::",
            stringify!(chr_be_event)
        )
    );
}
impl Default for ChardevClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Coroutine {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoMutex {
    _unused: [u8; 0],
}
pub type CoroutineEntry =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct EventNotifier {
    pub rfd: core::ffi::c_int,
    pub wfd: core::ffi::c_int,
    pub initialized: bool,
}
#[test]
fn bindgen_test_layout_EventNotifier() {
    const UNINIT: ::core::mem::MaybeUninit<EventNotifier> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EventNotifier>(),
        12usize,
        concat!("Size of: ", stringify!(EventNotifier))
    );
    assert_eq!(
        ::core::mem::align_of::<EventNotifier>(),
        4usize,
        concat!("Alignment of ", stringify!(EventNotifier))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rfd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EventNotifier),
            "::",
            stringify!(rfd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wfd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EventNotifier),
            "::",
            stringify!(wfd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initialized) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(EventNotifier),
            "::",
            stringify!(initialized)
        )
    );
}
pub type EventNotifierHandler =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut EventNotifier)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BdrvGraphRWlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct BdrvGraphLock {}
#[test]
fn bindgen_test_layout_BdrvGraphLock() {
    assert_eq!(
        ::core::mem::size_of::<BdrvGraphLock>(),
        0usize,
        concat!("Size of: ", stringify!(BdrvGraphLock))
    );
    assert_eq!(
        ::core::mem::align_of::<BdrvGraphLock>(),
        1usize,
        concat!("Alignment of ", stringify!(BdrvGraphLock))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GraphLockable {}
#[test]
fn bindgen_test_layout_GraphLockable() {
    assert_eq!(
        ::core::mem::size_of::<GraphLockable>(),
        0usize,
        concat!("Size of: ", stringify!(GraphLockable))
    );
    assert_eq!(
        ::core::mem::align_of::<GraphLockable>(),
        1usize,
        concat!("Alignment of ", stringify!(GraphLockable))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GraphLockableMainloop {}
#[test]
fn bindgen_test_layout_GraphLockableMainloop() {
    assert_eq!(
        ::core::mem::size_of::<GraphLockableMainloop>(),
        0usize,
        concat!("Size of: ", stringify!(GraphLockableMainloop))
    );
    assert_eq!(
        ::core::mem::align_of::<GraphLockableMainloop>(),
        1usize,
        concat!("Alignment of ", stringify!(GraphLockableMainloop))
    );
}
pub type BlockCompletionFunc = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut core::ffi::c_void, ret: core::ffi::c_int),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AIOCBInfo {
    pub cancel_async: ::core::option::Option<unsafe extern "C" fn(acb: *mut BlockAIOCB)>,
    pub aiocb_size: usize,
}
#[test]
fn bindgen_test_layout_AIOCBInfo() {
    const UNINIT: ::core::mem::MaybeUninit<AIOCBInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AIOCBInfo>(),
        16usize,
        concat!("Size of: ", stringify!(AIOCBInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<AIOCBInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AIOCBInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cancel_async) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AIOCBInfo),
            "::",
            stringify!(cancel_async)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aiocb_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AIOCBInfo),
            "::",
            stringify!(aiocb_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockAIOCB {
    pub aiocb_info: *const AIOCBInfo,
    pub bs: *mut BlockDriverState,
    pub cb: BlockCompletionFunc,
    pub opaque: *mut core::ffi::c_void,
    pub refcnt: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_BlockAIOCB() {
    const UNINIT: ::core::mem::MaybeUninit<BlockAIOCB> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BlockAIOCB>(),
        40usize,
        concat!("Size of: ", stringify!(BlockAIOCB))
    );
    assert_eq!(
        ::core::mem::align_of::<BlockAIOCB>(),
        8usize,
        concat!("Alignment of ", stringify!(BlockAIOCB))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aiocb_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BlockAIOCB),
            "::",
            stringify!(aiocb_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BlockAIOCB),
            "::",
            stringify!(bs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cb) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BlockAIOCB),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BlockAIOCB),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refcnt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BlockAIOCB),
            "::",
            stringify!(refcnt)
        )
    );
}
impl Default for BlockAIOCB {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AioHandler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AioHandlerList {
    pub lh_first: *mut AioHandler,
}
#[test]
fn bindgen_test_layout_AioHandlerList() {
    const UNINIT: ::core::mem::MaybeUninit<AioHandlerList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AioHandlerList>(),
        8usize,
        concat!("Size of: ", stringify!(AioHandlerList))
    );
    assert_eq!(
        ::core::mem::align_of::<AioHandlerList>(),
        8usize,
        concat!("Alignment of ", stringify!(AioHandlerList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AioHandlerList),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for AioHandlerList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type QEMUBHFunc = ::core::option::Option<unsafe extern "C" fn(opaque: *mut core::ffi::c_void)>;
pub type AioPollFn =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut core::ffi::c_void) -> bool>;
pub type IOHandler = ::core::option::Option<unsafe extern "C" fn(opaque: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ThreadPool {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LinuxAioState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LuringState {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FDMonOps {
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut AioContext,
            old_node: *mut AioHandler,
            new_node: *mut AioHandler,
        ),
    >,
    pub wait: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut AioContext,
            ready_list: *mut AioHandlerList,
            timeout: i64,
        ) -> core::ffi::c_int,
    >,
    pub need_wait: ::core::option::Option<unsafe extern "C" fn(ctx: *mut AioContext) -> bool>,
}
#[test]
fn bindgen_test_layout_FDMonOps() {
    const UNINIT: ::core::mem::MaybeUninit<FDMonOps> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FDMonOps>(),
        24usize,
        concat!("Size of: ", stringify!(FDMonOps))
    );
    assert_eq!(
        ::core::mem::align_of::<FDMonOps>(),
        8usize,
        concat!("Alignment of ", stringify!(FDMonOps))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FDMonOps),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FDMonOps),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).need_wait) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FDMonOps),
            "::",
            stringify!(need_wait)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BHList {
    pub slh_first: *mut QEMUBH,
}
#[test]
fn bindgen_test_layout_BHList() {
    const UNINIT: ::core::mem::MaybeUninit<BHList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BHList>(),
        8usize,
        concat!("Size of: ", stringify!(BHList))
    );
    assert_eq!(
        ::core::mem::align_of::<BHList>(),
        8usize,
        concat!("Alignment of ", stringify!(BHList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BHList),
            "::",
            stringify!(slh_first)
        )
    );
}
impl Default for BHList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BHListSlice {
    pub bh_list: BHList,
    pub next: BHListSlice__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BHListSlice__bindgen_ty_1 {
    pub sqe_next: *mut BHListSlice,
}
#[test]
fn bindgen_test_layout_BHListSlice__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<BHListSlice__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BHListSlice__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(BHListSlice__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<BHListSlice__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(BHListSlice__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sqe_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BHListSlice__bindgen_ty_1),
            "::",
            stringify!(sqe_next)
        )
    );
}
impl Default for BHListSlice__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_BHListSlice() {
    const UNINIT: ::core::mem::MaybeUninit<BHListSlice> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<BHListSlice>(),
        16usize,
        concat!("Size of: ", stringify!(BHListSlice))
    );
    assert_eq!(
        ::core::mem::align_of::<BHListSlice>(),
        8usize,
        concat!("Alignment of ", stringify!(BHListSlice))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bh_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BHListSlice),
            "::",
            stringify!(bh_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BHListSlice),
            "::",
            stringify!(next)
        )
    );
}
impl Default for BHListSlice {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AioHandlerSList {
    pub slh_first: *mut AioHandler,
}
#[test]
fn bindgen_test_layout_AioHandlerSList() {
    const UNINIT: ::core::mem::MaybeUninit<AioHandlerSList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AioHandlerSList>(),
        8usize,
        concat!("Size of: ", stringify!(AioHandlerSList))
    );
    assert_eq!(
        ::core::mem::align_of::<AioHandlerSList>(),
        8usize,
        concat!("Alignment of ", stringify!(AioHandlerSList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AioHandlerSList),
            "::",
            stringify!(slh_first)
        )
    );
}
impl Default for AioHandlerSList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AioContext {
    pub source: GSource,
    pub lock: QemuRecMutex,
    pub bdrv_graph: *mut BdrvGraphRWlock,
    pub aio_handlers: AioHandlerList,
    pub deleted_aio_handlers: AioHandlerList,
    pub notify_me: u32,
    pub list_lock: QemuLockCnt,
    pub bh_list: BHList,
    pub bh_slice_list: AioContext__bindgen_ty_1,
    pub notified: bool,
    pub notifier: EventNotifier,
    pub scheduled_coroutines: AioContext__bindgen_ty_2,
    pub co_schedule_bh: *mut QEMUBH,
    pub thread_pool_min: core::ffi::c_int,
    pub thread_pool_max: core::ffi::c_int,
    pub thread_pool: *mut ThreadPool,
    pub tlg: QEMUTimerListGroup,
    pub poll_disable_cnt: core::ffi::c_int,
    pub poll_ns: i64,
    pub poll_max_ns: i64,
    pub poll_grow: i64,
    pub poll_shrink: i64,
    pub aio_max_batch: i64,
    pub poll_aio_handlers: AioHandlerList,
    pub poll_started: bool,
    pub epollfd: core::ffi::c_int,
    pub fdmon_ops: *const FDMonOps,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AioContext__bindgen_ty_1 {
    pub sqh_first: *mut BHListSlice,
    pub sqh_last: *mut *mut BHListSlice,
}
#[test]
fn bindgen_test_layout_AioContext__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<AioContext__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AioContext__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(AioContext__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AioContext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AioContext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sqh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext__bindgen_ty_1),
            "::",
            stringify!(sqh_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sqh_last) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext__bindgen_ty_1),
            "::",
            stringify!(sqh_last)
        )
    );
}
impl Default for AioContext__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AioContext__bindgen_ty_2 {
    pub slh_first: *mut Coroutine,
}
#[test]
fn bindgen_test_layout_AioContext__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<AioContext__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AioContext__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(AioContext__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AioContext__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(AioContext__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext__bindgen_ty_2),
            "::",
            stringify!(slh_first)
        )
    );
}
impl Default for AioContext__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_AioContext() {
    const UNINIT: ::core::mem::MaybeUninit<AioContext> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AioContext>(),
        360usize,
        concat!("Size of: ", stringify!(AioContext))
    );
    assert_eq!(
        ::core::mem::align_of::<AioContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AioContext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bdrv_graph) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(bdrv_graph)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aio_handlers) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(aio_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deleted_aio_handlers) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(deleted_aio_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify_me) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(notify_me)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list_lock) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(list_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bh_list) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(bh_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bh_slice_list) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(bh_slice_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notified) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(notified)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notifier) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(notifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scheduled_coroutines) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(scheduled_coroutines)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).co_schedule_bh) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(co_schedule_bh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_pool_min) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(thread_pool_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_pool_max) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(thread_pool_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_pool) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(thread_pool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tlg) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(tlg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll_disable_cnt) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(poll_disable_cnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll_ns) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(poll_ns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll_max_ns) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(poll_max_ns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll_grow) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(poll_grow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll_shrink) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(poll_shrink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aio_max_batch) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(aio_max_batch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll_aio_handlers) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(poll_aio_handlers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).poll_started) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(poll_started)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).epollfd) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(epollfd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fdmon_ops) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AioContext),
            "::",
            stringify!(fdmon_ops)
        )
    );
}
impl Default for AioContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for AioContext {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "AioContext {{ source: {:?}, lock: {:?}, bdrv_graph: {:?}, aio_handlers: {:?}, deleted_aio_handlers: {:?}, notify_me: {:?}, list_lock: {:?}, bh_list: {:?}, bh_slice_list: {:?}, notified: {:?}, notifier: {:?}, scheduled_coroutines: {:?}, co_schedule_bh: {:?}, thread_pool_min: {:?}, thread_pool_max: {:?}, thread_pool: {:?}, tlg: {:?}, poll_disable_cnt: {:?}, poll_ns: {:?}, poll_max_ns: {:?}, poll_grow: {:?}, poll_shrink: {:?}, aio_max_batch: {:?}, poll_aio_handlers: {:?}, poll_started: {:?}, epollfd: {:?}, fdmon_ops: {:?} }}" , self . source , self . lock , self . bdrv_graph , self . aio_handlers , self . deleted_aio_handlers , self . notify_me , self . list_lock , self . bh_list , self . bh_slice_list , self . notified , self . notifier , self . scheduled_coroutines , self . co_schedule_bh , self . thread_pool_min , self . thread_pool_max , self . thread_pool , self . tlg , self . poll_disable_cnt , self . poll_ns , self . poll_max_ns , self . poll_grow , self . poll_shrink , self . aio_max_batch , self . poll_aio_handlers , self . poll_started , self . epollfd , self . fdmon_ops)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventLoopBaseClass {
    pub parent_class: ObjectClass,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(base: *mut EventLoopBase, errp: *mut *mut Error),
    >,
    pub update_params: ::core::option::Option<
        unsafe extern "C" fn(base: *mut EventLoopBase, errp: *mut *mut Error),
    >,
    pub can_be_deleted:
        ::core::option::Option<unsafe extern "C" fn(base: *mut EventLoopBase) -> bool>,
}
#[test]
fn bindgen_test_layout_EventLoopBaseClass() {
    const UNINIT: ::core::mem::MaybeUninit<EventLoopBaseClass> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EventLoopBaseClass>(),
        120usize,
        concat!("Size of: ", stringify!(EventLoopBaseClass))
    );
    assert_eq!(
        ::core::mem::align_of::<EventLoopBaseClass>(),
        8usize,
        concat!("Alignment of ", stringify!(EventLoopBaseClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EventLoopBaseClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(EventLoopBaseClass),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).update_params) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(EventLoopBaseClass),
            "::",
            stringify!(update_params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).can_be_deleted) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(EventLoopBaseClass),
            "::",
            stringify!(can_be_deleted)
        )
    );
}
impl Default for EventLoopBaseClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventLoopBase {
    pub parent: Object,
    pub aio_max_batch: i64,
    pub thread_pool_min: i64,
    pub thread_pool_max: i64,
}
#[test]
fn bindgen_test_layout_EventLoopBase() {
    const UNINIT: ::core::mem::MaybeUninit<EventLoopBase> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EventLoopBase>(),
        64usize,
        concat!("Size of: ", stringify!(EventLoopBase))
    );
    assert_eq!(
        ::core::mem::align_of::<EventLoopBase>(),
        8usize,
        concat!("Alignment of ", stringify!(EventLoopBase))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EventLoopBase),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aio_max_batch) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(EventLoopBase),
            "::",
            stringify!(aio_max_batch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_pool_min) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(EventLoopBase),
            "::",
            stringify!(thread_pool_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_pool_max) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(EventLoopBase),
            "::",
            stringify!(thread_pool_max)
        )
    );
}
impl Default for EventLoopBase {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MainLoopClass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MainLoop {
    pub parent_obj: EventLoopBase,
}
#[test]
fn bindgen_test_layout_MainLoop() {
    const UNINIT: ::core::mem::MaybeUninit<MainLoop> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MainLoop>(),
        64usize,
        concat!("Size of: ", stringify!(MainLoop))
    );
    assert_eq!(
        ::core::mem::align_of::<MainLoop>(),
        8usize,
        concat!("Alignment of ", stringify!(MainLoop))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MainLoop),
            "::",
            stringify!(parent_obj)
        )
    );
}
impl Default for MainLoop {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IOReadHandler = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut core::ffi::c_void, buf: *const u8, size: core::ffi::c_int),
>;
pub type IOCanReadHandler = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut core::ffi::c_void) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BQLLockAuto {
    _unused: [u8; 0],
}
pub const MAIN_LOOP_POLL_FILL: _bindgen_ty_36 = 0;
pub const MAIN_LOOP_POLL_ERR: _bindgen_ty_36 = 1;
pub const MAIN_LOOP_POLL_OK: _bindgen_ty_36 = 2;
pub type _bindgen_ty_36 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MainLoopPoll {
    pub state: core::ffi::c_int,
    pub timeout: u32,
    pub pollfds: *mut GArray,
}
#[test]
fn bindgen_test_layout_MainLoopPoll() {
    const UNINIT: ::core::mem::MaybeUninit<MainLoopPoll> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MainLoopPoll>(),
        16usize,
        concat!("Size of: ", stringify!(MainLoopPoll))
    );
    assert_eq!(
        ::core::mem::align_of::<MainLoopPoll>(),
        8usize,
        concat!("Alignment of ", stringify!(MainLoopPoll))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MainLoopPoll),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MainLoopPoll),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pollfds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MainLoopPoll),
            "::",
            stringify!(pollfds)
        )
    );
}
impl Default for MainLoopPoll {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type IOEventHandler = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut core::ffi::c_void, event: QEMUChrEvent),
>;
pub type BackendChangeHandler = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut core::ffi::c_void) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CharBackend {
    pub chr: *mut Chardev,
    pub chr_event: IOEventHandler,
    pub chr_can_read: IOCanReadHandler,
    pub chr_read: IOReadHandler,
    pub chr_be_change: BackendChangeHandler,
    pub opaque: *mut core::ffi::c_void,
    pub tag: core::ffi::c_int,
    pub fe_is_open: bool,
}
#[test]
fn bindgen_test_layout_CharBackend() {
    const UNINIT: ::core::mem::MaybeUninit<CharBackend> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CharBackend>(),
        56usize,
        concat!("Size of: ", stringify!(CharBackend))
    );
    assert_eq!(
        ::core::mem::align_of::<CharBackend>(),
        8usize,
        concat!("Alignment of ", stringify!(CharBackend))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CharBackend),
            "::",
            stringify!(chr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_event) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CharBackend),
            "::",
            stringify!(chr_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_can_read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CharBackend),
            "::",
            stringify!(chr_can_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_read) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CharBackend),
            "::",
            stringify!(chr_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chr_be_change) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CharBackend),
            "::",
            stringify!(chr_be_change)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CharBackend),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CharBackend),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fe_is_open) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CharBackend),
            "::",
            stringify!(fe_is_open)
        )
    );
}
impl Default for CharBackend {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FEWatchFunc = ::core::option::Option<
    unsafe extern "C" fn(
        do_not_use: *mut core::ffi::c_void,
        condition: GIOCondition,
        data: *mut core::ffi::c_void,
    ) -> gboolean,
>;
pub const ClockEvent_ClockUpdate: ClockEvent = 1;
pub const ClockEvent_ClockPreUpdate: ClockEvent = 2;
pub type ClockEvent = core::ffi::c_uint;
pub type ClockCallback =
    ::core::option::Option<unsafe extern "C" fn(opaque: *mut core::ffi::c_void, event: ClockEvent)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Clock {
    pub parent_obj: Object,
    pub period: u64,
    pub canonical_path: *mut core::ffi::c_char,
    pub callback: ClockCallback,
    pub callback_opaque: *mut core::ffi::c_void,
    pub callback_events: core::ffi::c_uint,
    pub multiplier: u32,
    pub divider: u32,
    pub source: *mut Clock,
    pub children: Clock__bindgen_ty_1,
    pub sibling: Clock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Clock__bindgen_ty_1 {
    pub lh_first: *mut Clock,
}
#[test]
fn bindgen_test_layout_Clock__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<Clock__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Clock__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(Clock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<Clock__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Clock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lh_first) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock__bindgen_ty_1),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Default for Clock__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Clock__bindgen_ty_2 {
    pub le_next: *mut Clock,
    pub le_prev: *mut *mut Clock,
}
#[test]
fn bindgen_test_layout_Clock__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<Clock__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Clock__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(Clock__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<Clock__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(Clock__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock__bindgen_ty_2),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_prev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock__bindgen_ty_2),
            "::",
            stringify!(le_prev)
        )
    );
}
impl Default for Clock__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_Clock() {
    const UNINIT: ::core::mem::MaybeUninit<Clock> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Clock>(),
        120usize,
        concat!("Size of: ", stringify!(Clock))
    );
    assert_eq!(
        ::core::mem::align_of::<Clock>(),
        8usize,
        concat!("Alignment of ", stringify!(Clock))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_obj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock),
            "::",
            stringify!(parent_obj)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).canonical_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock),
            "::",
            stringify!(canonical_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_opaque) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock),
            "::",
            stringify!(callback_opaque)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_events) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock),
            "::",
            stringify!(callback_events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).multiplier) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock),
            "::",
            stringify!(multiplier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).divider) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock),
            "::",
            stringify!(divider)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock),
            "::",
            stringify!(children)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sibling) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Clock),
            "::",
            stringify!(sibling)
        )
    );
}
impl Default for Clock {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClockPortInitElem {
    pub name: *const core::ffi::c_char,
    pub is_output: bool,
    pub callback: ClockCallback,
    pub callback_events: core::ffi::c_uint,
    pub offset: usize,
}
#[test]
fn bindgen_test_layout_ClockPortInitElem() {
    const UNINIT: ::core::mem::MaybeUninit<ClockPortInitElem> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ClockPortInitElem>(),
        40usize,
        concat!("Size of: ", stringify!(ClockPortInitElem))
    );
    assert_eq!(
        ::core::mem::align_of::<ClockPortInitElem>(),
        8usize,
        concat!("Alignment of ", stringify!(ClockPortInitElem))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClockPortInitElem),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_output) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClockPortInitElem),
            "::",
            stringify!(is_output)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClockPortInitElem),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_events) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClockPortInitElem),
            "::",
            stringify!(callback_events)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ClockPortInitElem),
            "::",
            stringify!(offset)
        )
    );
}
impl Default for ClockPortInitElem {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ClockPortInitArray = [ClockPortInitElem; 0usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Property {
    pub name: *const core::ffi::c_char,
    pub info: *const PropertyInfo,
    pub offset: isize,
    pub bitnr: u8,
    pub bitmask: u64,
    pub set_default: bool,
    pub defval: Property__bindgen_ty_1,
    pub arrayoffset: core::ffi::c_int,
    pub arrayinfo: *const PropertyInfo,
    pub arrayfieldsize: core::ffi::c_int,
    pub link_type: *const core::ffi::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Property__bindgen_ty_1 {
    pub i: i64,
    pub u: u64,
}
#[test]
fn bindgen_test_layout_Property__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<Property__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Property__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(Property__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<Property__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Property__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Property__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Property__bindgen_ty_1),
            "::",
            stringify!(u)
        )
    );
}
impl Default for Property__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for Property__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "Property__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_Property() {
    const UNINIT: ::core::mem::MaybeUninit<Property> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Property>(),
        88usize,
        concat!("Size of: ", stringify!(Property))
    );
    assert_eq!(
        ::core::mem::align_of::<Property>(),
        8usize,
        concat!("Alignment of ", stringify!(Property))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitnr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(bitnr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(bitmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_default) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(set_default)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).defval) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(defval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arrayoffset) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(arrayoffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arrayinfo) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(arrayinfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arrayfieldsize) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(arrayfieldsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).link_type) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(link_type)
        )
    );
}
impl Default for Property {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ::core::fmt::Debug for Property {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "Property {{ name: {:?}, info: {:?}, offset: {:?}, bitnr: {:?}, bitmask: {:?}, set_default: {:?}, defval: {:?}, arrayoffset: {:?}, arrayinfo: {:?}, arrayfieldsize: {:?}, link_type: {:?} }}" , self . name , self . info , self . offset , self . bitnr , self . bitmask , self . set_default , self . defval , self . arrayoffset , self . arrayinfo , self . arrayfieldsize , self . link_type)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PropertyInfo {
    pub name: *const core::ffi::c_char,
    pub description: *const core::ffi::c_char,
    pub enum_table: *const QEnumLookup,
    pub realized_set_allowed: bool,
    pub print: ::core::option::Option<
        unsafe extern "C" fn(
            obj: *mut Object,
            prop: *mut Property,
            dest: *mut core::ffi::c_char,
            len: usize,
        ) -> core::ffi::c_int,
    >,
    pub set_default_value: ::core::option::Option<
        unsafe extern "C" fn(op: *mut ObjectProperty, prop: *const Property),
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            oc: *mut ObjectClass,
            name: *const core::ffi::c_char,
            prop: *mut Property,
        ) -> *mut ObjectProperty,
    >,
    pub get: ObjectPropertyAccessor,
    pub set: ObjectPropertyAccessor,
    pub release: ObjectPropertyRelease,
}
#[test]
fn bindgen_test_layout_PropertyInfo() {
    const UNINIT: ::core::mem::MaybeUninit<PropertyInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PropertyInfo>(),
        80usize,
        concat!("Size of: ", stringify!(PropertyInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<PropertyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(PropertyInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyInfo),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enum_table) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyInfo),
            "::",
            stringify!(enum_table)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).realized_set_allowed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyInfo),
            "::",
            stringify!(realized_set_allowed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).print) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyInfo),
            "::",
            stringify!(print)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_default_value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyInfo),
            "::",
            stringify!(set_default_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyInfo),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyInfo),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyInfo),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PropertyInfo),
            "::",
            stringify!(release)
        )
    );
}
impl Default for PropertyInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const QapiErrorClass_QAPI_ERROR_CLASS_GENERICERROR: QapiErrorClass = 0;
pub const QapiErrorClass_QAPI_ERROR_CLASS_COMMANDNOTFOUND: QapiErrorClass = 1;
pub const QapiErrorClass_QAPI_ERROR_CLASS_DEVICENOTACTIVE: QapiErrorClass = 2;
pub const QapiErrorClass_QAPI_ERROR_CLASS_DEVICENOTFOUND: QapiErrorClass = 3;
pub const QapiErrorClass_QAPI_ERROR_CLASS_KVMMISSINGCAP: QapiErrorClass = 4;
pub const QapiErrorClass_QAPI_ERROR_CLASS__MAX: QapiErrorClass = 5;
pub type QapiErrorClass = core::ffi::c_uint;
pub const ErrorClass_ERROR_CLASS_GENERIC_ERROR: ErrorClass = 0;
pub const ErrorClass_ERROR_CLASS_COMMAND_NOT_FOUND: ErrorClass = 1;
pub const ErrorClass_ERROR_CLASS_DEVICE_NOT_ACTIVE: ErrorClass = 2;
pub const ErrorClass_ERROR_CLASS_DEVICE_NOT_FOUND: ErrorClass = 3;
pub const ErrorClass_ERROR_CLASS_KVM_MISSING_CAP: ErrorClass = 4;
pub type ErrorClass = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorPropagator {
    pub local_err: *mut Error,
    pub errp: *mut *mut Error,
}
#[test]
fn bindgen_test_layout_ErrorPropagator() {
    const UNINIT: ::core::mem::MaybeUninit<ErrorPropagator> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ErrorPropagator>(),
        16usize,
        concat!("Size of: ", stringify!(ErrorPropagator))
    );
    assert_eq!(
        ::core::mem::align_of::<ErrorPropagator>(),
        8usize,
        concat!("Alignment of ", stringify!(ErrorPropagator))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local_err) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorPropagator),
            "::",
            stringify!(local_err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ErrorPropagator),
            "::",
            stringify!(errp)
        )
    );
}
impl Default for ErrorPropagator {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VMStateIf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VMStateIfClass {
    pub parent_class: InterfaceClass,
    pub get_id:
        ::core::option::Option<unsafe extern "C" fn(obj: *mut VMStateIf) -> *mut core::ffi::c_char>,
}
#[test]
fn bindgen_test_layout_VMStateIfClass() {
    const UNINIT: ::core::mem::MaybeUninit<VMStateIfClass> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VMStateIfClass>(),
        120usize,
        concat!("Size of: ", stringify!(VMStateIfClass))
    );
    assert_eq!(
        ::core::mem::align_of::<VMStateIfClass>(),
        8usize,
        concat!("Alignment of ", stringify!(VMStateIfClass))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateIfClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateIfClass),
            "::",
            stringify!(get_id)
        )
    );
}
impl Default for VMStateIfClass {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VMStateInfo {
    pub name: *const core::ffi::c_char,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            f: *mut QEMUFile,
            pv: *mut core::ffi::c_void,
            size: usize,
            field: *const VMStateField,
        ) -> core::ffi::c_int,
    >,
    pub put: ::core::option::Option<
        unsafe extern "C" fn(
            f: *mut QEMUFile,
            pv: *mut core::ffi::c_void,
            size: usize,
            field: *const VMStateField,
            vmdesc: *mut JSONWriter,
        ) -> core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout_VMStateInfo() {
    const UNINIT: ::core::mem::MaybeUninit<VMStateInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VMStateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(VMStateInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<VMStateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VMStateInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateInfo),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).put) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateInfo),
            "::",
            stringify!(put)
        )
    );
}
impl Default for VMStateInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const VMStateFlags_VMS_SINGLE: VMStateFlags = 1;
pub const VMStateFlags_VMS_POINTER: VMStateFlags = 2;
pub const VMStateFlags_VMS_ARRAY: VMStateFlags = 4;
pub const VMStateFlags_VMS_STRUCT: VMStateFlags = 8;
pub const VMStateFlags_VMS_VARRAY_INT32: VMStateFlags = 16;
pub const VMStateFlags_VMS_BUFFER: VMStateFlags = 32;
pub const VMStateFlags_VMS_ARRAY_OF_POINTER: VMStateFlags = 64;
pub const VMStateFlags_VMS_VARRAY_UINT16: VMStateFlags = 128;
pub const VMStateFlags_VMS_VBUFFER: VMStateFlags = 256;
pub const VMStateFlags_VMS_MULTIPLY: VMStateFlags = 512;
pub const VMStateFlags_VMS_VARRAY_UINT8: VMStateFlags = 1024;
pub const VMStateFlags_VMS_VARRAY_UINT32: VMStateFlags = 2048;
pub const VMStateFlags_VMS_MUST_EXIST: VMStateFlags = 4096;
pub const VMStateFlags_VMS_ALLOC: VMStateFlags = 8192;
pub const VMStateFlags_VMS_MULTIPLY_ELEMENTS: VMStateFlags = 16384;
pub const VMStateFlags_VMS_VSTRUCT: VMStateFlags = 32768;
pub const VMStateFlags_VMS_END: VMStateFlags = 65536;
pub type VMStateFlags = core::ffi::c_uint;
pub const MigrationPriority_MIG_PRI_DEFAULT: MigrationPriority = 0;
pub const MigrationPriority_MIG_PRI_IOMMU: MigrationPriority = 1;
pub const MigrationPriority_MIG_PRI_PCI_BUS: MigrationPriority = 2;
pub const MigrationPriority_MIG_PRI_VIRTIO_MEM: MigrationPriority = 3;
pub const MigrationPriority_MIG_PRI_GICV3_ITS: MigrationPriority = 4;
pub const MigrationPriority_MIG_PRI_GICV3: MigrationPriority = 5;
pub const MigrationPriority_MIG_PRI_MAX: MigrationPriority = 6;
pub type MigrationPriority = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VMStateField {
    pub name: *const core::ffi::c_char,
    pub err_hint: *const core::ffi::c_char,
    pub offset: usize,
    pub size: usize,
    pub start: usize,
    pub num: core::ffi::c_int,
    pub num_offset: usize,
    pub size_offset: usize,
    pub info: *const VMStateInfo,
    pub flags: VMStateFlags,
    pub vmsd: *const VMStateDescription,
    pub version_id: core::ffi::c_int,
    pub struct_version_id: core::ffi::c_int,
    pub field_exists: ::core::option::Option<
        unsafe extern "C" fn(opaque: *mut core::ffi::c_void, version_id: core::ffi::c_int) -> bool,
    >,
}
#[test]
fn bindgen_test_layout_VMStateField() {
    const UNINIT: ::core::mem::MaybeUninit<VMStateField> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VMStateField>(),
        104usize,
        concat!("Size of: ", stringify!(VMStateField))
    );
    assert_eq!(
        ::core::mem::align_of::<VMStateField>(),
        8usize,
        concat!("Alignment of ", stringify!(VMStateField))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err_hint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(err_hint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_offset) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(num_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_offset) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(size_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vmsd) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(vmsd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version_id) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(version_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).struct_version_id) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(struct_version_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).field_exists) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateField),
            "::",
            stringify!(field_exists)
        )
    );
}
impl Default for VMStateField {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VMStateDescription {
    pub name: *const core::ffi::c_char,
    pub unmigratable: bool,
    pub early_setup: bool,
    pub version_id: core::ffi::c_int,
    pub minimum_version_id: core::ffi::c_int,
    pub priority: MigrationPriority,
    pub pre_load: ::core::option::Option<
        unsafe extern "C" fn(opaque: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub post_load: ::core::option::Option<
        unsafe extern "C" fn(
            opaque: *mut core::ffi::c_void,
            version_id: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub pre_save: ::core::option::Option<
        unsafe extern "C" fn(opaque: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub post_save: ::core::option::Option<
        unsafe extern "C" fn(opaque: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub needed:
        ::core::option::Option<unsafe extern "C" fn(opaque: *mut core::ffi::c_void) -> bool>,
    pub dev_unplug_pending:
        ::core::option::Option<unsafe extern "C" fn(opaque: *mut core::ffi::c_void) -> bool>,
    pub fields: *const VMStateField,
    pub subsections: *const *const VMStateDescription,
}
#[test]
fn bindgen_test_layout_VMStateDescription() {
    const UNINIT: ::core::mem::MaybeUninit<VMStateDescription> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<VMStateDescription>(),
        88usize,
        concat!("Size of: ", stringify!(VMStateDescription))
    );
    assert_eq!(
        ::core::mem::align_of::<VMStateDescription>(),
        8usize,
        concat!("Alignment of ", stringify!(VMStateDescription))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unmigratable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(unmigratable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).early_setup) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(early_setup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(version_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minimum_version_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(minimum_version_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pre_load) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(pre_load)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).post_load) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(post_load)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pre_save) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(pre_save)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).post_save) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(post_save)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).needed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(needed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_unplug_pending) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(dev_unplug_pending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fields) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(fields)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subsections) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VMStateDescription),
            "::",
            stringify!(subsections)
        )
    );
}
impl Default for VMStateDescription {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QEMUSerialSetParams {
    pub speed: core::ffi::c_int,
    pub parity: core::ffi::c_int,
    pub data_bits: core::ffi::c_int,
    pub stop_bits: core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_QEMUSerialSetParams() {
    const UNINIT: ::core::mem::MaybeUninit<QEMUSerialSetParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<QEMUSerialSetParams>(),
        16usize,
        concat!("Size of: ", stringify!(QEMUSerialSetParams))
    );
    assert_eq!(
        ::core::mem::align_of::<QEMUSerialSetParams>(),
        4usize,
        concat!("Alignment of ", stringify!(QEMUSerialSetParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).speed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUSerialSetParams),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parity) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUSerialSetParams),
            "::",
            stringify!(parity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_bits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUSerialSetParams),
            "::",
            stringify!(data_bits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop_bits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(QEMUSerialSetParams),
            "::",
            stringify!(stop_bits)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: core::ffi::c_uint,
    pub fp_offset: core::ffi::c_uint,
    pub overflow_arg_area: *mut core::ffi::c_void,
    pub reg_save_area: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::core::mem::MaybeUninit<__va_list_tag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_at {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_ax25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_dl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_eon {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_inarp {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_ipx {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_iso {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_ns {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_x25 {
    pub _address: u8,
}
pub type __int128_t = i128;
pub type Int128Alias___uint128_t = u128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct kvm_dirty_gfn {
    pub _address: u8,
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
    pub fn atof(__nptr: *const core::ffi::c_char) -> f64;
    pub fn atoi(__nptr: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn atol(__nptr: *const core::ffi::c_char) -> core::ffi::c_long;
    pub fn atoll(__nptr: *const core::ffi::c_char) -> core::ffi::c_longlong;
    pub fn strtod(__nptr: *const core::ffi::c_char, __endptr: *mut *mut core::ffi::c_char) -> f64;
    pub fn strtof(__nptr: *const core::ffi::c_char, __endptr: *mut *mut core::ffi::c_char) -> f32;
    pub fn strtold(__nptr: *const core::ffi::c_char, __endptr: *mut *mut core::ffi::c_char)
        -> u128;
    pub fn strtof32(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
    ) -> _Float32;
    pub fn strtof64(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
    ) -> _Float64;
    pub fn strtof32x(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
    ) -> _Float32x;
    pub fn strtof64x(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
    ) -> _Float64x;
    pub fn strtol(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_long;
    pub fn strtoul(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
    pub fn strtoq(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_longlong;
    pub fn strtouq(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulonglong;
    pub fn strtoll(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_longlong;
    pub fn strtoull(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulonglong;
    pub fn strfromd(
        __dest: *mut core::ffi::c_char,
        __size: usize,
        __format: *const core::ffi::c_char,
        __f: f64,
    ) -> core::ffi::c_int;
    pub fn strfromf(
        __dest: *mut core::ffi::c_char,
        __size: usize,
        __format: *const core::ffi::c_char,
        __f: f32,
    ) -> core::ffi::c_int;
    pub fn strfroml(
        __dest: *mut core::ffi::c_char,
        __size: usize,
        __format: *const core::ffi::c_char,
        __f: u128,
    ) -> core::ffi::c_int;
    pub fn strfromf32(
        __dest: *mut core::ffi::c_char,
        __size: usize,
        __format: *const core::ffi::c_char,
        __f: _Float32,
    ) -> core::ffi::c_int;
    pub fn strfromf64(
        __dest: *mut core::ffi::c_char,
        __size: usize,
        __format: *const core::ffi::c_char,
        __f: _Float64,
    ) -> core::ffi::c_int;
    pub fn strfromf32x(
        __dest: *mut core::ffi::c_char,
        __size: usize,
        __format: *const core::ffi::c_char,
        __f: _Float32x,
    ) -> core::ffi::c_int;
    pub fn strfromf64x(
        __dest: *mut core::ffi::c_char,
        __size: usize,
        __format: *const core::ffi::c_char,
        __f: _Float64x,
    ) -> core::ffi::c_int;
    pub fn strtol_l(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
        __loc: locale_t,
    ) -> core::ffi::c_long;
    pub fn strtoul_l(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
        __loc: locale_t,
    ) -> core::ffi::c_ulong;
    pub fn strtoll_l(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
        __loc: locale_t,
    ) -> core::ffi::c_longlong;
    pub fn strtoull_l(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __base: core::ffi::c_int,
        __loc: locale_t,
    ) -> core::ffi::c_ulonglong;
    pub fn strtod_l(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __loc: locale_t,
    ) -> f64;
    pub fn strtof_l(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __loc: locale_t,
    ) -> f32;
    pub fn strtold_l(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __loc: locale_t,
    ) -> u128;
    pub fn strtof32_l(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __loc: locale_t,
    ) -> _Float32;
    pub fn strtof64_l(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __loc: locale_t,
    ) -> _Float64;
    pub fn strtof32x_l(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __loc: locale_t,
    ) -> _Float32x;
    pub fn strtof64x_l(
        __nptr: *const core::ffi::c_char,
        __endptr: *mut *mut core::ffi::c_char,
        __loc: locale_t,
    ) -> _Float64x;
    pub fn l64a(__n: core::ffi::c_long) -> *mut core::ffi::c_char;
    pub fn a64l(__s: *const core::ffi::c_char) -> core::ffi::c_long;
    pub fn random() -> core::ffi::c_long;
    pub fn srandom(__seed: core::ffi::c_uint);
    pub fn initstate(
        __seed: core::ffi::c_uint,
        __statebuf: *mut core::ffi::c_char,
        __statelen: usize,
    ) -> *mut core::ffi::c_char;
    pub fn setstate(__statebuf: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> core::ffi::c_int;
    pub fn srandom_r(__seed: core::ffi::c_uint, __buf: *mut random_data) -> core::ffi::c_int;
    pub fn initstate_r(
        __seed: core::ffi::c_uint,
        __statebuf: *mut core::ffi::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> core::ffi::c_int;
    pub fn setstate_r(
        __statebuf: *mut core::ffi::c_char,
        __buf: *mut random_data,
    ) -> core::ffi::c_int;
    pub fn rand() -> core::ffi::c_int;
    pub fn srand(__seed: core::ffi::c_uint);
    pub fn rand_r(__seed: *mut core::ffi::c_uint) -> core::ffi::c_int;
    pub fn drand48() -> f64;
    pub fn erand48(__xsubi: *mut core::ffi::c_ushort) -> f64;
    pub fn lrand48() -> core::ffi::c_long;
    pub fn nrand48(__xsubi: *mut core::ffi::c_ushort) -> core::ffi::c_long;
    pub fn mrand48() -> core::ffi::c_long;
    pub fn jrand48(__xsubi: *mut core::ffi::c_ushort) -> core::ffi::c_long;
    pub fn srand48(__seedval: core::ffi::c_long);
    pub fn seed48(__seed16v: *mut core::ffi::c_ushort) -> *mut core::ffi::c_ushort;
    pub fn lcong48(__param: *mut core::ffi::c_ushort);
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> core::ffi::c_int;
    pub fn erand48_r(
        __xsubi: *mut core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> core::ffi::c_int;
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut core::ffi::c_long,
    ) -> core::ffi::c_int;
    pub fn nrand48_r(
        __xsubi: *mut core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut core::ffi::c_long,
    ) -> core::ffi::c_int;
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut core::ffi::c_long,
    ) -> core::ffi::c_int;
    pub fn jrand48_r(
        __xsubi: *mut core::ffi::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut core::ffi::c_long,
    ) -> core::ffi::c_int;
    pub fn srand48_r(__seedval: core::ffi::c_long, __buffer: *mut drand48_data)
        -> core::ffi::c_int;
    pub fn seed48_r(
        __seed16v: *mut core::ffi::c_ushort,
        __buffer: *mut drand48_data,
    ) -> core::ffi::c_int;
    pub fn lcong48_r(
        __param: *mut core::ffi::c_ushort,
        __buffer: *mut drand48_data,
    ) -> core::ffi::c_int;
    pub fn arc4random() -> __uint32_t;
    pub fn arc4random_buf(__buf: *mut core::ffi::c_void, __size: usize);
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
    pub fn malloc(__size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
    pub fn calloc(
        __nmemb: core::ffi::c_ulong,
        __size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
    pub fn realloc(
        __ptr: *mut core::ffi::c_void,
        __size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
    pub fn free(__ptr: *mut core::ffi::c_void);
    pub fn reallocarray(
        __ptr: *mut core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut core::ffi::c_void;
    pub fn alloca(__size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
    pub fn valloc(__size: usize) -> *mut core::ffi::c_void;
    pub fn posix_memalign(
        __memptr: *mut *mut core::ffi::c_void,
        __alignment: usize,
        __size: usize,
    ) -> core::ffi::c_int;
    pub fn aligned_alloc(
        __alignment: core::ffi::c_ulong,
        __size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
    pub fn abort() -> !;
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> core::ffi::c_int;
    pub fn at_quick_exit(
        __func: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> core::ffi::c_int;
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: core::ffi::c_int, __arg: *mut core::ffi::c_void),
        >,
        __arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn exit(__status: core::ffi::c_int) -> !;
    pub fn quick_exit(__status: core::ffi::c_int) -> !;
    pub fn _Exit(__status: core::ffi::c_int) -> !;
    pub fn getenv(__name: *const core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn secure_getenv(__name: *const core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn putenv(__string: *mut core::ffi::c_char) -> core::ffi::c_int;
    pub fn setenv(
        __name: *const core::ffi::c_char,
        __value: *const core::ffi::c_char,
        __replace: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn unsetenv(__name: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn clearenv() -> core::ffi::c_int;
    pub fn mktemp(__template: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
    #[link_name = "\u{1}mkstemp64"]
    pub fn mkstemp(__template: *mut core::ffi::c_char) -> core::ffi::c_int;
    #[link_name = "\u{1}mkstemps64"]
    pub fn mkstemps(
        __template: *mut core::ffi::c_char,
        __suffixlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn mkdtemp(__template: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
    #[link_name = "\u{1}mkostemp64"]
    pub fn mkostemp(
        __template: *mut core::ffi::c_char,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    #[link_name = "\u{1}mkostemps64"]
    pub fn mkostemps(
        __template: *mut core::ffi::c_char,
        __suffixlen: core::ffi::c_int,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn system(__command: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn canonicalize_file_name(__name: *const core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn realpath(
        __name: *const core::ffi::c_char,
        __resolved: *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn bsearch(
        __key: *const core::ffi::c_void,
        __base: *const core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut core::ffi::c_void;
    pub fn qsort(
        __base: *mut core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
    pub fn qsort_r(
        __base: *mut core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_d_fn_t,
        __arg: *mut core::ffi::c_void,
    );
    pub fn abs(__x: core::ffi::c_int) -> core::ffi::c_int;
    pub fn labs(__x: core::ffi::c_long) -> core::ffi::c_long;
    pub fn llabs(__x: core::ffi::c_longlong) -> core::ffi::c_longlong;
    pub fn div(__numer: core::ffi::c_int, __denom: core::ffi::c_int) -> div_t;
    pub fn ldiv(__numer: core::ffi::c_long, __denom: core::ffi::c_long) -> ldiv_t;
    pub fn lldiv(__numer: core::ffi::c_longlong, __denom: core::ffi::c_longlong) -> lldiv_t;
    pub fn ecvt(
        __value: f64,
        __ndigit: core::ffi::c_int,
        __decpt: *mut core::ffi::c_int,
        __sign: *mut core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
    pub fn fcvt(
        __value: f64,
        __ndigit: core::ffi::c_int,
        __decpt: *mut core::ffi::c_int,
        __sign: *mut core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
    pub fn gcvt(
        __value: f64,
        __ndigit: core::ffi::c_int,
        __buf: *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn qecvt(
        __value: u128,
        __ndigit: core::ffi::c_int,
        __decpt: *mut core::ffi::c_int,
        __sign: *mut core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
    pub fn qfcvt(
        __value: u128,
        __ndigit: core::ffi::c_int,
        __decpt: *mut core::ffi::c_int,
        __sign: *mut core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
    pub fn qgcvt(
        __value: u128,
        __ndigit: core::ffi::c_int,
        __buf: *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn ecvt_r(
        __value: f64,
        __ndigit: core::ffi::c_int,
        __decpt: *mut core::ffi::c_int,
        __sign: *mut core::ffi::c_int,
        __buf: *mut core::ffi::c_char,
        __len: usize,
    ) -> core::ffi::c_int;
    pub fn fcvt_r(
        __value: f64,
        __ndigit: core::ffi::c_int,
        __decpt: *mut core::ffi::c_int,
        __sign: *mut core::ffi::c_int,
        __buf: *mut core::ffi::c_char,
        __len: usize,
    ) -> core::ffi::c_int;
    pub fn qecvt_r(
        __value: u128,
        __ndigit: core::ffi::c_int,
        __decpt: *mut core::ffi::c_int,
        __sign: *mut core::ffi::c_int,
        __buf: *mut core::ffi::c_char,
        __len: usize,
    ) -> core::ffi::c_int;
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: core::ffi::c_int,
        __decpt: *mut core::ffi::c_int,
        __sign: *mut core::ffi::c_int,
        __buf: *mut core::ffi::c_char,
        __len: usize,
    ) -> core::ffi::c_int;
    pub fn mblen(__s: *const core::ffi::c_char, __n: usize) -> core::ffi::c_int;
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const core::ffi::c_char,
        __n: usize,
    ) -> core::ffi::c_int;
    pub fn wctomb(__s: *mut core::ffi::c_char, __wchar: wchar_t) -> core::ffi::c_int;
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const core::ffi::c_char, __n: usize) -> usize;
    pub fn wcstombs(__s: *mut core::ffi::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
    pub fn rpmatch(__response: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn getsubopt(
        __optionp: *mut *mut core::ffi::c_char,
        __tokens: *const *mut core::ffi::c_char,
        __valuep: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn posix_openpt(__oflag: core::ffi::c_int) -> core::ffi::c_int;
    pub fn grantpt(__fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn unlockpt(__fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn ptsname(__fd: core::ffi::c_int) -> *mut core::ffi::c_char;
    pub fn ptsname_r(
        __fd: core::ffi::c_int,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
    ) -> core::ffi::c_int;
    pub fn getpt() -> core::ffi::c_int;
    pub fn getloadavg(__loadavg: *mut f64, __nelem: core::ffi::c_int) -> core::ffi::c_int;
    pub fn memcpy(
        __dest: *mut core::ffi::c_void,
        __src: *const core::ffi::c_void,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
    pub fn memmove(
        __dest: *mut core::ffi::c_void,
        __src: *const core::ffi::c_void,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
    pub fn memccpy(
        __dest: *mut core::ffi::c_void,
        __src: *const core::ffi::c_void,
        __c: core::ffi::c_int,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
    pub fn memset(
        __s: *mut core::ffi::c_void,
        __c: core::ffi::c_int,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
    pub fn memcmp(
        __s1: *const core::ffi::c_void,
        __s2: *const core::ffi::c_void,
        __n: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
    pub fn __memcmpeq(
        __s1: *const core::ffi::c_void,
        __s2: *const core::ffi::c_void,
        __n: usize,
    ) -> core::ffi::c_int;
    pub fn memchr(
        __s: *const core::ffi::c_void,
        __c: core::ffi::c_int,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
    pub fn rawmemchr(
        __s: *const core::ffi::c_void,
        __c: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
    pub fn memrchr(
        __s: *const core::ffi::c_void,
        __c: core::ffi::c_int,
        __n: usize,
    ) -> *mut core::ffi::c_void;
    pub fn strcpy(
        __dest: *mut core::ffi::c_char,
        __src: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn strncpy(
        __dest: *mut core::ffi::c_char,
        __src: *const core::ffi::c_char,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_char;
    pub fn strcat(
        __dest: *mut core::ffi::c_char,
        __src: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn strncat(
        __dest: *mut core::ffi::c_char,
        __src: *const core::ffi::c_char,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_char;
    pub fn strcmp(
        __s1: *const core::ffi::c_char,
        __s2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn strncmp(
        __s1: *const core::ffi::c_char,
        __s2: *const core::ffi::c_char,
        __n: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
    pub fn strcoll(
        __s1: *const core::ffi::c_char,
        __s2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn strxfrm(
        __dest: *mut core::ffi::c_char,
        __src: *const core::ffi::c_char,
        __n: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
    pub fn strcoll_l(
        __s1: *const core::ffi::c_char,
        __s2: *const core::ffi::c_char,
        __l: locale_t,
    ) -> core::ffi::c_int;
    pub fn strxfrm_l(
        __dest: *mut core::ffi::c_char,
        __src: *const core::ffi::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
    pub fn strdup(__s: *const core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn strndup(
        __string: *const core::ffi::c_char,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_char;
    pub fn strchr(__s: *const core::ffi::c_char, __c: core::ffi::c_int) -> *mut core::ffi::c_char;
    pub fn strrchr(__s: *const core::ffi::c_char, __c: core::ffi::c_int) -> *mut core::ffi::c_char;
    pub fn strchrnul(
        __s: *const core::ffi::c_char,
        __c: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
    pub fn strcspn(
        __s: *const core::ffi::c_char,
        __reject: *const core::ffi::c_char,
    ) -> core::ffi::c_ulong;
    pub fn strspn(
        __s: *const core::ffi::c_char,
        __accept: *const core::ffi::c_char,
    ) -> core::ffi::c_ulong;
    pub fn strpbrk(
        __s: *const core::ffi::c_char,
        __accept: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn strstr(
        __haystack: *const core::ffi::c_char,
        __needle: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn strtok(
        __s: *mut core::ffi::c_char,
        __delim: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn __strtok_r(
        __s: *mut core::ffi::c_char,
        __delim: *const core::ffi::c_char,
        __save_ptr: *mut *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn strtok_r(
        __s: *mut core::ffi::c_char,
        __delim: *const core::ffi::c_char,
        __save_ptr: *mut *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn strcasestr(
        __haystack: *const core::ffi::c_char,
        __needle: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn memmem(
        __haystack: *const core::ffi::c_void,
        __haystacklen: usize,
        __needle: *const core::ffi::c_void,
        __needlelen: usize,
    ) -> *mut core::ffi::c_void;
    pub fn __mempcpy(
        __dest: *mut core::ffi::c_void,
        __src: *const core::ffi::c_void,
        __n: usize,
    ) -> *mut core::ffi::c_void;
    pub fn mempcpy(
        __dest: *mut core::ffi::c_void,
        __src: *const core::ffi::c_void,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
    pub fn strlen(__s: *const core::ffi::c_char) -> core::ffi::c_ulong;
    pub fn strnlen(__string: *const core::ffi::c_char, __maxlen: usize) -> usize;
    pub fn strerror(__errnum: core::ffi::c_int) -> *mut core::ffi::c_char;
    pub fn strerror_r(
        __errnum: core::ffi::c_int,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
    ) -> *mut core::ffi::c_char;
    pub fn strerrordesc_np(__err: core::ffi::c_int) -> *const core::ffi::c_char;
    pub fn strerrorname_np(__err: core::ffi::c_int) -> *const core::ffi::c_char;
    pub fn strerror_l(__errnum: core::ffi::c_int, __l: locale_t) -> *mut core::ffi::c_char;
    pub fn bcmp(
        __s1: *const core::ffi::c_void,
        __s2: *const core::ffi::c_void,
        __n: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
    pub fn bcopy(__src: *const core::ffi::c_void, __dest: *mut core::ffi::c_void, __n: usize);
    pub fn bzero(__s: *mut core::ffi::c_void, __n: core::ffi::c_ulong);
    pub fn index(__s: *const core::ffi::c_char, __c: core::ffi::c_int) -> *mut core::ffi::c_char;
    pub fn rindex(__s: *const core::ffi::c_char, __c: core::ffi::c_int) -> *mut core::ffi::c_char;
    pub fn ffs(__i: core::ffi::c_int) -> core::ffi::c_int;
    pub fn ffsl(__l: core::ffi::c_long) -> core::ffi::c_int;
    pub fn ffsll(__ll: core::ffi::c_longlong) -> core::ffi::c_int;
    pub fn strcasecmp(
        __s1: *const core::ffi::c_char,
        __s2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn strncasecmp(
        __s1: *const core::ffi::c_char,
        __s2: *const core::ffi::c_char,
        __n: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
    pub fn strcasecmp_l(
        __s1: *const core::ffi::c_char,
        __s2: *const core::ffi::c_char,
        __loc: locale_t,
    ) -> core::ffi::c_int;
    pub fn strncasecmp_l(
        __s1: *const core::ffi::c_char,
        __s2: *const core::ffi::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> core::ffi::c_int;
    pub fn explicit_bzero(__s: *mut core::ffi::c_void, __n: usize);
    pub fn strsep(
        __stringp: *mut *mut core::ffi::c_char,
        __delim: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn strsignal(__sig: core::ffi::c_int) -> *mut core::ffi::c_char;
    pub fn sigabbrev_np(__sig: core::ffi::c_int) -> *const core::ffi::c_char;
    pub fn sigdescr_np(__sig: core::ffi::c_int) -> *const core::ffi::c_char;
    pub fn __stpcpy(
        __dest: *mut core::ffi::c_char,
        __src: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn stpcpy(
        __dest: *mut core::ffi::c_char,
        __src: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn __stpncpy(
        __dest: *mut core::ffi::c_char,
        __src: *const core::ffi::c_char,
        __n: usize,
    ) -> *mut core::ffi::c_char;
    pub fn stpncpy(
        __dest: *mut core::ffi::c_char,
        __src: *const core::ffi::c_char,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_char;
    pub fn strverscmp(
        __s1: *const core::ffi::c_char,
        __s2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn strfry(__string: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn memfrob(__s: *mut core::ffi::c_void, __n: usize) -> *mut core::ffi::c_void;
    pub fn basename(__filename: *const core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn __sysconf(__name: core::ffi::c_int) -> core::ffi::c_long;
    pub fn access(__name: *const core::ffi::c_char, __type: core::ffi::c_int) -> core::ffi::c_int;
    pub fn euidaccess(
        __name: *const core::ffi::c_char,
        __type: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn eaccess(__name: *const core::ffi::c_char, __type: core::ffi::c_int) -> core::ffi::c_int;
    pub fn execveat(
        __fd: core::ffi::c_int,
        __path: *const core::ffi::c_char,
        __argv: *const *mut core::ffi::c_char,
        __envp: *const *mut core::ffi::c_char,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn faccessat(
        __fd: core::ffi::c_int,
        __file: *const core::ffi::c_char,
        __type: core::ffi::c_int,
        __flag: core::ffi::c_int,
    ) -> core::ffi::c_int;
    #[link_name = "\u{1}lseek64"]
    pub fn lseek(
        __fd: core::ffi::c_int,
        __offset: __off64_t,
        __whence: core::ffi::c_int,
    ) -> __off64_t;
    pub fn close(__fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn closefrom(__lowfd: core::ffi::c_int);
    pub fn read(__fd: core::ffi::c_int, __buf: *mut core::ffi::c_void, __nbytes: usize) -> isize;
    pub fn write(__fd: core::ffi::c_int, __buf: *const core::ffi::c_void, __n: usize) -> isize;
    #[link_name = "\u{1}pread64"]
    pub fn pread(
        __fd: core::ffi::c_int,
        __buf: *mut core::ffi::c_void,
        __nbytes: usize,
        __offset: __off64_t,
    ) -> isize;
    #[link_name = "\u{1}pwrite64"]
    pub fn pwrite(
        __fd: core::ffi::c_int,
        __buf: *const core::ffi::c_void,
        __nbytes: usize,
        __offset: __off64_t,
    ) -> isize;
    pub fn pipe(__pipedes: *mut core::ffi::c_int) -> core::ffi::c_int;
    pub fn pipe2(__pipedes: *mut core::ffi::c_int, __flags: core::ffi::c_int) -> core::ffi::c_int;
    pub fn alarm(__seconds: core::ffi::c_uint) -> core::ffi::c_uint;
    pub fn sleep(__seconds: core::ffi::c_uint) -> core::ffi::c_uint;
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
    pub fn usleep(__useconds: __useconds_t) -> core::ffi::c_int;
    pub fn pause() -> core::ffi::c_int;
    pub fn chown(
        __file: *const core::ffi::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> core::ffi::c_int;
    pub fn fchown(__fd: core::ffi::c_int, __owner: __uid_t, __group: __gid_t) -> core::ffi::c_int;
    pub fn lchown(
        __file: *const core::ffi::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> core::ffi::c_int;
    pub fn fchownat(
        __fd: core::ffi::c_int,
        __file: *const core::ffi::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn chdir(__path: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn fchdir(__fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn getcwd(__buf: *mut core::ffi::c_char, __size: usize) -> *mut core::ffi::c_char;
    pub fn get_current_dir_name() -> *mut core::ffi::c_char;
    pub fn getwd(__buf: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn dup(__fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn dup2(__fd: core::ffi::c_int, __fd2: core::ffi::c_int) -> core::ffi::c_int;
    pub fn dup3(
        __fd: core::ffi::c_int,
        __fd2: core::ffi::c_int,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub static mut __environ: *mut *mut core::ffi::c_char;
    pub static mut environ: *mut *mut core::ffi::c_char;
    pub fn execve(
        __path: *const core::ffi::c_char,
        __argv: *const *mut core::ffi::c_char,
        __envp: *const *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn fexecve(
        __fd: core::ffi::c_int,
        __argv: *const *mut core::ffi::c_char,
        __envp: *const *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn execv(
        __path: *const core::ffi::c_char,
        __argv: *const *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn execle(
        __path: *const core::ffi::c_char,
        __arg: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
    pub fn execl(
        __path: *const core::ffi::c_char,
        __arg: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
    pub fn execvp(
        __file: *const core::ffi::c_char,
        __argv: *const *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn execlp(
        __file: *const core::ffi::c_char,
        __arg: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
    pub fn execvpe(
        __file: *const core::ffi::c_char,
        __argv: *const *mut core::ffi::c_char,
        __envp: *const *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn nice(__inc: core::ffi::c_int) -> core::ffi::c_int;
    pub fn _exit(__status: core::ffi::c_int) -> !;
    pub fn pathconf(
        __path: *const core::ffi::c_char,
        __name: core::ffi::c_int,
    ) -> core::ffi::c_long;
    pub fn fpathconf(__fd: core::ffi::c_int, __name: core::ffi::c_int) -> core::ffi::c_long;
    pub fn sysconf(__name: core::ffi::c_int) -> core::ffi::c_long;
    pub fn confstr(__name: core::ffi::c_int, __buf: *mut core::ffi::c_char, __len: usize) -> usize;
    pub fn getpid() -> __pid_t;
    pub fn getppid() -> __pid_t;
    pub fn getpgrp() -> __pid_t;
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> core::ffi::c_int;
    pub fn setpgrp() -> core::ffi::c_int;
    pub fn setsid() -> __pid_t;
    pub fn getsid(__pid: __pid_t) -> __pid_t;
    pub fn getuid() -> __uid_t;
    pub fn geteuid() -> __uid_t;
    pub fn getgid() -> __gid_t;
    pub fn getegid() -> __gid_t;
    pub fn getgroups(__size: core::ffi::c_int, __list: *mut __gid_t) -> core::ffi::c_int;
    pub fn group_member(__gid: __gid_t) -> core::ffi::c_int;
    pub fn setuid(__uid: __uid_t) -> core::ffi::c_int;
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> core::ffi::c_int;
    pub fn seteuid(__uid: __uid_t) -> core::ffi::c_int;
    pub fn setgid(__gid: __gid_t) -> core::ffi::c_int;
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> core::ffi::c_int;
    pub fn setegid(__gid: __gid_t) -> core::ffi::c_int;
    pub fn getresuid(
        __ruid: *mut __uid_t,
        __euid: *mut __uid_t,
        __suid: *mut __uid_t,
    ) -> core::ffi::c_int;
    pub fn getresgid(
        __rgid: *mut __gid_t,
        __egid: *mut __gid_t,
        __sgid: *mut __gid_t,
    ) -> core::ffi::c_int;
    pub fn setresuid(__ruid: __uid_t, __euid: __uid_t, __suid: __uid_t) -> core::ffi::c_int;
    pub fn setresgid(__rgid: __gid_t, __egid: __gid_t, __sgid: __gid_t) -> core::ffi::c_int;
    pub fn fork() -> __pid_t;
    pub fn vfork() -> core::ffi::c_int;
    pub fn _Fork() -> __pid_t;
    pub fn ttyname(__fd: core::ffi::c_int) -> *mut core::ffi::c_char;
    pub fn ttyname_r(
        __fd: core::ffi::c_int,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
    ) -> core::ffi::c_int;
    pub fn isatty(__fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn ttyslot() -> core::ffi::c_int;
    pub fn link(
        __from: *const core::ffi::c_char,
        __to: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn linkat(
        __fromfd: core::ffi::c_int,
        __from: *const core::ffi::c_char,
        __tofd: core::ffi::c_int,
        __to: *const core::ffi::c_char,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn symlink(
        __from: *const core::ffi::c_char,
        __to: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn readlink(
        __path: *const core::ffi::c_char,
        __buf: *mut core::ffi::c_char,
        __len: usize,
    ) -> isize;
    pub fn symlinkat(
        __from: *const core::ffi::c_char,
        __tofd: core::ffi::c_int,
        __to: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn readlinkat(
        __fd: core::ffi::c_int,
        __path: *const core::ffi::c_char,
        __buf: *mut core::ffi::c_char,
        __len: usize,
    ) -> isize;
    pub fn unlink(__name: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn unlinkat(
        __fd: core::ffi::c_int,
        __name: *const core::ffi::c_char,
        __flag: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn rmdir(__path: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn tcgetpgrp(__fd: core::ffi::c_int) -> __pid_t;
    pub fn tcsetpgrp(__fd: core::ffi::c_int, __pgrp_id: __pid_t) -> core::ffi::c_int;
    pub fn getlogin() -> *mut core::ffi::c_char;
    pub fn getlogin_r(__name: *mut core::ffi::c_char, __name_len: usize) -> core::ffi::c_int;
    pub fn setlogin(__name: *const core::ffi::c_char) -> core::ffi::c_int;
    pub static mut optarg: *mut core::ffi::c_char;
    pub static mut optind: core::ffi::c_int;
    pub static mut opterr: core::ffi::c_int;
    pub static mut optopt: core::ffi::c_int;
    pub fn getopt(
        ___argc: core::ffi::c_int,
        ___argv: *const *mut core::ffi::c_char,
        __shortopts: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn gethostname(__name: *mut core::ffi::c_char, __len: usize) -> core::ffi::c_int;
    pub fn sethostname(__name: *const core::ffi::c_char, __len: usize) -> core::ffi::c_int;
    pub fn sethostid(__id: core::ffi::c_long) -> core::ffi::c_int;
    pub fn getdomainname(__name: *mut core::ffi::c_char, __len: usize) -> core::ffi::c_int;
    pub fn setdomainname(__name: *const core::ffi::c_char, __len: usize) -> core::ffi::c_int;
    pub fn vhangup() -> core::ffi::c_int;
    pub fn revoke(__file: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn profil(
        __sample_buffer: *mut core::ffi::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: core::ffi::c_uint,
    ) -> core::ffi::c_int;
    pub fn acct(__name: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn getusershell() -> *mut core::ffi::c_char;
    pub fn endusershell();
    pub fn setusershell();
    pub fn daemon(__nochdir: core::ffi::c_int, __noclose: core::ffi::c_int) -> core::ffi::c_int;
    pub fn chroot(__path: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn getpass(__prompt: *const core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn fsync(__fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn syncfs(__fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn gethostid() -> core::ffi::c_long;
    pub fn sync();
    pub fn getpagesize() -> core::ffi::c_int;
    pub fn getdtablesize() -> core::ffi::c_int;
    #[link_name = "\u{1}truncate64"]
    pub fn truncate(__file: *const core::ffi::c_char, __length: __off64_t) -> core::ffi::c_int;
    #[link_name = "\u{1}ftruncate64"]
    pub fn ftruncate(__fd: core::ffi::c_int, __length: __off64_t) -> core::ffi::c_int;
    pub fn brk(__addr: *mut core::ffi::c_void) -> core::ffi::c_int;
    pub fn sbrk(__delta: isize) -> *mut core::ffi::c_void;
    pub fn syscall(__sysno: core::ffi::c_long, ...) -> core::ffi::c_long;
    #[link_name = "\u{1}lockf64"]
    pub fn lockf(
        __fd: core::ffi::c_int,
        __cmd: core::ffi::c_int,
        __len: __off64_t,
    ) -> core::ffi::c_int;
    pub fn copy_file_range(
        __infd: core::ffi::c_int,
        __pinoff: *mut __off64_t,
        __outfd: core::ffi::c_int,
        __poutoff: *mut __off64_t,
        __length: usize,
        __flags: core::ffi::c_uint,
    ) -> isize;
    pub fn fdatasync(__fildes: core::ffi::c_int) -> core::ffi::c_int;
    pub fn crypt(
        __key: *const core::ffi::c_char,
        __salt: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn swab(__from: *const core::ffi::c_void, __to: *mut core::ffi::c_void, __n: isize);
    pub fn getentropy(__buffer: *mut core::ffi::c_void, __length: usize) -> core::ffi::c_int;
    pub fn close_range(
        __fd: core::ffi::c_uint,
        __max_fd: core::ffi::c_uint,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn gettid() -> __pid_t;
    pub fn clock_adjtime(__clock_id: __clockid_t, __utx: *mut timex) -> core::ffi::c_int;
    pub fn clock() -> clock_t;
    pub fn time(__timer: *mut time_t) -> time_t;
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
    pub fn mktime(__tp: *mut tm) -> time_t;
    pub fn strftime(
        __s: *mut core::ffi::c_char,
        __maxsize: usize,
        __format: *const core::ffi::c_char,
        __tp: *const tm,
    ) -> usize;
    pub fn strptime(
        __s: *const core::ffi::c_char,
        __fmt: *const core::ffi::c_char,
        __tp: *mut tm,
    ) -> *mut core::ffi::c_char;
    pub fn strftime_l(
        __s: *mut core::ffi::c_char,
        __maxsize: usize,
        __format: *const core::ffi::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
    pub fn strptime_l(
        __s: *const core::ffi::c_char,
        __fmt: *const core::ffi::c_char,
        __tp: *mut tm,
        __loc: locale_t,
    ) -> *mut core::ffi::c_char;
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
    pub fn localtime(__timer: *const time_t) -> *mut tm;
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
    pub fn asctime(__tp: *const tm) -> *mut core::ffi::c_char;
    pub fn ctime(__timer: *const time_t) -> *mut core::ffi::c_char;
    pub fn asctime_r(__tp: *const tm, __buf: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn ctime_r(__timer: *const time_t, __buf: *mut core::ffi::c_char)
        -> *mut core::ffi::c_char;
    pub static mut __tzname: [*mut core::ffi::c_char; 2usize];
    pub static mut __daylight: core::ffi::c_int;
    pub static mut __timezone: core::ffi::c_long;
    pub static mut tzname: [*mut core::ffi::c_char; 2usize];
    pub fn tzset();
    pub static mut daylight: core::ffi::c_int;
    pub static mut timezone: core::ffi::c_long;
    pub fn timegm(__tp: *mut tm) -> time_t;
    pub fn timelocal(__tp: *mut tm) -> time_t;
    pub fn dysize(__year: core::ffi::c_int) -> core::ffi::c_int;
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> core::ffi::c_int;
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> core::ffi::c_int;
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> core::ffi::c_int;
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> core::ffi::c_int;
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: core::ffi::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> core::ffi::c_int;
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> core::ffi::c_int;
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> core::ffi::c_int;
    pub fn timer_delete(__timerid: timer_t) -> core::ffi::c_int;
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: core::ffi::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> core::ffi::c_int;
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> core::ffi::c_int;
    pub fn timer_getoverrun(__timerid: timer_t) -> core::ffi::c_int;
    pub fn timespec_get(__ts: *mut timespec, __base: core::ffi::c_int) -> core::ffi::c_int;
    pub fn timespec_getres(__ts: *mut timespec, __base: core::ffi::c_int) -> core::ffi::c_int;
    pub static mut getdate_err: core::ffi::c_int;
    pub fn getdate(__string: *const core::ffi::c_char) -> *mut tm;
    pub fn getdate_r(__string: *const core::ffi::c_char, __resbufp: *mut tm) -> core::ffi::c_int;
    pub fn readahead(__fd: core::ffi::c_int, __offset: __off64_t, __count: usize) -> __ssize_t;
    pub fn sync_file_range(
        __fd: core::ffi::c_int,
        __offset: __off64_t,
        __count: __off64_t,
        __flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
    pub fn vmsplice(
        __fdout: core::ffi::c_int,
        __iov: *const iovec,
        __count: usize,
        __flags: core::ffi::c_uint,
    ) -> __ssize_t;
    pub fn splice(
        __fdin: core::ffi::c_int,
        __offin: *mut __off64_t,
        __fdout: core::ffi::c_int,
        __offout: *mut __off64_t,
        __len: usize,
        __flags: core::ffi::c_uint,
    ) -> __ssize_t;
    pub fn tee(
        __fdin: core::ffi::c_int,
        __fdout: core::ffi::c_int,
        __len: usize,
        __flags: core::ffi::c_uint,
    ) -> __ssize_t;
    #[link_name = "\u{1}fallocate64"]
    pub fn fallocate(
        __fd: core::ffi::c_int,
        __mode: core::ffi::c_int,
        __offset: __off64_t,
        __len: __off64_t,
    ) -> core::ffi::c_int;
    pub fn name_to_handle_at(
        __dfd: core::ffi::c_int,
        __name: *const core::ffi::c_char,
        __handle: *mut file_handle,
        __mnt_id: *mut core::ffi::c_int,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn open_by_handle_at(
        __mountdirfd: core::ffi::c_int,
        __handle: *mut file_handle,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn getopt_long(
        ___argc: core::ffi::c_int,
        ___argv: *const *mut core::ffi::c_char,
        __shortopts: *const core::ffi::c_char,
        __longopts: *const option,
        __longind: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn getopt_long_only(
        ___argc: core::ffi::c_int,
        ___argv: *const *mut core::ffi::c_char,
        __shortopts: *const core::ffi::c_char,
        __longopts: *const option,
        __longind: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    #[link_name = "\u{1}stat64"]
    pub fn stat(__file: *const core::ffi::c_char, __buf: *mut stat) -> core::ffi::c_int;
    #[link_name = "\u{1}fstat64"]
    pub fn fstat(__fd: core::ffi::c_int, __buf: *mut stat) -> core::ffi::c_int;
    #[link_name = "\u{1}fstatat64"]
    pub fn fstatat(
        __fd: core::ffi::c_int,
        __file: *const core::ffi::c_char,
        __buf: *mut stat,
        __flag: core::ffi::c_int,
    ) -> core::ffi::c_int;
    #[link_name = "\u{1}lstat64"]
    pub fn lstat(__file: *const core::ffi::c_char, __buf: *mut stat) -> core::ffi::c_int;
    pub fn chmod(__file: *const core::ffi::c_char, __mode: __mode_t) -> core::ffi::c_int;
    pub fn lchmod(__file: *const core::ffi::c_char, __mode: __mode_t) -> core::ffi::c_int;
    pub fn fchmod(__fd: core::ffi::c_int, __mode: __mode_t) -> core::ffi::c_int;
    pub fn fchmodat(
        __fd: core::ffi::c_int,
        __file: *const core::ffi::c_char,
        __mode: __mode_t,
        __flag: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn umask(__mask: __mode_t) -> __mode_t;
    pub fn getumask() -> __mode_t;
    pub fn mkdir(__path: *const core::ffi::c_char, __mode: __mode_t) -> core::ffi::c_int;
    pub fn mkdirat(
        __fd: core::ffi::c_int,
        __path: *const core::ffi::c_char,
        __mode: __mode_t,
    ) -> core::ffi::c_int;
    pub fn mknod(
        __path: *const core::ffi::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> core::ffi::c_int;
    pub fn mknodat(
        __fd: core::ffi::c_int,
        __path: *const core::ffi::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> core::ffi::c_int;
    pub fn mkfifo(__path: *const core::ffi::c_char, __mode: __mode_t) -> core::ffi::c_int;
    pub fn mkfifoat(
        __fd: core::ffi::c_int,
        __path: *const core::ffi::c_char,
        __mode: __mode_t,
    ) -> core::ffi::c_int;
    pub fn utimensat(
        __fd: core::ffi::c_int,
        __path: *const core::ffi::c_char,
        __times: *const timespec,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn futimens(__fd: core::ffi::c_int, __times: *const timespec) -> core::ffi::c_int;
    pub fn statx(
        __dirfd: core::ffi::c_int,
        __path: *const core::ffi::c_char,
        __flags: core::ffi::c_int,
        __mask: core::ffi::c_uint,
        __buf: *mut statx,
    ) -> core::ffi::c_int;
    pub fn gettimeofday(__tv: *mut timeval, __tz: *mut core::ffi::c_void) -> core::ffi::c_int;
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> core::ffi::c_int;
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> core::ffi::c_int;
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> core::ffi::c_int;
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> core::ffi::c_int;
    pub fn utimes(__file: *const core::ffi::c_char, __tvp: *const timeval) -> core::ffi::c_int;
    pub fn lutimes(__file: *const core::ffi::c_char, __tvp: *const timeval) -> core::ffi::c_int;
    pub fn futimes(__fd: core::ffi::c_int, __tvp: *const timeval) -> core::ffi::c_int;
    pub fn futimesat(
        __fd: core::ffi::c_int,
        __file: *const core::ffi::c_char,
        __tvp: *const timeval,
    ) -> core::ffi::c_int;
    pub fn setjmp(__env: *mut __jmp_buf_tag) -> core::ffi::c_int;
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: core::ffi::c_int)
        -> core::ffi::c_int;
    pub fn _setjmp(__env: *mut __jmp_buf_tag) -> core::ffi::c_int;
    pub fn longjmp(__env: *mut __jmp_buf_tag, __val: core::ffi::c_int) -> !;
    pub fn _longjmp(__env: *mut __jmp_buf_tag, __val: core::ffi::c_int) -> !;
    pub fn siglongjmp(__env: *mut __jmp_buf_tag, __val: core::ffi::c_int) -> !;
    pub fn __sysv_signal(__sig: core::ffi::c_int, __handler: __sighandler_t) -> __sighandler_t;
    pub fn sysv_signal(__sig: core::ffi::c_int, __handler: __sighandler_t) -> __sighandler_t;
    pub fn signal(__sig: core::ffi::c_int, __handler: __sighandler_t) -> __sighandler_t;
    pub fn kill(__pid: __pid_t, __sig: core::ffi::c_int) -> core::ffi::c_int;
    pub fn killpg(__pgrp: __pid_t, __sig: core::ffi::c_int) -> core::ffi::c_int;
    pub fn raise(__sig: core::ffi::c_int) -> core::ffi::c_int;
    pub fn ssignal(__sig: core::ffi::c_int, __handler: __sighandler_t) -> __sighandler_t;
    pub fn gsignal(__sig: core::ffi::c_int) -> core::ffi::c_int;
    pub fn psignal(__sig: core::ffi::c_int, __s: *const core::ffi::c_char);
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const core::ffi::c_char);
    #[link_name = "\u{1}__xpg_sigpause"]
    pub fn sigpause(__sig: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sigblock(__mask: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sigsetmask(__mask: core::ffi::c_int) -> core::ffi::c_int;
    pub fn siggetmask() -> core::ffi::c_int;
    pub fn sigemptyset(__set: *mut sigset_t) -> core::ffi::c_int;
    pub fn sigfillset(__set: *mut sigset_t) -> core::ffi::c_int;
    pub fn sigaddset(__set: *mut sigset_t, __signo: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sigdelset(__set: *mut sigset_t, __signo: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sigismember(__set: *const sigset_t, __signo: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sigisemptyset(__set: *const sigset_t) -> core::ffi::c_int;
    pub fn sigandset(
        __set: *mut sigset_t,
        __left: *const sigset_t,
        __right: *const sigset_t,
    ) -> core::ffi::c_int;
    pub fn sigorset(
        __set: *mut sigset_t,
        __left: *const sigset_t,
        __right: *const sigset_t,
    ) -> core::ffi::c_int;
    pub fn sigprocmask(
        __how: core::ffi::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> core::ffi::c_int;
    pub fn sigsuspend(__set: *const sigset_t) -> core::ffi::c_int;
    pub fn sigaction(
        __sig: core::ffi::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> core::ffi::c_int;
    pub fn sigpending(__set: *mut sigset_t) -> core::ffi::c_int;
    pub fn sigwait(__set: *const sigset_t, __sig: *mut core::ffi::c_int) -> core::ffi::c_int;
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> core::ffi::c_int;
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> core::ffi::c_int;
    pub fn sigqueue(__pid: __pid_t, __sig: core::ffi::c_int, __val: sigval) -> core::ffi::c_int;
    pub fn sigreturn(__scp: *mut sigcontext) -> core::ffi::c_int;
    pub fn siginterrupt(__sig: core::ffi::c_int, __interrupt: core::ffi::c_int)
        -> core::ffi::c_int;
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> core::ffi::c_int;
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> core::ffi::c_int;
    pub fn sighold(__sig: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sigrelse(__sig: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sigignore(__sig: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sigset(__sig: core::ffi::c_int, __disp: __sighandler_t) -> __sighandler_t;
    pub fn pthread_sigmask(
        __how: core::ffi::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> core::ffi::c_int;
    pub fn pthread_kill(__threadid: pthread_t, __signo: core::ffi::c_int) -> core::ffi::c_int;
    pub fn pthread_sigqueue(
        __threadid: pthread_t,
        __signo: core::ffi::c_int,
        __value: sigval,
    ) -> core::ffi::c_int;
    pub fn __libc_current_sigrtmin() -> core::ffi::c_int;
    pub fn __libc_current_sigrtmax() -> core::ffi::c_int;
    pub fn tgkill(__tgid: __pid_t, __tid: __pid_t, __signal: core::ffi::c_int) -> core::ffi::c_int;
    pub fn readv(__fd: core::ffi::c_int, __iovec: *const iovec, __count: core::ffi::c_int)
        -> isize;
    pub fn writev(
        __fd: core::ffi::c_int,
        __iovec: *const iovec,
        __count: core::ffi::c_int,
    ) -> isize;
    #[link_name = "\u{1}preadv64"]
    pub fn preadv(
        __fd: core::ffi::c_int,
        __iovec: *const iovec,
        __count: core::ffi::c_int,
        __offset: __off64_t,
    ) -> isize;
    #[link_name = "\u{1}pwritev64"]
    pub fn pwritev(
        __fd: core::ffi::c_int,
        __iovec: *const iovec,
        __count: core::ffi::c_int,
        __offset: __off64_t,
    ) -> isize;
    #[link_name = "\u{1}pwritev64v2"]
    pub fn pwritev2(
        __fd: core::ffi::c_int,
        __iovec: *const iovec,
        __count: core::ffi::c_int,
        __offset: __off64_t,
        __flags: core::ffi::c_int,
    ) -> isize;
    #[link_name = "\u{1}preadv64v2"]
    pub fn preadv2(
        __fd: core::ffi::c_int,
        __iovec: *const iovec,
        __count: core::ffi::c_int,
        __offset: __off64_t,
        __flags: core::ffi::c_int,
    ) -> isize;
    pub fn process_vm_readv(
        __pid: pid_t,
        __lvec: *const iovec,
        __liovcnt: core::ffi::c_ulong,
        __rvec: *const iovec,
        __riovcnt: core::ffi::c_ulong,
        __flags: core::ffi::c_ulong,
    ) -> isize;
    pub fn process_vm_writev(
        __pid: pid_t,
        __lvec: *const iovec,
        __liovcnt: core::ffi::c_ulong,
        __rvec: *const iovec,
        __riovcnt: core::ffi::c_ulong,
        __flags: core::ffi::c_ulong,
    ) -> isize;
    pub fn wait(__stat_loc: *mut core::ffi::c_int) -> __pid_t;
    pub fn waitpid(
        __pid: __pid_t,
        __stat_loc: *mut core::ffi::c_int,
        __options: core::ffi::c_int,
    ) -> __pid_t;
    pub fn waitid(
        __idtype: idtype_t,
        __id: __id_t,
        __infop: *mut siginfo_t,
        __options: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn wait3(
        __stat_loc: *mut core::ffi::c_int,
        __options: core::ffi::c_int,
        __usage: *mut rusage,
    ) -> __pid_t;
    pub fn wait4(
        __pid: __pid_t,
        __stat_loc: *mut core::ffi::c_int,
        __options: core::ffi::c_int,
        __usage: *mut rusage,
    ) -> __pid_t;
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
    pub fn g_array_steal(array: *mut GArray, len: *mut gsize) -> gpointer;
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
    pub fn g_array_copy(array: *mut GArray) -> *mut GArray;
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
    pub fn g_array_unref(array: *mut GArray);
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
        -> *mut GArray;
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_array_binary_search(
        array: *mut GArray,
        target: gconstpointer,
        compare_func: GCompareFunc,
        out_match_index: *mut guint,
    ) -> gboolean;
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
    pub fn g_ptr_array_new() -> *mut GPtrArray;
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
    pub fn g_ptr_array_steal(array: *mut GPtrArray, len: *mut gsize) -> *mut gpointer;
    pub fn g_ptr_array_copy(
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GPtrArray;
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
    pub fn g_ptr_array_new_null_terminated(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
        null_terminated: gboolean,
    ) -> *mut GPtrArray;
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
    pub fn g_ptr_array_steal_index(array: *mut GPtrArray, index_: guint) -> gpointer;
    pub fn g_ptr_array_steal_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
    pub fn g_ptr_array_extend(
        array_to_extend: *mut GPtrArray,
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    );
    pub fn g_ptr_array_extend_and_steal(array_to_extend: *mut GPtrArray, array: *mut GPtrArray);
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut guint,
    ) -> gboolean;
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut guint,
    ) -> gboolean;
    pub fn g_ptr_array_is_null_terminated(array: *mut GPtrArray) -> gboolean;
    pub fn g_byte_array_new() -> *mut GByteArray;
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
    pub fn g_byte_array_steal(array: *mut GByteArray, len: *mut gsize) -> *mut guint8;
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
    pub fn g_byte_array_unref(array: *mut GByteArray);
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
        -> *mut GByteArray;
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
    pub fn g_atomic_int_inc(atomic: *mut gint);
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
    pub fn g_atomic_int_compare_and_exchange_full(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
        preval: *mut gint,
    ) -> gboolean;
    pub fn g_atomic_int_exchange(atomic: *mut gint, newval: gint) -> gint;
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
    pub fn g_atomic_pointer_get(atomic: *const core::ffi::c_void) -> gpointer;
    pub fn g_atomic_pointer_set(atomic: *mut core::ffi::c_void, newval: gpointer);
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut core::ffi::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
    pub fn g_atomic_pointer_compare_and_exchange_full(
        atomic: *mut core::ffi::c_void,
        oldval: gpointer,
        newval: gpointer,
        preval: *mut core::ffi::c_void,
    ) -> gboolean;
    pub fn g_atomic_pointer_exchange(atomic: *mut core::ffi::c_void, newval: gpointer) -> gpointer;
    pub fn g_atomic_pointer_add(atomic: *mut core::ffi::c_void, val: gssize) -> gssize;
    pub fn g_atomic_pointer_and(atomic: *mut core::ffi::c_void, val: gsize) -> gsize;
    pub fn g_atomic_pointer_or(atomic: *mut core::ffi::c_void, val: gsize) -> gsize;
    pub fn g_atomic_pointer_xor(atomic: *mut core::ffi::c_void, val: gsize) -> gsize;
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
    pub fn g_error_domain_register_static(
        error_type_name: *const core::ffi::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
    pub fn g_error_domain_register(
        error_type_name: *const core::ffi::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> *mut GError;
    pub fn g_error_free(error: *mut GError);
    pub fn g_error_copy(error: *const GError) -> *mut GError;
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
    pub fn g_clear_error(err: *mut *mut GError);
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
    pub fn g_prefix_error_literal(err: *mut *mut GError, prefix: *const gchar);
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
    pub fn g_get_user_name() -> *const gchar;
    pub fn g_get_real_name() -> *const gchar;
    pub fn g_get_home_dir() -> *const gchar;
    pub fn g_get_tmp_dir() -> *const gchar;
    pub fn g_get_host_name() -> *const gchar;
    pub fn g_get_prgname() -> *const gchar;
    pub fn g_set_prgname(prgname: *const gchar);
    pub fn g_get_application_name() -> *const gchar;
    pub fn g_set_application_name(application_name: *const gchar);
    pub fn g_get_os_info(key_name: *const gchar) -> *mut gchar;
    pub fn g_reload_user_special_dirs_cache();
    pub fn g_get_user_data_dir() -> *const gchar;
    pub fn g_get_user_config_dir() -> *const gchar;
    pub fn g_get_user_cache_dir() -> *const gchar;
    pub fn g_get_user_state_dir() -> *const gchar;
    pub fn g_get_system_data_dirs() -> *const *const gchar;
    pub fn g_get_system_config_dirs() -> *const *const gchar;
    pub fn g_get_user_runtime_dir() -> *const gchar;
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
    pub fn g_vsnprintf(
        string: *mut gchar,
        n: gulong,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gint;
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
    pub fn g_format_size(size: guint64) -> *mut gchar;
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
    pub fn g_atexit(func: GVoidFunc);
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
    pub fn g_bit_storage(number: gulong) -> guint;
    pub fn g_thread_error_quark() -> GQuark;
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
    pub fn g_thread_unref(thread: *mut GThread);
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
    pub fn g_thread_self() -> *mut GThread;
    pub fn g_thread_exit(retval: gpointer);
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
    pub fn g_thread_yield();
    pub fn g_mutex_init(mutex: *mut GMutex);
    pub fn g_mutex_clear(mutex: *mut GMutex);
    pub fn g_mutex_lock(mutex: *mut GMutex);
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
    pub fn g_mutex_unlock(mutex: *mut GMutex);
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
    pub fn g_cond_init(cond: *mut GCond);
    pub fn g_cond_clear(cond: *mut GCond);
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
    pub fn g_cond_signal(cond: *mut GCond);
    pub fn g_cond_broadcast(cond: *mut GCond);
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
    pub fn g_once_init_enter(location: *mut core::ffi::c_void) -> gboolean;
    pub fn g_once_init_leave(location: *mut core::ffi::c_void, result: gsize);
    pub fn g_get_num_processors() -> guint;
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
    pub fn g_on_error_query(prg_name: *const gchar);
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
    pub fn g_pointer_bit_lock(address: *mut core::ffi::c_void, lock_bit: gint);
    pub fn g_pointer_bit_trylock(address: *mut core::ffi::c_void, lock_bit: gint) -> gboolean;
    pub fn g_pointer_bit_unlock(address: *mut core::ffi::c_void, lock_bit: gint);
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
    pub fn g_time_zone_new_identifier(identifier: *const gchar) -> *mut GTimeZone;
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
    pub fn g_time_zone_new_offset(seconds: gint32) -> *mut GTimeZone;
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
    pub fn g_time_zone_get_identifier(tz: *mut GTimeZone) -> *const gchar;
    pub fn g_date_time_unref(datetime: *mut GDateTime);
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
    pub fn g_date_time_new_from_iso8601(
        text: *const gchar,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
    pub fn g_date_time_format_iso8601(datetime: *mut GDateTime) -> *mut gchar;
    pub fn g_bookmark_file_error_quark() -> GQuark;
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_set_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const core::ffi::c_char,
        name: *const core::ffi::c_char,
        exec: *const core::ffi::c_char,
        count: core::ffi::c_int,
        stamp: *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_get_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const core::ffi::c_char,
        name: *const core::ffi::c_char,
        exec: *mut *mut core::ffi::c_char,
        count: *mut core::ffi::c_uint,
        stamp: *mut *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
    pub fn g_bookmark_file_set_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const core::ffi::c_char,
        added: *mut GDateTime,
    );
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
    pub fn g_bookmark_file_get_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const core::ffi::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
    pub fn g_bookmark_file_set_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const core::ffi::c_char,
        modified: *mut GDateTime,
    );
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
    pub fn g_bookmark_file_get_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const core::ffi::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
    pub fn g_bookmark_file_set_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const core::ffi::c_char,
        visited: *mut GDateTime,
    );
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
    pub fn g_bookmark_file_get_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const core::ffi::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
    pub fn g_bytes_unref(bytes: *mut GBytes);
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
    pub fn g_bytes_get_region(
        bytes: *mut GBytes,
        element_size: gsize,
        offset: gsize,
        n_elements: gsize,
    ) -> gconstpointer;
    pub fn g_get_charset(charset: *mut *const core::ffi::c_char) -> gboolean;
    pub fn g_get_codeset() -> *mut gchar;
    pub fn g_get_console_charset(charset: *mut *const core::ffi::c_char) -> gboolean;
    pub fn g_get_language_names() -> *const *const gchar;
    pub fn g_get_language_names_with_category(category_name: *const gchar) -> *const *const gchar;
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
    pub fn g_checksum_reset(checksum: *mut GChecksum);
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
    pub fn g_checksum_free(checksum: *mut GChecksum);
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
    pub fn g_convert_error_quark() -> GQuark;
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
    pub fn g_iconv_close(converter: GIConv) -> gint;
    pub fn g_convert(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_convert_with_iconv(
        str_: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_convert_with_fallback(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
    pub fn g_get_filename_charsets(filename_charsets: *mut *mut *const gchar) -> gboolean;
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
    pub fn g_datalist_init(datalist: *mut *mut GData);
    pub fn g_datalist_clear(datalist: *mut *mut GData);
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
    pub fn g_datalist_id_remove_multiple(
        datalist: *mut *mut GData,
        keys: *mut GQuark,
        n_keys: gsize,
    );
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
    pub fn g_date_new() -> *mut GDate;
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
    pub fn g_date_free(date: *mut GDate);
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
    pub fn g_date_valid(date: *const GDate) -> gboolean;
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
    pub fn g_date_set_parse(date: *mut GDate, str_: *const gchar);
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
    pub fn closedir(__dirp: *mut DIR) -> core::ffi::c_int;
    pub fn opendir(__name: *const core::ffi::c_char) -> *mut DIR;
    pub fn fdopendir(__fd: core::ffi::c_int) -> *mut DIR;
    #[link_name = "\u{1}readdir64"]
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
    #[link_name = "\u{1}readdir64_r"]
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> core::ffi::c_int;
    pub fn rewinddir(__dirp: *mut DIR);
    pub fn seekdir(__dirp: *mut DIR, __pos: core::ffi::c_long);
    pub fn telldir(__dirp: *mut DIR) -> core::ffi::c_long;
    pub fn dirfd(__dirp: *mut DIR) -> core::ffi::c_int;
    #[link_name = "\u{1}scandir64"]
    pub fn scandir(
        __dir: *const core::ffi::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> core::ffi::c_int,
        >,
        __cmp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
    #[link_name = "\u{1}scandirat64"]
    pub fn scandirat(
        __dfd: core::ffi::c_int,
        __dir: *const core::ffi::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> core::ffi::c_int,
        >,
        __cmp: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
    #[link_name = "\u{1}alphasort64"]
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> core::ffi::c_int;
    #[link_name = "\u{1}getdirentries64"]
    pub fn getdirentries(
        __fd: core::ffi::c_int,
        __buf: *mut core::ffi::c_char,
        __nbytes: usize,
        __basep: *mut __off64_t,
    ) -> __ssize_t;
    #[link_name = "\u{1}versionsort64"]
    pub fn versionsort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> core::ffi::c_int;
    pub fn getdents64(
        __fd: core::ffi::c_int,
        __buffer: *mut core::ffi::c_void,
        __length: usize,
    ) -> __ssize_t;
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
    pub fn g_dir_rewind(dir: *mut GDir);
    pub fn g_dir_close(dir: *mut GDir);
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
    pub fn g_unsetenv(variable: *const gchar);
    pub fn g_listenv() -> *mut *mut gchar;
    pub fn g_get_environ() -> *mut *mut gchar;
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
    pub fn g_file_error_quark() -> GQuark;
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_file_set_contents_full(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        flags: GFileSetContentsFlags,
        mode: core::ffi::c_int,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
    pub fn g_build_filename_valist(first_element: *const gchar, args: *mut va_list) -> *mut gchar;
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
    pub fn g_get_current_dir() -> *mut gchar;
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
    pub fn g_canonicalize_filename(filename: *const gchar, relative_to: *const gchar)
        -> *mut gchar;
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
    pub fn g_free(mem: gpointer);
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
    pub fn g_aligned_alloc(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
    pub fn g_aligned_alloc0(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
    pub fn g_aligned_free(mem: gpointer);
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
    pub fn g_mem_is_system_malloc() -> gboolean;
    pub static mut g_mem_gc_friendly: gboolean;
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
    pub fn g_mem_profile();
    pub fn g_node_new(data: gpointer) -> *mut GNode;
    pub fn g_node_destroy(root: *mut GNode);
    pub fn g_node_unlink(node: *mut GNode);
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
    pub fn g_node_depth(node: *mut GNode) -> guint;
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
    pub fn g_node_max_height(root: *mut GNode) -> guint;
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
    pub fn g_node_reverse_children(node: *mut GNode);
    pub fn g_node_n_children(node: *mut GNode) -> guint;
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
    pub fn g_list_alloc() -> *mut GList;
    pub fn g_list_free(list: *mut GList);
    pub fn g_list_free_1(list: *mut GList);
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
    pub fn g_list_insert_before_link(
        list: *mut GList,
        sibling: *mut GList,
        link_: *mut GList,
    ) -> *mut GList;
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
    pub fn g_list_last(list: *mut GList) -> *mut GList;
    pub fn g_list_first(list: *mut GList) -> *mut GList;
    pub fn g_list_length(list: *mut GList) -> guint;
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
    pub fn g_clear_list(list_ptr: *mut *mut GList, destroy: GDestroyNotify);
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
    pub fn g_hash_table_new_similar(other_hash_table: *mut GHashTable) -> *mut GHashTable;
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_steal_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        stolen_key: *mut gpointer,
        stolen_value: *mut gpointer,
    ) -> gboolean;
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_str_hash(v: gconstpointer) -> guint;
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int_hash(v: gconstpointer) -> guint;
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_int64_hash(v: gconstpointer) -> guint;
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_double_hash(v: gconstpointer) -> guint;
    pub fn g_direct_hash(v: gconstpointer) -> guint;
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
        -> *mut GHmac;
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
    pub fn g_hmac_unref(hmac: *mut GHmac);
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
    pub fn g_slist_alloc() -> *mut GSList;
    pub fn g_slist_free(list: *mut GSList);
    pub fn g_slist_free_1(list: *mut GSList);
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
    pub fn g_slist_length(list: *mut GSList) -> guint;
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
    pub fn g_clear_slist(slist_ptr: *mut *mut GSList, destroy: GDestroyNotify);
    pub fn g_main_context_new() -> *mut GMainContext;
    pub fn g_main_context_new_with_flags(flags: GMainContextFlags) -> *mut GMainContext;
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
    pub fn g_main_context_unref(context: *mut GMainContext);
    pub fn g_main_context_default() -> *mut GMainContext;
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
    pub fn g_main_context_wakeup(context: *mut GMainContext);
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_release(context: *mut GMainContext);
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
    pub fn g_main_context_dispatch(context: *mut GMainContext);
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
    pub fn g_main_depth() -> gint;
    pub fn g_main_current_source() -> *mut GSource;
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
    pub fn g_source_set_dispose_function(source: *mut GSource, dispose: GSourceDisposeFunc);
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
    pub fn g_source_unref(source: *mut GSource);
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
    pub fn g_source_destroy(source: *mut GSource);
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
    pub fn g_source_get_id(source: *mut GSource) -> guint;
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
    pub fn g_source_set_name(source: *mut GSource, name: *const core::ffi::c_char);
    pub fn g_source_set_static_name(source: *mut GSource, name: *const core::ffi::c_char);
    pub fn g_source_get_name(source: *mut GSource) -> *const core::ffi::c_char;
    pub fn g_source_set_name_by_id(tag: guint, name: *const core::ffi::c_char);
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
    pub fn g_idle_source_new() -> *mut GSource;
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
    pub fn g_get_current_time(result: *mut GTimeVal);
    pub fn g_get_monotonic_time() -> gint64;
    pub fn g_get_real_time() -> gint64;
    pub fn g_source_remove(tag: guint) -> gboolean;
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
    pub fn g_clear_handle_id(tag_ptr: *mut guint, clear_func: GClearHandleFunc);
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
    pub fn g_timeout_add_once(interval: guint, function: GSourceOnceFunc, data: gpointer) -> guint;
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
    pub fn g_idle_add_once(function: GSourceOnceFunc, data: gpointer) -> guint;
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
    pub static mut g_timeout_funcs: GSourceFuncs;
    pub static mut g_child_watch_funcs: GSourceFuncs;
    pub static mut g_idle_funcs: GSourceFuncs;
    pub static mut g_unix_signal_funcs: GSourceFuncs;
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
        -> *mut gunichar;
    pub static g_utf8_skip: *const gchar;
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
    pub fn g_utf8_offset_to_pointer(str_: *const gchar, offset: glong) -> *mut gchar;
    pub fn g_utf8_pointer_to_offset(str_: *const gchar, pos: *const gchar) -> glong;
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
    pub fn g_utf8_find_prev_char(str_: *const gchar, p: *const gchar) -> *mut gchar;
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
    pub fn g_utf8_substring(str_: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
    pub fn g_utf8_strreverse(str_: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_to_utf16(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
    pub fn g_utf8_to_ucs4(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
    pub fn g_utf8_to_ucs4_fast(
        str_: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
    pub fn g_utf16_to_ucs4(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
    pub fn g_utf16_to_utf8(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_ucs4_to_utf16(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
    pub fn g_ucs4_to_utf8(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
    pub fn g_utf8_validate(str_: *const gchar, max_len: gssize, end: *mut *const gchar)
        -> gboolean;
    pub fn g_utf8_validate_len(
        str_: *const gchar,
        max_len: gsize,
        end: *mut *const gchar,
    ) -> gboolean;
    pub fn g_utf8_strup(str_: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_casefold(str_: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_normalize(str_: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
    pub fn g_utf8_collate_key(str_: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_collate_key_for_filename(str_: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_utf8_make_valid(str_: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_string_new(init: *const gchar) -> *mut GString;
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
    pub fn g_string_hash(str_: *const GString) -> guint;
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
        -> *mut GString;
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
    pub fn g_string_replace(
        string: *mut GString,
        find: *const gchar,
        replace: *const gchar,
        limit: guint,
    ) -> guint;
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: *mut __va_list_tag);
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
    pub fn g_string_append_vprintf(
        string: *mut GString,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
    pub fn g_string_down(string: *mut GString) -> *mut GString;
    pub fn g_string_up(string: *mut GString) -> *mut GString;
    pub fn g_io_channel_init(channel: *mut GIOChannel);
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
    pub fn g_io_channel_close(channel: *mut GIOChannel);
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
    pub fn g_io_channel_error_quark() -> GQuark;
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
    pub fn g_io_channel_unix_new(fd: core::ffi::c_int) -> *mut GIOChannel;
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
    pub static mut g_io_watch_funcs: GSourceFuncs;
    pub fn g_key_file_error_quark() -> GQuark;
    pub fn g_key_file_new() -> *mut GKeyFile;
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
    pub fn g_key_file_free(key_file: *mut GKeyFile);
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_key_file_get_locale_for_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
    ) -> *mut gchar;
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
    pub fn g_mapped_file_free(file: *mut GMappedFile);
    pub fn g_markup_error_quark() -> GQuark;
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
    pub fn g_markup_printf_escaped(format: *const core::ffi::c_char, ...) -> *mut gchar;
    pub fn g_markup_vprintf_escaped(
        format: *const core::ffi::c_char,
        args: *mut __va_list_tag,
    ) -> *mut gchar;
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
    pub fn g_variant_type_free(type_: *mut GVariantType);
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
    pub fn g_variant_type_string_get_depth_(type_string: *const gchar) -> gsize;
    pub fn g_variant_unref(value: *mut GVariant);
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
    pub fn g_variant_new_byte(value: guint8) -> *mut GVariant;
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
    pub fn g_variant_get_byte(value: *mut GVariant) -> guint8;
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: gsize) -> *mut GVariant;
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
    pub fn g_variant_hash(value: gconstpointer) -> guint;
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
    pub fn g_variant_parser_get_error_quark() -> GQuark;
    pub fn g_variant_parse_error_quark() -> GQuark;
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
    pub fn g_printf_string_upper_bound(format: *const gchar, args: *mut __va_list_tag) -> gsize;
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
    pub fn g_log_writer_default_set_use_stderr(use_stderr: gboolean);
    pub fn g_log_writer_default_would_drop(
        log_level: GLogLevelFlags,
        log_domain: *const core::ffi::c_char,
    ) -> gboolean;
    pub fn g_log_get_debug_enabled() -> gboolean;
    pub fn g_log_set_debug_enabled(enabled: gboolean);
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
    pub fn g_return_if_fail_warning(
        log_domain: *const core::ffi::c_char,
        pretty_function: *const core::ffi::c_char,
        expression: *const core::ffi::c_char,
    );
    pub fn g_warn_message(
        domain: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        warnexpr: *const core::ffi::c_char,
    );
    pub fn g_assert_warning(
        log_domain: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        pretty_function: *const core::ffi::c_char,
        expression: *const core::ffi::c_char,
    ) -> !;
    pub fn g_log_structured_standard(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        file: *const gchar,
        line: *const gchar,
        func: *const gchar,
        message_format: *const gchar,
        ...
    );
    pub fn g_print(format: *const gchar, ...);
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_printerr(format: *const gchar, ...);
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
    pub fn g_option_error_quark() -> GQuark;
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
    pub fn g_option_context_free(context: *mut GOptionContext);
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
    pub fn g_option_group_free(group: *mut GOptionGroup);
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
    pub fn g_option_group_unref(group: *mut GOptionGroup);
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
    pub fn g_pattern_spec_copy(pspec: *mut GPatternSpec) -> *mut GPatternSpec;
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
    pub fn g_pattern_spec_match(
        pspec: *mut GPatternSpec,
        string_length: gsize,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
    pub fn g_pattern_spec_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
    pub fn g_spaced_primes_closest(num: guint) -> guint;
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_queue_new() -> *mut GQueue;
    pub fn g_queue_free(queue: *mut GQueue);
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
    pub fn g_queue_init(queue: *mut GQueue);
    pub fn g_queue_clear(queue: *mut GQueue);
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
    pub fn g_queue_clear_full(queue: *mut GQueue, free_func: GDestroyNotify);
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
    pub fn g_queue_reverse(queue: *mut GQueue);
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
    pub fn g_queue_insert_before_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
    pub fn g_queue_insert_after_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
    pub fn g_rand_new() -> *mut GRand;
    pub fn g_rand_free(rand_: *mut GRand);
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
    pub fn g_random_set_seed(seed: guint32);
    pub fn g_random_int() -> guint32;
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
    pub fn g_random_double() -> gdouble;
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
    pub fn g_rc_box_alloc(block_size: gsize) -> gpointer;
    pub fn g_rc_box_alloc0(block_size: gsize) -> gpointer;
    pub fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
    pub fn g_rc_box_acquire(mem_block: gpointer) -> gpointer;
    pub fn g_rc_box_release(mem_block: gpointer);
    pub fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
    pub fn g_rc_box_get_size(mem_block: gpointer) -> gsize;
    pub fn g_atomic_rc_box_alloc(block_size: gsize) -> gpointer;
    pub fn g_atomic_rc_box_alloc0(block_size: gsize) -> gpointer;
    pub fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
    pub fn g_atomic_rc_box_acquire(mem_block: gpointer) -> gpointer;
    pub fn g_atomic_rc_box_release(mem_block: gpointer);
    pub fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
    pub fn g_atomic_rc_box_get_size(mem_block: gpointer) -> gsize;
    pub fn g_ref_count_init(rc: *mut grefcount);
    pub fn g_ref_count_inc(rc: *mut grefcount);
    pub fn g_ref_count_dec(rc: *mut grefcount) -> gboolean;
    pub fn g_ref_count_compare(rc: *mut grefcount, val: gint) -> gboolean;
    pub fn g_atomic_ref_count_init(arc: *mut gatomicrefcount);
    pub fn g_atomic_ref_count_inc(arc: *mut gatomicrefcount);
    pub fn g_atomic_ref_count_dec(arc: *mut gatomicrefcount) -> gboolean;
    pub fn g_atomic_ref_count_compare(arc: *mut gatomicrefcount, val: gint) -> gboolean;
    pub fn g_ref_string_new(str_: *const core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn g_ref_string_new_len(
        str_: *const core::ffi::c_char,
        len: gssize,
    ) -> *mut core::ffi::c_char;
    pub fn g_ref_string_new_intern(str_: *const core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn g_ref_string_acquire(str_: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn g_ref_string_release(str_: *mut core::ffi::c_char);
    pub fn g_ref_string_length(str_: *mut core::ffi::c_char) -> gsize;
    pub fn g_regex_error_quark() -> GQuark;
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
    pub fn g_regex_unref(regex: *mut GRegex);
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
    pub fn g_scanner_destroy(scanner: *mut GScanner);
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
    pub fn g_sequence_free(seq: *mut GSequence);
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
    pub fn g_shell_error_quark() -> GQuark;
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
    pub fn g_spawn_error_quark() -> GQuark;
    pub fn g_spawn_exit_error_quark() -> GQuark;
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_spawn_async_with_pipes_and_fds(
        working_directory: *const gchar,
        argv: *const *const gchar,
        envp: *const *const gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        source_fds: *const gint,
        target_fds: *const gint,
        n_fds: gsize,
        child_pid_out: *mut GPid,
        stdin_pipe_out: *mut gint,
        stdout_pipe_out: *mut gint,
        stderr_pipe_out: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_spawn_async_with_fds(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_spawn_check_wait_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_check_exit_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
    pub fn g_spawn_close_pid(pid: GPid);
    pub static g_ascii_table: *const guint16;
    pub fn g_ascii_tolower(c: gchar) -> gchar;
    pub fn g_ascii_toupper(c: gchar) -> gchar;
    pub fn g_ascii_digit_value(c: gchar) -> gint;
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
    pub fn g_strerror(errnum: gint) -> *const gchar;
    pub fn g_strsignal(signum: gint) -> *const gchar;
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
    pub fn g_str_has_suffix(str_: *const gchar, suffix: *const gchar) -> gboolean;
    pub fn g_str_has_prefix(str_: *const gchar, prefix: *const gchar) -> gboolean;
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
    pub fn g_ascii_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_ascii_strup(str_: *const gchar, len: gssize) -> *mut gchar;
    pub fn g_str_is_ascii(str_: *const gchar) -> gboolean;
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
    pub fn g_strdup(str_: *const gchar) -> *mut gchar;
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
    pub fn g_strdup_vprintf(format: *const gchar, args: *mut __va_list_tag) -> *mut gchar;
    pub fn g_strndup(str_: *const gchar, n: gsize) -> *mut gchar;
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
    pub fn g_memdup2(mem: gconstpointer, byte_size: gsize) -> gpointer;
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
    pub fn g_strfreev(str_array: *mut *mut gchar);
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
    pub fn g_stpcpy(dest: *mut gchar, src: *const core::ffi::c_char) -> *mut gchar;
    pub fn g_str_to_ascii(str_: *const gchar, from_locale: *const gchar) -> *mut gchar;
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
    pub fn g_strv_contains(strv: *const *const gchar, str_: *const gchar) -> gboolean;
    pub fn g_strv_equal(strv1: *const *const gchar, strv2: *const *const gchar) -> gboolean;
    pub fn g_number_parser_error_quark() -> GQuark;
    pub fn g_ascii_string_to_signed(
        str_: *const gchar,
        base: guint,
        min: gint64,
        max: gint64,
        out_num: *mut gint64,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_ascii_string_to_unsigned(
        str_: *const gchar,
        base: guint,
        min: guint64,
        max: guint64,
        out_num: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
    pub fn g_strv_builder_new() -> *mut GStrvBuilder;
    pub fn g_strv_builder_unref(builder: *mut GStrvBuilder);
    pub fn g_strv_builder_ref(builder: *mut GStrvBuilder) -> *mut GStrvBuilder;
    pub fn g_strv_builder_add(builder: *mut GStrvBuilder, value: *const core::ffi::c_char);
    pub fn g_strv_builder_addv(builder: *mut GStrvBuilder, value: *mut *const core::ffi::c_char);
    pub fn g_strv_builder_add_many(builder: *mut GStrvBuilder, ...);
    pub fn g_strv_builder_end(builder: *mut GStrvBuilder) -> GStrv;
    pub fn g_strcmp0(
        str1: *const core::ffi::c_char,
        str2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn g_test_minimized_result(minimized_quantity: f64, format: *const core::ffi::c_char, ...);
    pub fn g_test_maximized_result(maximized_quantity: f64, format: *const core::ffi::c_char, ...);
    pub fn g_test_init(argc: *mut core::ffi::c_int, argv: *mut *mut *mut core::ffi::c_char, ...);
    pub fn g_test_subprocess() -> gboolean;
    pub fn g_test_run() -> core::ffi::c_int;
    pub fn g_test_add_func(testpath: *const core::ffi::c_char, test_func: GTestFunc);
    pub fn g_test_add_data_func(
        testpath: *const core::ffi::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
    pub fn g_test_add_data_func_full(
        testpath: *const core::ffi::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
    pub fn g_test_get_path() -> *const core::ffi::c_char;
    pub fn g_test_fail();
    pub fn g_test_fail_printf(format: *const core::ffi::c_char, ...);
    pub fn g_test_incomplete(msg: *const gchar);
    pub fn g_test_incomplete_printf(format: *const core::ffi::c_char, ...);
    pub fn g_test_skip(msg: *const gchar);
    pub fn g_test_skip_printf(format: *const core::ffi::c_char, ...);
    pub fn g_test_failed() -> gboolean;
    pub fn g_test_set_nonfatal_assertions();
    pub fn g_test_message(format: *const core::ffi::c_char, ...);
    pub fn g_test_bug_base(uri_pattern: *const core::ffi::c_char);
    pub fn g_test_bug(bug_uri_snippet: *const core::ffi::c_char);
    pub fn g_test_summary(summary: *const core::ffi::c_char);
    pub fn g_test_timer_start();
    pub fn g_test_timer_elapsed() -> f64;
    pub fn g_test_timer_last() -> f64;
    pub fn g_test_queue_free(gfree_pointer: gpointer);
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
    pub fn g_test_trap_subprocess(
        test_path: *const core::ffi::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
    pub fn g_test_trap_has_passed() -> gboolean;
    pub fn g_test_trap_reached_timeout() -> gboolean;
    pub fn g_test_rand_int() -> gint32;
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
    pub fn g_test_rand_double() -> f64;
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
    pub fn g_test_create_case(
        test_name: *const core::ffi::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
    pub fn g_test_create_suite(suite_name: *const core::ffi::c_char) -> *mut GTestSuite;
    pub fn g_test_get_root() -> *mut GTestSuite;
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> core::ffi::c_int;
    pub fn g_test_case_free(test_case: *mut GTestCase);
    pub fn g_test_suite_free(suite: *mut GTestSuite);
    pub fn g_test_trap_assertions(
        domain: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        assertion_flags: guint64,
        pattern: *const core::ffi::c_char,
    );
    pub fn g_assertion_message(
        domain: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        message: *const core::ffi::c_char,
    );
    pub fn g_assertion_message_expr(
        domain: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        expr: *const core::ffi::c_char,
    ) -> !;
    pub fn g_assertion_message_cmpstr(
        domain: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        expr: *const core::ffi::c_char,
        arg1: *const core::ffi::c_char,
        cmp: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    );
    pub fn g_assertion_message_cmpstrv(
        domain: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        expr: *const core::ffi::c_char,
        arg1: *const *const core::ffi::c_char,
        arg2: *const *const core::ffi::c_char,
        first_wrong_idx: gsize,
    );
    pub fn g_assertion_message_cmpnum(
        domain: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        expr: *const core::ffi::c_char,
        arg1: u128,
        cmp: *const core::ffi::c_char,
        arg2: u128,
        numtype: core::ffi::c_char,
    );
    pub fn g_assertion_message_error(
        domain: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        expr: *const core::ffi::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: core::ffi::c_int,
    );
    pub fn g_test_add_vtable(
        testpath: *const core::ffi::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
    pub static g_test_config_vars: *const GTestConfig;
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const core::ffi::c_char;
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
    pub fn g_test_assert_expected_messages_internal(
        domain: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
    );
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
    pub fn g_thread_pool_new_full(
        func: GFunc,
        user_data: gpointer,
        item_free_func: GDestroyNotify,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
    pub fn g_thread_pool_stop_unused_threads();
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
    pub fn g_thread_pool_get_max_idle_time() -> guint;
    pub fn g_timer_new() -> *mut GTimer;
    pub fn g_timer_destroy(timer: *mut GTimer);
    pub fn g_timer_start(timer: *mut GTimer);
    pub fn g_timer_stop(timer: *mut GTimer);
    pub fn g_timer_reset(timer: *mut GTimer);
    pub fn g_timer_continue(timer: *mut GTimer);
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
    pub fn g_timer_is_active(timer: *mut GTimer) -> gboolean;
    pub fn g_usleep(microseconds: gulong);
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
    pub fn g_tree_node_first(tree: *mut GTree) -> *mut GTreeNode;
    pub fn g_tree_node_last(tree: *mut GTree) -> *mut GTreeNode;
    pub fn g_tree_node_previous(node: *mut GTreeNode) -> *mut GTreeNode;
    pub fn g_tree_node_next(node: *mut GTreeNode) -> *mut GTreeNode;
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
    pub fn g_tree_unref(tree: *mut GTree);
    pub fn g_tree_destroy(tree: *mut GTree);
    pub fn g_tree_insert_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_replace_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_remove_all(tree: *mut GTree);
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
    pub fn g_tree_node_key(node: *mut GTreeNode) -> gpointer;
    pub fn g_tree_node_value(node: *mut GTreeNode) -> gpointer;
    pub fn g_tree_lookup_node(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
    pub fn g_tree_foreach_node(tree: *mut GTree, func: GTraverseNodeFunc, user_data: gpointer);
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
    pub fn g_tree_search_node(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> *mut GTreeNode;
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
    pub fn g_tree_lower_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
    pub fn g_tree_upper_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
    pub fn g_tree_height(tree: *mut GTree) -> gint;
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
    pub fn g_uri_ref(uri: *mut GUri) -> *mut GUri;
    pub fn g_uri_unref(uri: *mut GUri);
    pub fn g_uri_split(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        userinfo: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_uri_split_with_user(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        user: *mut *mut gchar,
        password: *mut *mut gchar,
        auth_params: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_uri_split_network(
        uri_string: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_uri_is_valid(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_uri_join(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
    pub fn g_uri_join_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
    pub fn g_uri_parse(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
    pub fn g_uri_parse_relative(
        base_uri: *mut GUri,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
    pub fn g_uri_resolve_relative(
        base_uri_string: *const gchar,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
    pub fn g_uri_build(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
    pub fn g_uri_build_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
    pub fn g_uri_to_string(uri: *mut GUri) -> *mut core::ffi::c_char;
    pub fn g_uri_to_string_partial(uri: *mut GUri, flags: GUriHideFlags) -> *mut core::ffi::c_char;
    pub fn g_uri_get_scheme(uri: *mut GUri) -> *const gchar;
    pub fn g_uri_get_userinfo(uri: *mut GUri) -> *const gchar;
    pub fn g_uri_get_user(uri: *mut GUri) -> *const gchar;
    pub fn g_uri_get_password(uri: *mut GUri) -> *const gchar;
    pub fn g_uri_get_auth_params(uri: *mut GUri) -> *const gchar;
    pub fn g_uri_get_host(uri: *mut GUri) -> *const gchar;
    pub fn g_uri_get_port(uri: *mut GUri) -> gint;
    pub fn g_uri_get_path(uri: *mut GUri) -> *const gchar;
    pub fn g_uri_get_query(uri: *mut GUri) -> *const gchar;
    pub fn g_uri_get_fragment(uri: *mut GUri) -> *const gchar;
    pub fn g_uri_get_flags(uri: *mut GUri) -> GUriFlags;
    pub fn g_uri_parse_params(
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
        error: *mut *mut GError,
    ) -> *mut GHashTable;
    pub fn g_uri_params_iter_init(
        iter: *mut GUriParamsIter,
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
    );
    pub fn g_uri_params_iter_next(
        iter: *mut GUriParamsIter,
        attribute: *mut *mut gchar,
        value: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_uri_error_quark() -> GQuark;
    pub fn g_uri_unescape_string(
        escaped_string: *const core::ffi::c_char,
        illegal_characters: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn g_uri_unescape_segment(
        escaped_string: *const core::ffi::c_char,
        escaped_string_end: *const core::ffi::c_char,
        illegal_characters: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn g_uri_parse_scheme(uri: *const core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn g_uri_peek_scheme(uri: *const core::ffi::c_char) -> *const core::ffi::c_char;
    pub fn g_uri_escape_string(
        unescaped: *const core::ffi::c_char,
        reserved_chars_allowed: *const core::ffi::c_char,
        allow_utf8: gboolean,
    ) -> *mut core::ffi::c_char;
    pub fn g_uri_unescape_bytes(
        escaped_string: *const core::ffi::c_char,
        length: gssize,
        illegal_characters: *const core::ffi::c_char,
        error: *mut *mut GError,
    ) -> *mut GBytes;
    pub fn g_uri_escape_bytes(
        unescaped: *const guint8,
        length: gsize,
        reserved_chars_allowed: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn g_uuid_string_is_valid(str_: *const gchar) -> gboolean;
    pub fn g_uuid_string_random() -> *mut gchar;
    pub static glib_major_version: guint;
    pub static glib_minor_version: guint;
    pub static glib_micro_version: guint;
    pub static glib_interface_age: guint;
    pub static glib_binary_age: guint;
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
    pub fn g_mem_chunk_info();
    pub fn g_blow_chunks();
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
    pub fn g_allocator_free(allocator: *mut GAllocator);
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
    pub fn g_list_pop_allocator();
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
    pub fn g_slist_pop_allocator();
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
    pub fn g_node_pop_allocator();
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
    pub fn g_cache_destroy(cache: *mut GCache);
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
    pub fn g_completion_free(cmp: *mut GCompletion);
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
    pub fn g_relation_destroy(relation: *mut GRelation);
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
    pub fn g_relation_insert(relation: *mut GRelation, ...);
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
    pub fn g_relation_print(relation: *mut GRelation);
    pub fn g_tuples_destroy(tuples: *mut GTuples);
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
    pub static mut g_thread_use_default_impl: gboolean;
    pub static mut g_thread_gettime: ::core::option::Option<unsafe extern "C" fn() -> guint64>;
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
    pub fn clone(
        __fn: ::core::option::Option<
            unsafe extern "C" fn(__arg: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
        __child_stack: *mut core::ffi::c_void,
        __flags: core::ffi::c_int,
        __arg: *mut core::ffi::c_void,
        ...
    ) -> core::ffi::c_int;
    pub fn unshare(__flags: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sched_getcpu() -> core::ffi::c_int;
    pub fn getcpu(arg1: *mut core::ffi::c_uint, arg2: *mut core::ffi::c_uint) -> core::ffi::c_int;
    pub fn setns(__fd: core::ffi::c_int, __nstype: core::ffi::c_int) -> core::ffi::c_int;
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> core::ffi::c_int;
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> core::ffi::c_int;
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> core::ffi::c_int;
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: core::ffi::c_int,
        __param: *const sched_param,
    ) -> core::ffi::c_int;
    pub fn sched_getscheduler(__pid: __pid_t) -> core::ffi::c_int;
    pub fn sched_yield() -> core::ffi::c_int;
    pub fn sched_get_priority_max(__algorithm: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sched_get_priority_min(__algorithm: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> core::ffi::c_int;
    pub fn sched_setaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> core::ffi::c_int;
    pub fn sched_getaffinity(
        __pid: __pid_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> core::ffi::c_int;
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> *mut core::ffi::c_void,
        >,
        __arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn pthread_exit(__retval: *mut core::ffi::c_void) -> !;
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn pthread_tryjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn pthread_timedjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut core::ffi::c_void,
        __abstime: *const timespec,
    ) -> core::ffi::c_int;
    pub fn pthread_clockjoin_np(
        __th: pthread_t,
        __thread_return: *mut *mut core::ffi::c_void,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> core::ffi::c_int;
    pub fn pthread_detach(__th: pthread_t) -> core::ffi::c_int;
    pub fn pthread_self() -> pthread_t;
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> core::ffi::c_int;
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> core::ffi::c_int;
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> core::ffi::c_int;
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut core::ffi::c_void,
        __stacksize: *mut usize,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut core::ffi::c_void,
        __stacksize: usize,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_setaffinity_np(
        __attr: *mut pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_getaffinity_np(
        __attr: *const pthread_attr_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> core::ffi::c_int;
    pub fn pthread_getattr_default_np(__attr: *mut pthread_attr_t) -> core::ffi::c_int;
    pub fn pthread_attr_setsigmask_np(
        __attr: *mut pthread_attr_t,
        sigmask: *const __sigset_t,
    ) -> core::ffi::c_int;
    pub fn pthread_attr_getsigmask_np(
        __attr: *const pthread_attr_t,
        sigmask: *mut __sigset_t,
    ) -> core::ffi::c_int;
    pub fn pthread_setattr_default_np(__attr: *const pthread_attr_t) -> core::ffi::c_int;
    pub fn pthread_getattr_np(__th: pthread_t, __attr: *mut pthread_attr_t) -> core::ffi::c_int;
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: core::ffi::c_int,
        __param: *const sched_param,
    ) -> core::ffi::c_int;
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut core::ffi::c_int,
        __param: *mut sched_param,
    ) -> core::ffi::c_int;
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_getname_np(
        __target_thread: pthread_t,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
    ) -> core::ffi::c_int;
    pub fn pthread_setname_np(
        __target_thread: pthread_t,
        __name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn pthread_getconcurrency() -> core::ffi::c_int;
    pub fn pthread_setconcurrency(__level: core::ffi::c_int) -> core::ffi::c_int;
    pub fn pthread_yield() -> core::ffi::c_int;
    pub fn pthread_setaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *const cpu_set_t,
    ) -> core::ffi::c_int;
    pub fn pthread_getaffinity_np(
        __th: pthread_t,
        __cpusetsize: usize,
        __cpuset: *mut cpu_set_t,
    ) -> core::ffi::c_int;
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> core::ffi::c_int;
    pub fn pthread_setcancelstate(
        __state: core::ffi::c_int,
        __oldstate: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_setcanceltype(
        __type: core::ffi::c_int,
        __oldtype: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_cancel(__th: pthread_t) -> core::ffi::c_int;
    pub fn pthread_testcancel();
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
    pub fn __pthread_register_cancel_defer(__buf: *mut __pthread_unwind_buf_t);
    pub fn __pthread_unregister_cancel_restore(__buf: *mut __pthread_unwind_buf_t);
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> core::ffi::c_int;
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> core::ffi::c_int;
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> core::ffi::c_int;
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> core::ffi::c_int;
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> core::ffi::c_int;
    pub fn pthread_mutex_clocklock(
        __mutex: *mut pthread_mutex_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> core::ffi::c_int;
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> core::ffi::c_int;
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: core::ffi::c_int,
        __old_ceiling: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> core::ffi::c_int;
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> core::ffi::c_int;
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> core::ffi::c_int;
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> core::ffi::c_int;
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> core::ffi::c_int;
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> core::ffi::c_int;
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> core::ffi::c_int;
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> core::ffi::c_int;
    pub fn pthread_rwlock_clockrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> core::ffi::c_int;
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> core::ffi::c_int;
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> core::ffi::c_int;
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> core::ffi::c_int;
    pub fn pthread_rwlock_clockwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __clockid: clockid_t,
        __abstime: *const timespec,
    ) -> core::ffi::c_int;
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> core::ffi::c_int;
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> core::ffi::c_int;
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> core::ffi::c_int;
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> core::ffi::c_int;
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> core::ffi::c_int;
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> core::ffi::c_int;
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> core::ffi::c_int;
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> core::ffi::c_int;
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> core::ffi::c_int;
    pub fn pthread_cond_clockwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __clock_id: __clockid_t,
        __abstime: *const timespec,
    ) -> core::ffi::c_int;
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> core::ffi::c_int;
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> core::ffi::c_int;
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> core::ffi::c_int;
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> core::ffi::c_int;
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> core::ffi::c_int;
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> core::ffi::c_int;
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> core::ffi::c_int;
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> core::ffi::c_int;
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: core::ffi::c_uint,
    ) -> core::ffi::c_int;
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> core::ffi::c_int;
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> core::ffi::c_int;
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> core::ffi::c_int;
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t) -> core::ffi::c_int;
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void),
        >,
    ) -> core::ffi::c_int;
    pub fn pthread_key_delete(__key: pthread_key_t) -> core::ffi::c_int;
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut core::ffi::c_void;
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> core::ffi::c_int;
    pub fn pthread_atfork(
        __prepare: ::core::option::Option<unsafe extern "C" fn()>,
        __parent: ::core::option::Option<unsafe extern "C" fn()>,
        __child: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> core::ffi::c_int;
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
    pub fn g_thread_init(vtable: gpointer);
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
    pub fn g_thread_get_initialized() -> gboolean;
    pub static mut g_threads_got_initialized: gboolean;
    pub fn g_mutex_new() -> *mut GMutex;
    pub fn g_mutex_free(mutex: *mut GMutex);
    pub fn g_cond_new() -> *mut GCond;
    pub fn g_cond_free(cond: *mut GCond);
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        timeval: *mut GTimeVal,
    ) -> gboolean;
    pub fn g_unix_error_quark() -> GQuark;
    pub fn g_unix_open_pipe(fds: *mut gint, flags: gint, error: *mut *mut GError) -> gboolean;
    pub fn g_unix_set_fd_nonblocking(
        fd: gint,
        nonblock: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
    pub fn g_unix_signal_source_new(signum: gint) -> *mut GSource;
    pub fn g_unix_signal_add_full(
        priority: gint,
        signum: gint,
        handler: GSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
    pub fn g_unix_signal_add(signum: gint, handler: GSourceFunc, user_data: gpointer) -> guint;
    pub fn g_unix_fd_source_new(fd: gint, condition: GIOCondition) -> *mut GSource;
    pub fn g_unix_fd_add_full(
        priority: gint,
        fd: gint,
        condition: GIOCondition,
        function: GUnixFDSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
    pub fn g_unix_fd_add(
        fd: gint,
        condition: GIOCondition,
        function: GUnixFDSourceFunc,
        user_data: gpointer,
    ) -> guint;
    pub fn g_unix_get_passwd_entry(user_name: *const gchar, error: *mut *mut GError)
        -> *mut passwd;
    pub fn setpwent();
    pub fn endpwent();
    pub fn getpwent() -> *mut passwd;
    pub fn fgetpwent(__stream: *mut FILE) -> *mut passwd;
    pub fn putpwent(__p: *const passwd, __f: *mut FILE) -> core::ffi::c_int;
    pub fn getpwuid(__uid: __uid_t) -> *mut passwd;
    pub fn getpwnam(__name: *const core::ffi::c_char) -> *mut passwd;
    pub fn getpwent_r(
        __resultbuf: *mut passwd,
        __buffer: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> core::ffi::c_int;
    pub fn getpwuid_r(
        __uid: __uid_t,
        __resultbuf: *mut passwd,
        __buffer: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> core::ffi::c_int;
    pub fn getpwnam_r(
        __name: *const core::ffi::c_char,
        __resultbuf: *mut passwd,
        __buffer: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> core::ffi::c_int;
    pub fn fgetpwent_r(
        __stream: *mut FILE,
        __resultbuf: *mut passwd,
        __buffer: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut passwd,
    ) -> core::ffi::c_int;
    pub fn getpw(__uid: __uid_t, __buffer: *mut core::ffi::c_char) -> core::ffi::c_int;
    pub fn memfd_create(
        __name: *const core::ffi::c_char,
        __flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
    pub fn mlock2(
        __addr: *const core::ffi::c_void,
        __length: usize,
        __flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
    pub fn pkey_alloc(
        __flags: core::ffi::c_uint,
        __access_rights: core::ffi::c_uint,
    ) -> core::ffi::c_int;
    pub fn pkey_set(
        __key: core::ffi::c_int,
        __access_rights: core::ffi::c_uint,
    ) -> core::ffi::c_int;
    pub fn pkey_get(__key: core::ffi::c_int) -> core::ffi::c_int;
    pub fn pkey_free(__key: core::ffi::c_int) -> core::ffi::c_int;
    pub fn pkey_mprotect(
        __addr: *mut core::ffi::c_void,
        __len: usize,
        __prot: core::ffi::c_int,
        __pkey: core::ffi::c_int,
    ) -> core::ffi::c_int;
    #[link_name = "\u{1}mmap64"]
    pub fn mmap(
        __addr: *mut core::ffi::c_void,
        __len: usize,
        __prot: core::ffi::c_int,
        __flags: core::ffi::c_int,
        __fd: core::ffi::c_int,
        __offset: __off64_t,
    ) -> *mut core::ffi::c_void;
    pub fn munmap(__addr: *mut core::ffi::c_void, __len: usize) -> core::ffi::c_int;
    pub fn mprotect(
        __addr: *mut core::ffi::c_void,
        __len: usize,
        __prot: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn msync(
        __addr: *mut core::ffi::c_void,
        __len: usize,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn madvise(
        __addr: *mut core::ffi::c_void,
        __len: usize,
        __advice: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn posix_madvise(
        __addr: *mut core::ffi::c_void,
        __len: usize,
        __advice: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn mlock(__addr: *const core::ffi::c_void, __len: usize) -> core::ffi::c_int;
    pub fn munlock(__addr: *const core::ffi::c_void, __len: usize) -> core::ffi::c_int;
    pub fn mlockall(__flags: core::ffi::c_int) -> core::ffi::c_int;
    pub fn munlockall() -> core::ffi::c_int;
    pub fn mincore(
        __start: *mut core::ffi::c_void,
        __len: usize,
        __vec: *mut core::ffi::c_uchar,
    ) -> core::ffi::c_int;
    pub fn mremap(
        __addr: *mut core::ffi::c_void,
        __old_len: usize,
        __new_len: usize,
        __flags: core::ffi::c_int,
        ...
    ) -> *mut core::ffi::c_void;
    pub fn remap_file_pages(
        __start: *mut core::ffi::c_void,
        __size: usize,
        __prot: core::ffi::c_int,
        __pgoff: usize,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn shm_open(
        __name: *const core::ffi::c_char,
        __oflag: core::ffi::c_int,
        __mode: mode_t,
    ) -> core::ffi::c_int;
    pub fn shm_unlink(__name: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn process_madvise(
        __pid_fd: core::ffi::c_int,
        __iov: *const iovec,
        __count: usize,
        __advice: core::ffi::c_int,
        __flags: core::ffi::c_uint,
    ) -> __ssize_t;
    pub fn process_mrelease(pidfd: core::ffi::c_int, flags: core::ffi::c_uint) -> core::ffi::c_int;
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr) -> *mut cmsghdr;
    pub fn socket(
        __domain: core::ffi::c_int,
        __type: core::ffi::c_int,
        __protocol: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn socketpair(
        __domain: core::ffi::c_int,
        __type: core::ffi::c_int,
        __protocol: core::ffi::c_int,
        __fds: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn bind(
        __fd: core::ffi::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __len: socklen_t,
    ) -> core::ffi::c_int;
    pub fn getsockname(
        __fd: core::ffi::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> core::ffi::c_int;
    pub fn connect(
        __fd: core::ffi::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __len: socklen_t,
    ) -> core::ffi::c_int;
    pub fn getpeername(
        __fd: core::ffi::c_int,
        __addr: __SOCKADDR_ARG,
        __len: *mut socklen_t,
    ) -> core::ffi::c_int;
    pub fn send(
        __fd: core::ffi::c_int,
        __buf: *const core::ffi::c_void,
        __n: usize,
        __flags: core::ffi::c_int,
    ) -> isize;
    pub fn recv(
        __fd: core::ffi::c_int,
        __buf: *mut core::ffi::c_void,
        __n: usize,
        __flags: core::ffi::c_int,
    ) -> isize;
    pub fn sendto(
        __fd: core::ffi::c_int,
        __buf: *const core::ffi::c_void,
        __n: usize,
        __flags: core::ffi::c_int,
        __addr: __CONST_SOCKADDR_ARG,
        __addr_len: socklen_t,
    ) -> isize;
    pub fn recvfrom(
        __fd: core::ffi::c_int,
        __buf: *mut core::ffi::c_void,
        __n: usize,
        __flags: core::ffi::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> isize;
    pub fn sendmsg(
        __fd: core::ffi::c_int,
        __message: *const msghdr,
        __flags: core::ffi::c_int,
    ) -> isize;
    pub fn sendmmsg(
        __fd: core::ffi::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: core::ffi::c_uint,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn recvmsg(
        __fd: core::ffi::c_int,
        __message: *mut msghdr,
        __flags: core::ffi::c_int,
    ) -> isize;
    pub fn recvmmsg(
        __fd: core::ffi::c_int,
        __vmessages: *mut mmsghdr,
        __vlen: core::ffi::c_uint,
        __flags: core::ffi::c_int,
        __tmo: *mut timespec,
    ) -> core::ffi::c_int;
    pub fn getsockopt(
        __fd: core::ffi::c_int,
        __level: core::ffi::c_int,
        __optname: core::ffi::c_int,
        __optval: *mut core::ffi::c_void,
        __optlen: *mut socklen_t,
    ) -> core::ffi::c_int;
    pub fn setsockopt(
        __fd: core::ffi::c_int,
        __level: core::ffi::c_int,
        __optname: core::ffi::c_int,
        __optval: *const core::ffi::c_void,
        __optlen: socklen_t,
    ) -> core::ffi::c_int;
    pub fn listen(__fd: core::ffi::c_int, __n: core::ffi::c_int) -> core::ffi::c_int;
    pub fn accept(
        __fd: core::ffi::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
    ) -> core::ffi::c_int;
    pub fn accept4(
        __fd: core::ffi::c_int,
        __addr: __SOCKADDR_ARG,
        __addr_len: *mut socklen_t,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn shutdown(__fd: core::ffi::c_int, __how: core::ffi::c_int) -> core::ffi::c_int;
    pub fn sockatmark(__fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn isfdtype(__fd: core::ffi::c_int, __fdtype: core::ffi::c_int) -> core::ffi::c_int;
    pub static in6addr_any: in6_addr;
    pub static in6addr_loopback: in6_addr;
    pub fn ntohl(__netlong: u32) -> u32;
    pub fn ntohs(__netshort: u16) -> u16;
    pub fn htonl(__hostlong: u32) -> u32;
    pub fn htons(__hostshort: u16) -> u16;
    pub fn bindresvport(
        __sockfd: core::ffi::c_int,
        __sock_in: *mut sockaddr_in,
    ) -> core::ffi::c_int;
    pub fn bindresvport6(
        __sockfd: core::ffi::c_int,
        __sock_in: *mut sockaddr_in6,
    ) -> core::ffi::c_int;
    pub fn inet6_option_space(__nbytes: core::ffi::c_int) -> core::ffi::c_int;
    pub fn inet6_option_init(
        __bp: *mut core::ffi::c_void,
        __cmsgp: *mut *mut cmsghdr,
        __type: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn inet6_option_append(
        __cmsg: *mut cmsghdr,
        __typep: *const u8,
        __multx: core::ffi::c_int,
        __plusy: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn inet6_option_alloc(
        __cmsg: *mut cmsghdr,
        __datalen: core::ffi::c_int,
        __multx: core::ffi::c_int,
        __plusy: core::ffi::c_int,
    ) -> *mut u8;
    pub fn inet6_option_next(__cmsg: *const cmsghdr, __tptrp: *mut *mut u8) -> core::ffi::c_int;
    pub fn inet6_option_find(
        __cmsg: *const cmsghdr,
        __tptrp: *mut *mut u8,
        __type: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn inet6_opt_init(
        __extbuf: *mut core::ffi::c_void,
        __extlen: socklen_t,
    ) -> core::ffi::c_int;
    pub fn inet6_opt_append(
        __extbuf: *mut core::ffi::c_void,
        __extlen: socklen_t,
        __offset: core::ffi::c_int,
        __type: u8,
        __len: socklen_t,
        __align: u8,
        __databufp: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn inet6_opt_finish(
        __extbuf: *mut core::ffi::c_void,
        __extlen: socklen_t,
        __offset: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn inet6_opt_set_val(
        __databuf: *mut core::ffi::c_void,
        __offset: core::ffi::c_int,
        __val: *mut core::ffi::c_void,
        __vallen: socklen_t,
    ) -> core::ffi::c_int;
    pub fn inet6_opt_next(
        __extbuf: *mut core::ffi::c_void,
        __extlen: socklen_t,
        __offset: core::ffi::c_int,
        __typep: *mut u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn inet6_opt_find(
        __extbuf: *mut core::ffi::c_void,
        __extlen: socklen_t,
        __offset: core::ffi::c_int,
        __type: u8,
        __lenp: *mut socklen_t,
        __databufp: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn inet6_opt_get_val(
        __databuf: *mut core::ffi::c_void,
        __offset: core::ffi::c_int,
        __val: *mut core::ffi::c_void,
        __vallen: socklen_t,
    ) -> core::ffi::c_int;
    pub fn inet6_rth_space(__type: core::ffi::c_int, __segments: core::ffi::c_int) -> socklen_t;
    pub fn inet6_rth_init(
        __bp: *mut core::ffi::c_void,
        __bp_len: socklen_t,
        __type: core::ffi::c_int,
        __segments: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
    pub fn inet6_rth_add(__bp: *mut core::ffi::c_void, __addr: *const in6_addr)
        -> core::ffi::c_int;
    pub fn inet6_rth_reverse(
        __in: *const core::ffi::c_void,
        __out: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn inet6_rth_segments(__bp: *const core::ffi::c_void) -> core::ffi::c_int;
    pub fn inet6_rth_getaddr(
        __bp: *const core::ffi::c_void,
        __index: core::ffi::c_int,
    ) -> *mut in6_addr;
    pub fn getipv4sourcefilter(
        __s: core::ffi::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut in_addr,
    ) -> core::ffi::c_int;
    pub fn setipv4sourcefilter(
        __s: core::ffi::c_int,
        __interface_addr: in_addr,
        __group: in_addr,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const in_addr,
    ) -> core::ffi::c_int;
    pub fn getsourcefilter(
        __s: core::ffi::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: *mut u32,
        __numsrc: *mut u32,
        __slist: *mut sockaddr_storage,
    ) -> core::ffi::c_int;
    pub fn setsourcefilter(
        __s: core::ffi::c_int,
        __interface_addr: u32,
        __group: *const sockaddr,
        __grouplen: socklen_t,
        __fmode: u32,
        __numsrc: u32,
        __slist: *const sockaddr_storage,
    ) -> core::ffi::c_int;
    pub fn inet_addr(__cp: *const core::ffi::c_char) -> in_addr_t;
    pub fn inet_lnaof(__in: in_addr) -> in_addr_t;
    pub fn inet_makeaddr(__net: in_addr_t, __host: in_addr_t) -> in_addr;
    pub fn inet_netof(__in: in_addr) -> in_addr_t;
    pub fn inet_network(__cp: *const core::ffi::c_char) -> in_addr_t;
    pub fn inet_ntoa(__in: in_addr) -> *mut core::ffi::c_char;
    pub fn inet_pton(
        __af: core::ffi::c_int,
        __cp: *const core::ffi::c_char,
        __buf: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn inet_ntop(
        __af: core::ffi::c_int,
        __cp: *const core::ffi::c_void,
        __buf: *mut core::ffi::c_char,
        __len: socklen_t,
    ) -> *const core::ffi::c_char;
    pub fn inet_aton(__cp: *const core::ffi::c_char, __inp: *mut in_addr) -> core::ffi::c_int;
    pub fn inet_neta(
        __net: in_addr_t,
        __buf: *mut core::ffi::c_char,
        __len: usize,
    ) -> *mut core::ffi::c_char;
    pub fn inet_net_ntop(
        __af: core::ffi::c_int,
        __cp: *const core::ffi::c_void,
        __bits: core::ffi::c_int,
        __buf: *mut core::ffi::c_char,
        __len: usize,
    ) -> *mut core::ffi::c_char;
    pub fn inet_net_pton(
        __af: core::ffi::c_int,
        __cp: *const core::ffi::c_char,
        __buf: *mut core::ffi::c_void,
        __len: usize,
    ) -> core::ffi::c_int;
    pub fn inet_nsap_addr(
        __cp: *const core::ffi::c_char,
        __buf: *mut core::ffi::c_uchar,
        __len: core::ffi::c_int,
    ) -> core::ffi::c_uint;
    pub fn inet_nsap_ntoa(
        __len: core::ffi::c_int,
        __cp: *const core::ffi::c_uchar,
        __buf: *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn setrpcent(__stayopen: core::ffi::c_int);
    pub fn endrpcent();
    pub fn getrpcbyname(__name: *const core::ffi::c_char) -> *mut rpcent;
    pub fn getrpcbynumber(__number: core::ffi::c_int) -> *mut rpcent;
    pub fn getrpcent() -> *mut rpcent;
    pub fn getrpcbyname_r(
        __name: *const core::ffi::c_char,
        __result_buf: *mut rpcent,
        __buffer: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> core::ffi::c_int;
    pub fn getrpcbynumber_r(
        __number: core::ffi::c_int,
        __result_buf: *mut rpcent,
        __buffer: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> core::ffi::c_int;
    pub fn getrpcent_r(
        __result_buf: *mut rpcent,
        __buffer: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut rpcent,
    ) -> core::ffi::c_int;
    pub fn __h_errno_location() -> *mut core::ffi::c_int;
    pub fn herror(__str: *const core::ffi::c_char);
    pub fn hstrerror(__err_num: core::ffi::c_int) -> *const core::ffi::c_char;
    pub fn sethostent(__stay_open: core::ffi::c_int);
    pub fn endhostent();
    pub fn gethostent() -> *mut hostent;
    pub fn gethostbyaddr(
        __addr: *const core::ffi::c_void,
        __len: __socklen_t,
        __type: core::ffi::c_int,
    ) -> *mut hostent;
    pub fn gethostbyname(__name: *const core::ffi::c_char) -> *mut hostent;
    pub fn gethostbyname2(__name: *const core::ffi::c_char, __af: core::ffi::c_int)
        -> *mut hostent;
    pub fn gethostent_r(
        __result_buf: *mut hostent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn gethostbyaddr_r(
        __addr: *const core::ffi::c_void,
        __len: __socklen_t,
        __type: core::ffi::c_int,
        __result_buf: *mut hostent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn gethostbyname_r(
        __name: *const core::ffi::c_char,
        __result_buf: *mut hostent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn gethostbyname2_r(
        __name: *const core::ffi::c_char,
        __af: core::ffi::c_int,
        __result_buf: *mut hostent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut hostent,
        __h_errnop: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn setnetent(__stay_open: core::ffi::c_int);
    pub fn endnetent();
    pub fn getnetent() -> *mut netent;
    pub fn getnetbyaddr(__net: u32, __type: core::ffi::c_int) -> *mut netent;
    pub fn getnetbyname(__name: *const core::ffi::c_char) -> *mut netent;
    pub fn getnetent_r(
        __result_buf: *mut netent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn getnetbyaddr_r(
        __net: u32,
        __type: core::ffi::c_int,
        __result_buf: *mut netent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn getnetbyname_r(
        __name: *const core::ffi::c_char,
        __result_buf: *mut netent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut netent,
        __h_errnop: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn setservent(__stay_open: core::ffi::c_int);
    pub fn endservent();
    pub fn getservent() -> *mut servent;
    pub fn getservbyname(
        __name: *const core::ffi::c_char,
        __proto: *const core::ffi::c_char,
    ) -> *mut servent;
    pub fn getservbyport(
        __port: core::ffi::c_int,
        __proto: *const core::ffi::c_char,
    ) -> *mut servent;
    pub fn getservent_r(
        __result_buf: *mut servent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> core::ffi::c_int;
    pub fn getservbyname_r(
        __name: *const core::ffi::c_char,
        __proto: *const core::ffi::c_char,
        __result_buf: *mut servent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> core::ffi::c_int;
    pub fn getservbyport_r(
        __port: core::ffi::c_int,
        __proto: *const core::ffi::c_char,
        __result_buf: *mut servent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut servent,
    ) -> core::ffi::c_int;
    pub fn setprotoent(__stay_open: core::ffi::c_int);
    pub fn endprotoent();
    pub fn getprotoent() -> *mut protoent;
    pub fn getprotobyname(__name: *const core::ffi::c_char) -> *mut protoent;
    pub fn getprotobynumber(__proto: core::ffi::c_int) -> *mut protoent;
    pub fn getprotoent_r(
        __result_buf: *mut protoent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> core::ffi::c_int;
    pub fn getprotobyname_r(
        __name: *const core::ffi::c_char,
        __result_buf: *mut protoent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> core::ffi::c_int;
    pub fn getprotobynumber_r(
        __proto: core::ffi::c_int,
        __result_buf: *mut protoent,
        __buf: *mut core::ffi::c_char,
        __buflen: usize,
        __result: *mut *mut protoent,
    ) -> core::ffi::c_int;
    pub fn setnetgrent(__netgroup: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn endnetgrent();
    pub fn getnetgrent(
        __hostp: *mut *mut core::ffi::c_char,
        __userp: *mut *mut core::ffi::c_char,
        __domainp: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn innetgr(
        __netgroup: *const core::ffi::c_char,
        __host: *const core::ffi::c_char,
        __user: *const core::ffi::c_char,
        __domain: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn getnetgrent_r(
        __hostp: *mut *mut core::ffi::c_char,
        __userp: *mut *mut core::ffi::c_char,
        __domainp: *mut *mut core::ffi::c_char,
        __buffer: *mut core::ffi::c_char,
        __buflen: usize,
    ) -> core::ffi::c_int;
    pub fn rcmd(
        __ahost: *mut *mut core::ffi::c_char,
        __rport: core::ffi::c_ushort,
        __locuser: *const core::ffi::c_char,
        __remuser: *const core::ffi::c_char,
        __cmd: *const core::ffi::c_char,
        __fd2p: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn rcmd_af(
        __ahost: *mut *mut core::ffi::c_char,
        __rport: core::ffi::c_ushort,
        __locuser: *const core::ffi::c_char,
        __remuser: *const core::ffi::c_char,
        __cmd: *const core::ffi::c_char,
        __fd2p: *mut core::ffi::c_int,
        __af: sa_family_t,
    ) -> core::ffi::c_int;
    pub fn rexec(
        __ahost: *mut *mut core::ffi::c_char,
        __rport: core::ffi::c_int,
        __name: *const core::ffi::c_char,
        __pass: *const core::ffi::c_char,
        __cmd: *const core::ffi::c_char,
        __fd2p: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn rexec_af(
        __ahost: *mut *mut core::ffi::c_char,
        __rport: core::ffi::c_int,
        __name: *const core::ffi::c_char,
        __pass: *const core::ffi::c_char,
        __cmd: *const core::ffi::c_char,
        __fd2p: *mut core::ffi::c_int,
        __af: sa_family_t,
    ) -> core::ffi::c_int;
    pub fn ruserok(
        __rhost: *const core::ffi::c_char,
        __suser: core::ffi::c_int,
        __remuser: *const core::ffi::c_char,
        __locuser: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn ruserok_af(
        __rhost: *const core::ffi::c_char,
        __suser: core::ffi::c_int,
        __remuser: *const core::ffi::c_char,
        __locuser: *const core::ffi::c_char,
        __af: sa_family_t,
    ) -> core::ffi::c_int;
    pub fn iruserok(
        __raddr: u32,
        __suser: core::ffi::c_int,
        __remuser: *const core::ffi::c_char,
        __locuser: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn iruserok_af(
        __raddr: *const core::ffi::c_void,
        __suser: core::ffi::c_int,
        __remuser: *const core::ffi::c_char,
        __locuser: *const core::ffi::c_char,
        __af: sa_family_t,
    ) -> core::ffi::c_int;
    pub fn rresvport(__alport: *mut core::ffi::c_int) -> core::ffi::c_int;
    pub fn rresvport_af(__alport: *mut core::ffi::c_int, __af: sa_family_t) -> core::ffi::c_int;
    pub fn getaddrinfo(
        __name: *const core::ffi::c_char,
        __service: *const core::ffi::c_char,
        __req: *const addrinfo,
        __pai: *mut *mut addrinfo,
    ) -> core::ffi::c_int;
    pub fn freeaddrinfo(__ai: *mut addrinfo);
    pub fn gai_strerror(__ecode: core::ffi::c_int) -> *const core::ffi::c_char;
    pub fn getnameinfo(
        __sa: *const sockaddr,
        __salen: socklen_t,
        __host: *mut core::ffi::c_char,
        __hostlen: socklen_t,
        __serv: *mut core::ffi::c_char,
        __servlen: socklen_t,
        __flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn getaddrinfo_a(
        __mode: core::ffi::c_int,
        __list: *mut *mut gaicb,
        __ent: core::ffi::c_int,
        __sig: *mut sigevent,
    ) -> core::ffi::c_int;
    pub fn gai_suspend(
        __list: *const *const gaicb,
        __ent: core::ffi::c_int,
        __timeout: *const timespec,
    ) -> core::ffi::c_int;
    pub fn gai_error(__req: *mut gaicb) -> core::ffi::c_int;
    pub fn gai_cancel(__gaicbp: *mut gaicb) -> core::ffi::c_int;
    pub fn gnu_dev_major(__dev: __dev_t) -> core::ffi::c_uint;
    pub fn gnu_dev_minor(__dev: __dev_t) -> core::ffi::c_uint;
    pub fn gnu_dev_makedev(__major: core::ffi::c_uint, __minor: core::ffi::c_uint) -> __dev_t;
    pub fn os_set_line_buffering();
    pub fn os_setup_early_signal_handling();
    pub fn os_set_proc_name(s: *const core::ffi::c_char);
    pub fn os_setup_signal_handling();
    pub fn os_set_daemonize(d: bool) -> core::ffi::c_int;
    pub fn is_daemonized() -> bool;
    pub fn os_daemonize();
    pub fn os_set_runas(user_id: *const core::ffi::c_char) -> bool;
    pub fn os_set_chroot(path: *const core::ffi::c_char);
    pub fn os_setup_limits();
    pub fn os_setup_post();
    pub fn os_mlock() -> core::ffi::c_int;
    pub fn qemu_alloc_stack(sz: *mut usize) -> *mut core::ffi::c_void;
    pub fn qemu_free_stack(stack: *mut core::ffi::c_void, sz: usize);
    pub fn qemu_build_not_reached_always() -> !;
    pub fn qemu_daemon(nochdir: core::ffi::c_int, noclose: core::ffi::c_int) -> core::ffi::c_int;
    pub fn qemu_anon_ram_alloc(
        size: usize,
        align: *mut u64,
        shared: bool,
        noreserve: bool,
    ) -> *mut core::ffi::c_void;
    pub fn qemu_anon_ram_free(ptr: *mut core::ffi::c_void, size: usize);
    pub fn qemu_signalfd(mask: *const sigset_t) -> core::ffi::c_int;
    pub fn sigaction_invoke(action: *mut sigaction, info: *mut qemu_signalfd_siginfo);
    pub fn qemu_open_old(
        name: *const core::ffi::c_char,
        flags: core::ffi::c_int,
        ...
    ) -> core::ffi::c_int;
    pub fn qemu_open(
        name: *const core::ffi::c_char,
        flags: core::ffi::c_int,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn qemu_create(
        name: *const core::ffi::c_char,
        flags: core::ffi::c_int,
        mode: mode_t,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn qemu_close(fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn qemu_unlink(name: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn qemu_dup_flags(fd: core::ffi::c_int, flags: core::ffi::c_int) -> core::ffi::c_int;
    pub fn qemu_dup(fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn qemu_lock_fd(
        fd: core::ffi::c_int,
        start: i64,
        len: i64,
        exclusive: bool,
    ) -> core::ffi::c_int;
    pub fn qemu_unlock_fd(fd: core::ffi::c_int, start: i64, len: i64) -> core::ffi::c_int;
    pub fn qemu_lock_fd_test(
        fd: core::ffi::c_int,
        start: i64,
        len: i64,
        exclusive: bool,
    ) -> core::ffi::c_int;
    pub fn qemu_has_ofd_lock() -> bool;
    pub fn qemu_write_pidfile(pidfile: *const core::ffi::c_char, errp: *mut *mut Error) -> bool;
    pub fn qemu_get_thread_id() -> core::ffi::c_int;
    pub fn qemu_write_full(
        fd: core::ffi::c_int,
        buf: *const core::ffi::c_void,
        count: usize,
    ) -> isize;
    pub fn qemu_set_cloexec(fd: core::ffi::c_int);
    pub fn qemu_get_local_state_dir() -> *mut core::ffi::c_char;
    pub fn qemu_getauxval(type_: core::ffi::c_ulong) -> core::ffi::c_ulong;
    pub fn qemu_set_tty_echo(fd: core::ffi::c_int, echo: bool);
    pub fn qemu_prealloc_mem(
        fd: core::ffi::c_int,
        area: *mut core::ffi::c_char,
        sz: usize,
        max_threads: core::ffi::c_int,
        tc: *mut ThreadContext,
        async_: bool,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn qemu_finish_async_prealloc_mem(errp: *mut *mut Error) -> bool;
    pub fn qemu_get_pid_name(pid: pid_t) -> *mut core::ffi::c_char;
    pub fn qemu_fdatasync(fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn qemu_msync(
        addr: *mut core::ffi::c_void,
        length: usize,
        fd: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn qemu_get_host_physmem() -> usize;
    pub fn register_module_init(
        fn_: ::core::option::Option<unsafe extern "C" fn()>,
        type_: module_init_type,
    );
    pub fn register_dso_module_init(
        fn_: ::core::option::Option<unsafe extern "C" fn()>,
        type_: module_init_type,
    );
    pub fn module_call_init(type_: module_init_type);
    pub fn module_load(
        prefix: *const core::ffi::c_char,
        name: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn module_load_qom(
        type_: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn module_load_qom_all();
    pub fn module_allow_arch(arch: *const core::ffi::c_char);
    pub static qemu_modinfo: [QemuModinfo; 0usize];
    pub fn module_init_info(info: *const QemuModinfo);
    pub static mut qemuio_misalign: bool;
    pub fn qemuio_command(
        blk: *mut BlockBackend,
        cmd: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
    pub fn qemuio_add_command(ci: *const cmdinfo_t);
    pub fn qemuio_command_usage(ci: *const cmdinfo_t);
    pub fn qemuio_complete_command(
        input: *const core::ffi::c_char,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(cmd: *const core::ffi::c_char, opaque: *mut core::ffi::c_void),
        >,
        opaque: *mut core::ffi::c_void,
    );
    pub fn urshift(plow: *mut u64, phigh: *mut u64, shift: i32);
    pub fn ulshift(plow: *mut u64, phigh: *mut u64, shift: i32, overflow: *mut bool);
    pub fn divu256(plow: *mut Int128, phigh: *mut Int128, divisor: Int128) -> Int128;
    pub fn divs256(plow: *mut Int128, phigh: *mut Int128, divisor: Int128) -> Int128;
    pub fn find_last_bit(
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
    pub fn find_next_bit(
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        offset: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
    pub fn find_next_zero_bit(
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        offset: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
    pub fn notifier_list_init(list: *mut NotifierList);
    pub fn notifier_list_add(list: *mut NotifierList, notifier: *mut Notifier);
    pub fn notifier_remove(notifier: *mut Notifier);
    pub fn notifier_list_notify(list: *mut NotifierList, data: *mut core::ffi::c_void);
    pub fn notifier_list_empty(list: *mut NotifierList) -> bool;
    pub fn notifier_with_return_list_init(list: *mut NotifierWithReturnList);
    pub fn notifier_with_return_list_add(
        list: *mut NotifierWithReturnList,
        notifier: *mut NotifierWithReturn,
    );
    pub fn notifier_with_return_remove(notifier: *mut NotifierWithReturn);
    pub fn notifier_with_return_list_notify(
        list: *mut NotifierWithReturnList,
        data: *mut core::ffi::c_void,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub static mut main_loop_tlg: QEMUTimerListGroup;
    pub fn qemu_clock_get_ns(type_: QEMUClockType) -> i64;
    pub fn qemu_clock_has_timers(type_: QEMUClockType) -> bool;
    pub fn qemu_clock_expired(type_: QEMUClockType) -> bool;
    pub fn qemu_clock_use_for_deadline(type_: QEMUClockType) -> bool;
    pub fn qemu_clock_deadline_ns_all(type_: QEMUClockType, attr_mask: core::ffi::c_int) -> i64;
    pub fn qemu_clock_get_main_loop_timerlist(type_: QEMUClockType) -> *mut QEMUTimerList;
    pub fn qemu_clock_notify(type_: QEMUClockType);
    pub fn qemu_clock_enable(type_: QEMUClockType, enabled: bool);
    pub fn qemu_clock_run_timers(type_: QEMUClockType) -> bool;
    pub fn qemu_clock_run_all_timers() -> bool;
    pub fn timerlist_new(
        type_: QEMUClockType,
        cb: QEMUTimerListNotifyCB,
        opaque: *mut core::ffi::c_void,
    ) -> *mut QEMUTimerList;
    pub fn timerlist_free(timer_list: *mut QEMUTimerList);
    pub fn timerlist_has_timers(timer_list: *mut QEMUTimerList) -> bool;
    pub fn timerlist_expired(timer_list: *mut QEMUTimerList) -> bool;
    pub fn timerlist_deadline_ns(timer_list: *mut QEMUTimerList) -> i64;
    pub fn timerlist_get_clock(timer_list: *mut QEMUTimerList) -> QEMUClockType;
    pub fn timerlist_run_timers(timer_list: *mut QEMUTimerList) -> bool;
    pub fn timerlist_notify(timer_list: *mut QEMUTimerList);
    pub fn timerlistgroup_init(
        tlg: *mut QEMUTimerListGroup,
        cb: QEMUTimerListNotifyCB,
        opaque: *mut core::ffi::c_void,
    );
    pub fn timerlistgroup_deinit(tlg: *mut QEMUTimerListGroup);
    pub fn timerlistgroup_run_timers(tlg: *mut QEMUTimerListGroup) -> bool;
    pub fn timerlistgroup_deadline_ns(tlg: *mut QEMUTimerListGroup) -> i64;
    pub fn timer_init_full(
        ts: *mut QEMUTimer,
        timer_list_group: *mut QEMUTimerListGroup,
        type_: QEMUClockType,
        scale: core::ffi::c_int,
        attributes: core::ffi::c_int,
        cb: QEMUTimerCB,
        opaque: *mut core::ffi::c_void,
    );
    pub fn timer_deinit(ts: *mut QEMUTimer);
    pub fn timer_del(ts: *mut QEMUTimer);
    pub fn timer_mod_ns(ts: *mut QEMUTimer, expire_time: i64);
    pub fn timer_mod_anticipate_ns(ts: *mut QEMUTimer, expire_time: i64);
    pub fn timer_mod(ts: *mut QEMUTimer, expire_timer: i64);
    pub fn timer_mod_anticipate(ts: *mut QEMUTimer, expire_time: i64);
    pub fn timer_pending(ts: *mut QEMUTimer) -> bool;
    pub fn timer_expired(timer_head: *mut QEMUTimer, current_time: i64) -> bool;
    pub fn timer_expire_time_ns(ts: *mut QEMUTimer) -> u64;
    pub fn timer_get(f: *mut QEMUFile, ts: *mut QEMUTimer);
    pub fn timer_put(f: *mut QEMUFile, ts: *mut QEMUTimer);
    pub fn qemu_timeout_ns_to_ms(ns: i64) -> core::ffi::c_int;
    pub fn qemu_poll_ns(fds: *mut GPollFD, nfds: guint, timeout: i64) -> core::ffi::c_int;
    pub fn init_clocks(notify_cb: QEMUTimerListNotifyCB);
    pub static mut clock_start: i64;
    pub static mut use_rt_clock: core::ffi::c_int;
    pub fn qemu_uuid_generate(out: *mut QemuUUID);
    pub fn qemu_uuid_is_null(uu: *const QemuUUID) -> core::ffi::c_int;
    pub fn qemu_uuid_is_equal(lhv: *const QemuUUID, rhv: *const QemuUUID) -> core::ffi::c_int;
    pub fn qemu_uuid_unparse(uuid: *const QemuUUID, out: *mut core::ffi::c_char);
    pub fn qemu_uuid_unparse_strdup(uuid: *const QemuUUID) -> *mut core::ffi::c_char;
    pub fn qemu_uuid_parse(str_: *const core::ffi::c_char, uuid: *mut QemuUUID)
        -> core::ffi::c_int;
    pub fn qemu_uuid_bswap(uuid: QemuUUID) -> QemuUUID;
    pub fn qemu_uuid_hash(uuid: *const core::ffi::c_void) -> u32;
    pub static mut only_migratable: core::ffi::c_int;
    pub static mut qemu_name: *const core::ffi::c_char;
    pub static mut qemu_uuid: QemuUUID;
    pub static mut qemu_uuid_set: bool;
    pub fn qemu_get_vm_name() -> *const core::ffi::c_char;
    pub fn qemu_add_exit_notifier(notify: *mut Notifier);
    pub fn qemu_remove_exit_notifier(notify: *mut Notifier);
    pub fn qemu_add_machine_init_done_notifier(notify: *mut Notifier);
    pub fn qemu_remove_machine_init_done_notifier(notify: *mut Notifier);
    pub fn configure_rtc(opts: *mut QemuOpts);
    pub fn qemu_init_subsystems();
    pub static mut autostart: core::ffi::c_int;
    pub static mut vga_interface_type: core::ffi::c_int;
    pub static mut vga_interface_created: bool;
    pub static mut graphic_width: core::ffi::c_int;
    pub static mut graphic_height: core::ffi::c_int;
    pub static mut graphic_depth: core::ffi::c_int;
    pub static mut display_opengl: core::ffi::c_int;
    pub static mut keyboard_layout: *const core::ffi::c_char;
    pub static mut graphic_rotate: core::ffi::c_int;
    pub static mut old_param: core::ffi::c_int;
    pub static mut boot_splash_filedata: *mut u8;
    pub static mut enable_mlock: bool;
    pub static mut enable_cpu_pm: bool;
    pub static mut rtc_clock: QEMUClockType;
    pub static mut option_rom: [QEMUOptionRom; 16usize];
    pub static mut nb_option_roms: core::ffi::c_int;
    pub static mut prom_envs: [*const core::ffi::c_char; 128usize];
    pub static mut nb_prom_envs: core::ffi::c_uint;
    pub fn serial_hd(i: core::ffi::c_int) -> *mut Chardev;
    pub static mut parallel_hds: [*mut Chardev; 3usize];
    pub fn add_boot_device_path(
        bootindex: i32,
        dev: *mut DeviceState,
        suffix: *const core::ffi::c_char,
    );
    pub fn get_boot_devices_list(size: *mut usize) -> *mut core::ffi::c_char;
    pub fn get_boot_device(position: u32) -> *mut DeviceState;
    pub fn check_boot_index(bootindex: i32, errp: *mut *mut Error);
    pub fn del_boot_device_path(dev: *mut DeviceState, suffix: *const core::ffi::c_char);
    pub fn device_add_bootindex_property(
        obj: *mut Object,
        bootindex: *mut i32,
        name: *const core::ffi::c_char,
        suffix: *const core::ffi::c_char,
        dev: *mut DeviceState,
    );
    pub fn restore_boot_order(opaque: *mut core::ffi::c_void);
    pub fn validate_bootdevices(devices: *const core::ffi::c_char, errp: *mut *mut Error);
    pub fn add_boot_device_lchs(
        dev: *mut DeviceState,
        suffix: *const core::ffi::c_char,
        lcyls: u32,
        lheads: u32,
        lsecs: u32,
    );
    pub fn del_boot_device_lchs(dev: *mut DeviceState, suffix: *const core::ffi::c_char);
    pub fn get_boot_devices_lchs_list(size: *mut usize) -> *mut core::ffi::c_char;
    pub fn qemu_register_boot_set(func: QEMUBootSetHandler, opaque: *mut core::ffi::c_void);
    pub fn qemu_boot_set(boot_order: *const core::ffi::c_char, errp: *mut *mut Error);
    pub fn defaults_enabled() -> bool;
    pub fn qemu_init(argc: core::ffi::c_int, argv: *mut *mut core::ffi::c_char);
    pub fn qemu_main_loop() -> core::ffi::c_int;
    pub fn qemu_cleanup(arg1: core::ffi::c_int);
    pub static mut qemu_legacy_drive_opts: QemuOptsList;
    pub static mut qemu_common_drive_opts: QemuOptsList;
    pub static mut qemu_drive_opts: QemuOptsList;
    pub static mut bdrv_runtime_opts: QemuOptsList;
    pub static mut qemu_chardev_opts: QemuOptsList;
    pub static mut qemu_device_opts: QemuOptsList;
    pub static mut qemu_netdev_opts: QemuOptsList;
    pub static mut qemu_nic_opts: QemuOptsList;
    pub static mut qemu_net_opts: QemuOptsList;
    pub static mut qemu_global_opts: QemuOptsList;
    pub static mut qemu_semihosting_config_opts: QemuOptsList;
    pub fn slow_bitmap_empty(
        bitmap: *const core::ffi::c_ulong,
        bits: core::ffi::c_long,
    ) -> core::ffi::c_int;
    pub fn slow_bitmap_full(
        bitmap: *const core::ffi::c_ulong,
        bits: core::ffi::c_long,
    ) -> core::ffi::c_int;
    pub fn slow_bitmap_equal(
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        bits: core::ffi::c_long,
    ) -> core::ffi::c_int;
    pub fn slow_bitmap_complement(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        bits: core::ffi::c_long,
    );
    pub fn slow_bitmap_and(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        bits: core::ffi::c_long,
    ) -> core::ffi::c_int;
    pub fn slow_bitmap_or(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        bits: core::ffi::c_long,
    );
    pub fn slow_bitmap_xor(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        bits: core::ffi::c_long,
    );
    pub fn slow_bitmap_andnot(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        bits: core::ffi::c_long,
    ) -> core::ffi::c_int;
    pub fn slow_bitmap_intersects(
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        bits: core::ffi::c_long,
    ) -> core::ffi::c_int;
    pub fn slow_bitmap_count_one(
        bitmap: *const core::ffi::c_ulong,
        nbits: core::ffi::c_long,
    ) -> core::ffi::c_long;
    pub fn bitmap_set(map: *mut core::ffi::c_ulong, i: core::ffi::c_long, len: core::ffi::c_long);
    pub fn bitmap_set_atomic(
        map: *mut core::ffi::c_ulong,
        i: core::ffi::c_long,
        len: core::ffi::c_long,
    );
    pub fn bitmap_clear(
        map: *mut core::ffi::c_ulong,
        start: core::ffi::c_long,
        nr: core::ffi::c_long,
    );
    pub fn bitmap_test_and_clear_atomic(
        map: *mut core::ffi::c_ulong,
        start: core::ffi::c_long,
        nr: core::ffi::c_long,
    ) -> bool;
    pub fn bitmap_test_and_clear(
        map: *mut core::ffi::c_ulong,
        start: core::ffi::c_long,
        nr: core::ffi::c_long,
    ) -> bool;
    pub fn bitmap_copy_and_clear_atomic(
        dst: *mut core::ffi::c_ulong,
        src: *mut core::ffi::c_ulong,
        nr: core::ffi::c_long,
    );
    pub fn bitmap_find_next_zero_area(
        map: *mut core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
        nr: core::ffi::c_ulong,
        align_mask: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
    pub fn bitmap_to_le(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        nbits: core::ffi::c_long,
    );
    pub fn bitmap_from_le(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        nbits: core::ffi::c_long,
    );
    pub fn bitmap_copy_with_src_offset(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        offset: core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
    );
    pub fn bitmap_copy_with_dst_offset(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        shift: core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
    );
    pub fn sem_init(
        __sem: *mut sem_t,
        __pshared: core::ffi::c_int,
        __value: core::ffi::c_uint,
    ) -> core::ffi::c_int;
    pub fn sem_destroy(__sem: *mut sem_t) -> core::ffi::c_int;
    pub fn sem_open(__name: *const core::ffi::c_char, __oflag: core::ffi::c_int, ...)
        -> *mut sem_t;
    pub fn sem_close(__sem: *mut sem_t) -> core::ffi::c_int;
    pub fn sem_unlink(__name: *const core::ffi::c_char) -> core::ffi::c_int;
    pub fn sem_wait(__sem: *mut sem_t) -> core::ffi::c_int;
    pub fn sem_timedwait(__sem: *mut sem_t, __abstime: *const timespec) -> core::ffi::c_int;
    pub fn sem_clockwait(
        __sem: *mut sem_t,
        clock: clockid_t,
        __abstime: *const timespec,
    ) -> core::ffi::c_int;
    pub fn sem_trywait(__sem: *mut sem_t) -> core::ffi::c_int;
    pub fn sem_post(__sem: *mut sem_t) -> core::ffi::c_int;
    pub fn sem_getvalue(__sem: *mut sem_t, __sval: *mut core::ffi::c_int) -> core::ffi::c_int;
    pub fn qsp_report(max: usize, sort_by: QSPSortBy, callsite_coalesce: bool);
    pub fn qsp_is_enabled() -> bool;
    pub fn qsp_enable();
    pub fn qsp_disable();
    pub fn qsp_reset();
    pub fn qemu_mutex_init(mutex: *mut QemuMutex);
    pub fn qemu_mutex_destroy(mutex: *mut QemuMutex);
    pub fn qemu_mutex_trylock_impl(
        mutex: *mut QemuMutex,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn qemu_mutex_lock_impl(
        mutex: *mut QemuMutex,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
    );
    pub fn qemu_mutex_unlock_impl(
        mutex: *mut QemuMutex,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
    );
    pub fn qemu_rec_mutex_init(mutex: *mut QemuRecMutex);
    pub fn qemu_rec_mutex_destroy(mutex: *mut QemuRecMutex);
    pub fn qemu_rec_mutex_lock_impl(
        mutex: *mut QemuRecMutex,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
    );
    pub fn qemu_rec_mutex_trylock_impl(
        mutex: *mut QemuRecMutex,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn qemu_rec_mutex_unlock_impl(
        mutex: *mut QemuRecMutex,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
    );
    pub static mut bql_mutex_lock_func: QemuMutexLockFunc;
    pub static mut qemu_mutex_lock_func: QemuMutexLockFunc;
    pub static mut qemu_mutex_trylock_func: QemuMutexTrylockFunc;
    pub static mut qemu_rec_mutex_lock_func: QemuRecMutexLockFunc;
    pub static mut qemu_rec_mutex_trylock_func: QemuRecMutexTrylockFunc;
    pub static mut qemu_cond_wait_func: QemuCondWaitFunc;
    pub static mut qemu_cond_timedwait_func: QemuCondTimedWaitFunc;
    pub fn qemu_cond_init(cond: *mut QemuCond);
    pub fn qemu_cond_destroy(cond: *mut QemuCond);
    pub fn qemu_cond_signal(cond: *mut QemuCond);
    pub fn qemu_cond_broadcast(cond: *mut QemuCond);
    pub fn qemu_cond_wait_impl(
        cond: *mut QemuCond,
        mutex: *mut QemuMutex,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
    );
    pub fn qemu_cond_timedwait_impl(
        cond: *mut QemuCond,
        mutex: *mut QemuMutex,
        ms: core::ffi::c_int,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
    ) -> bool;
    pub fn qemu_sem_init(sem: *mut QemuSemaphore, init: core::ffi::c_int);
    pub fn qemu_sem_post(sem: *mut QemuSemaphore);
    pub fn qemu_sem_wait(sem: *mut QemuSemaphore);
    pub fn qemu_sem_timedwait(sem: *mut QemuSemaphore, ms: core::ffi::c_int) -> core::ffi::c_int;
    pub fn qemu_sem_destroy(sem: *mut QemuSemaphore);
    pub fn qemu_event_init(ev: *mut QemuEvent, init: bool);
    pub fn qemu_event_set(ev: *mut QemuEvent);
    pub fn qemu_event_reset(ev: *mut QemuEvent);
    pub fn qemu_event_wait(ev: *mut QemuEvent);
    pub fn qemu_event_destroy(ev: *mut QemuEvent);
    pub fn qemu_thread_create(
        thread: *mut QemuThread,
        name: *const core::ffi::c_char,
        start_routine: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> *mut core::ffi::c_void,
        >,
        arg: *mut core::ffi::c_void,
        mode: core::ffi::c_int,
    );
    pub fn qemu_thread_set_affinity(
        thread: *mut QemuThread,
        host_cpus: *mut core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
    pub fn qemu_thread_get_affinity(
        thread: *mut QemuThread,
        host_cpus: *mut *mut core::ffi::c_ulong,
        nbits: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
    pub fn qemu_thread_join(thread: *mut QemuThread) -> *mut core::ffi::c_void;
    pub fn qemu_thread_get_self(thread: *mut QemuThread);
    pub fn qemu_thread_is_self(thread: *mut QemuThread) -> bool;
    pub fn qemu_thread_exit(retval: *mut core::ffi::c_void) -> !;
    pub fn qemu_thread_naming(enable: bool);
    pub fn qemu_thread_atexit_add(notifier: *mut Notifier);
    pub fn qemu_thread_atexit_remove(notifier: *mut Notifier);
    pub fn qemu_lockcnt_init(lockcnt: *mut QemuLockCnt);
    pub fn qemu_lockcnt_destroy(lockcnt: *mut QemuLockCnt);
    pub fn qemu_lockcnt_inc(lockcnt: *mut QemuLockCnt);
    pub fn qemu_lockcnt_dec(lockcnt: *mut QemuLockCnt);
    pub fn qemu_lockcnt_dec_and_lock(lockcnt: *mut QemuLockCnt) -> bool;
    pub fn qemu_lockcnt_dec_if_lock(lockcnt: *mut QemuLockCnt) -> bool;
    pub fn qemu_lockcnt_lock(lockcnt: *mut QemuLockCnt);
    pub fn qemu_lockcnt_unlock(lockcnt: *mut QemuLockCnt);
    pub fn qemu_lockcnt_inc_and_unlock(lockcnt: *mut QemuLockCnt);
    pub fn qemu_lockcnt_count(lockcnt: *mut QemuLockCnt) -> core::ffi::c_uint;
    pub static mut rcu_gp_ctr: core::ffi::c_ulong;
    pub static mut rcu_gp_event: QemuEvent;
    pub fn get_rcu_reader() -> rcu_reader_data;
    pub fn set_rcu_reader(v: rcu_reader_data);
    pub fn get_ptr_rcu_reader() -> *mut rcu_reader_data;
    pub fn synchronize_rcu();
    pub fn rcu_register_thread();
    pub fn rcu_unregister_thread();
    pub fn rcu_enable_atfork();
    pub fn rcu_disable_atfork();
    pub fn call_rcu1(head: *mut rcu_head, func: RCUCBFunc);
    pub fn drain_call_rcu();
    pub fn rcu_add_force_rcu_notifier(n: *mut Notifier);
    pub fn rcu_remove_force_rcu_notifier(n: *mut Notifier);
    pub fn qapi_enum_lookup(
        lookup: *const QEnumLookup,
        val: core::ffi::c_int,
    ) -> *const core::ffi::c_char;
    pub fn qapi_enum_parse(
        lookup: *const QEnumLookup,
        buf: *const core::ffi::c_char,
        def: core::ffi::c_int,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn qapi_bool_parse(
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_char,
        obj: *mut bool,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn parse_qapi_name(name: *const core::ffi::c_char, complete: bool) -> core::ffi::c_int;
    pub static QType_lookup: QEnumLookup;
    pub fn qapi_free_strList(obj: *mut strList);
    pub fn qapi_free_numberList(obj: *mut numberList);
    pub fn qapi_free_intList(obj: *mut intList);
    pub fn qapi_free_int8List(obj: *mut int8List);
    pub fn qapi_free_int16List(obj: *mut int16List);
    pub fn qapi_free_int32List(obj: *mut int32List);
    pub fn qapi_free_int64List(obj: *mut int64List);
    pub fn qapi_free_uint8List(obj: *mut uint8List);
    pub fn qapi_free_uint16List(obj: *mut uint16List);
    pub fn qapi_free_uint32List(obj: *mut uint32List);
    pub fn qapi_free_uint64List(obj: *mut uint64List);
    pub fn qapi_free_sizeList(obj: *mut sizeList);
    pub fn qapi_free_boolList(obj: *mut boolList);
    pub fn qapi_free_anyList(obj: *mut anyList);
    pub fn qapi_free_nullList(obj: *mut nullList);
    pub fn object_new_with_class(klass: *mut ObjectClass) -> *mut Object;
    pub fn object_new(typename: *const core::ffi::c_char) -> *mut Object;
    pub fn object_new_with_props(
        typename: *const core::ffi::c_char,
        parent: *mut Object,
        id: *const core::ffi::c_char,
        errp: *mut *mut Error,
        ...
    ) -> *mut Object;
    pub fn object_new_with_propv(
        typename: *const core::ffi::c_char,
        parent: *mut Object,
        id: *const core::ffi::c_char,
        errp: *mut *mut Error,
        vargs: *mut __va_list_tag,
    ) -> *mut Object;
    pub fn object_apply_global_props(
        obj: *mut Object,
        props: *const GPtrArray,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn object_set_machine_compat_props(compat_props: *mut GPtrArray);
    pub fn object_set_accelerator_compat_props(compat_props: *mut GPtrArray);
    pub fn object_register_sugar_prop(
        driver: *const core::ffi::c_char,
        prop: *const core::ffi::c_char,
        value: *const core::ffi::c_char,
        optional: bool,
    );
    pub fn object_apply_compat_props(obj: *mut Object);
    pub fn object_set_props(obj: *mut Object, errp: *mut *mut Error, ...) -> bool;
    pub fn object_set_propv(
        obj: *mut Object,
        errp: *mut *mut Error,
        vargs: *mut __va_list_tag,
    ) -> bool;
    pub fn object_initialize(
        obj: *mut core::ffi::c_void,
        size: usize,
        typename: *const core::ffi::c_char,
    );
    pub fn object_initialize_child_with_props(
        parentobj: *mut Object,
        propname: *const core::ffi::c_char,
        childobj: *mut core::ffi::c_void,
        size: usize,
        type_: *const core::ffi::c_char,
        errp: *mut *mut Error,
        ...
    ) -> bool;
    pub fn object_initialize_child_with_propsv(
        parentobj: *mut Object,
        propname: *const core::ffi::c_char,
        childobj: *mut core::ffi::c_void,
        size: usize,
        type_: *const core::ffi::c_char,
        errp: *mut *mut Error,
        vargs: *mut __va_list_tag,
    ) -> bool;
    pub fn object_initialize_child_internal(
        parent: *mut Object,
        propname: *const core::ffi::c_char,
        child: *mut core::ffi::c_void,
        size: usize,
        type_: *const core::ffi::c_char,
    );
    pub fn object_dynamic_cast(obj: *mut Object, typename: *const core::ffi::c_char)
        -> *mut Object;
    pub fn object_dynamic_cast_assert(
        obj: *mut Object,
        typename: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
    ) -> *mut Object;
    pub fn object_get_class(obj: *mut Object) -> *mut ObjectClass;
    pub fn object_get_typename(obj: *const Object) -> *const core::ffi::c_char;
    pub fn type_register_static(info: *const TypeInfo) -> Type;
    pub fn type_register(info: *const TypeInfo) -> Type;
    pub fn type_register_static_array(infos: *const TypeInfo, nr_infos: core::ffi::c_int);
    pub fn type_print_class_properties(type_: *const core::ffi::c_char) -> bool;
    pub fn object_set_properties_from_keyval(
        obj: *mut Object,
        qdict: *const QDict,
        from_json: bool,
        errp: *mut *mut Error,
    );
    pub fn object_class_dynamic_cast_assert(
        klass: *mut ObjectClass,
        typename: *const core::ffi::c_char,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
    ) -> *mut ObjectClass;
    pub fn object_class_dynamic_cast(
        klass: *mut ObjectClass,
        typename: *const core::ffi::c_char,
    ) -> *mut ObjectClass;
    pub fn object_class_get_parent(klass: *mut ObjectClass) -> *mut ObjectClass;
    pub fn object_class_get_name(klass: *mut ObjectClass) -> *const core::ffi::c_char;
    pub fn object_class_is_abstract(klass: *mut ObjectClass) -> bool;
    pub fn object_class_by_name(typename: *const core::ffi::c_char) -> *mut ObjectClass;
    pub fn module_object_class_by_name(typename: *const core::ffi::c_char) -> *mut ObjectClass;
    pub fn object_class_foreach(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(klass: *mut ObjectClass, opaque: *mut core::ffi::c_void),
        >,
        implements_type: *const core::ffi::c_char,
        include_abstract: bool,
        opaque: *mut core::ffi::c_void,
    );
    pub fn object_class_get_list(
        implements_type: *const core::ffi::c_char,
        include_abstract: bool,
    ) -> *mut GSList;
    pub fn object_class_get_list_sorted(
        implements_type: *const core::ffi::c_char,
        include_abstract: bool,
    ) -> *mut GSList;
    pub fn object_ref(obj: *mut core::ffi::c_void) -> *mut Object;
    pub fn object_unref(obj: *mut core::ffi::c_void);
    pub fn object_property_try_add(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        type_: *const core::ffi::c_char,
        get: ObjectPropertyAccessor,
        set: ObjectPropertyAccessor,
        release: ObjectPropertyRelease,
        opaque: *mut core::ffi::c_void,
        errp: *mut *mut Error,
    ) -> *mut ObjectProperty;
    pub fn object_property_add(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        type_: *const core::ffi::c_char,
        get: ObjectPropertyAccessor,
        set: ObjectPropertyAccessor,
        release: ObjectPropertyRelease,
        opaque: *mut core::ffi::c_void,
    ) -> *mut ObjectProperty;
    pub fn object_property_del(obj: *mut Object, name: *const core::ffi::c_char);
    pub fn object_class_property_add(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
        type_: *const core::ffi::c_char,
        get: ObjectPropertyAccessor,
        set: ObjectPropertyAccessor,
        release: ObjectPropertyRelease,
        opaque: *mut core::ffi::c_void,
    ) -> *mut ObjectProperty;
    pub fn object_property_set_default_bool(prop: *mut ObjectProperty, value: bool);
    pub fn object_property_set_default_str(
        prop: *mut ObjectProperty,
        value: *const core::ffi::c_char,
    );
    pub fn object_property_set_default_list(prop: *mut ObjectProperty);
    pub fn object_property_set_default_int(prop: *mut ObjectProperty, value: i64);
    pub fn object_property_set_default_uint(prop: *mut ObjectProperty, value: u64);
    pub fn object_property_find(
        obj: *mut Object,
        name: *const core::ffi::c_char,
    ) -> *mut ObjectProperty;
    pub fn object_property_find_err(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> *mut ObjectProperty;
    pub fn object_class_property_find(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
    ) -> *mut ObjectProperty;
    pub fn object_class_property_find_err(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> *mut ObjectProperty;
    pub fn object_property_iter_init(iter: *mut ObjectPropertyIterator, obj: *mut Object);
    pub fn object_class_property_iter_init(
        iter: *mut ObjectPropertyIterator,
        klass: *mut ObjectClass,
    );
    pub fn object_property_iter_next(iter: *mut ObjectPropertyIterator) -> *mut ObjectProperty;
    pub fn object_unparent(obj: *mut Object);
    pub fn object_property_get(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        v: *mut Visitor,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn object_property_set_str(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn object_property_get_str(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> *mut core::ffi::c_char;
    pub fn object_property_set_link(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        value: *mut Object,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn object_property_get_link(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> *mut Object;
    pub fn object_property_set_bool(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        value: bool,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn object_property_get_bool(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn object_property_set_int(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        value: i64,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn object_property_get_int(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> i64;
    pub fn object_property_set_uint(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        value: u64,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn object_property_get_uint(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> u64;
    pub fn object_property_get_enum(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        typename: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn object_property_set(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        v: *mut Visitor,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn object_property_parse(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        string: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn object_property_print(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        human: bool,
        errp: *mut *mut Error,
    ) -> *mut core::ffi::c_char;
    pub fn object_property_get_type(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> *const core::ffi::c_char;
    pub fn object_get_root() -> *mut Object;
    pub fn object_get_objects_root() -> *mut Object;
    pub fn object_get_internal_root() -> *mut Object;
    pub fn object_get_canonical_path_component(obj: *const Object) -> *const core::ffi::c_char;
    pub fn object_get_canonical_path(obj: *const Object) -> *mut core::ffi::c_char;
    pub fn object_resolve_path(path: *const core::ffi::c_char, ambiguous: *mut bool)
        -> *mut Object;
    pub fn object_resolve_path_type(
        path: *const core::ffi::c_char,
        typename: *const core::ffi::c_char,
        ambiguous: *mut bool,
    ) -> *mut Object;
    pub fn object_resolve_type_unambiguous(
        typename: *const core::ffi::c_char,
        errp: *mut *mut Error,
    ) -> *mut Object;
    pub fn object_resolve_path_at(
        parent: *mut Object,
        path: *const core::ffi::c_char,
    ) -> *mut Object;
    pub fn object_resolve_path_component(
        parent: *mut Object,
        part: *const core::ffi::c_char,
    ) -> *mut Object;
    pub fn object_property_try_add_child(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        child: *mut Object,
        errp: *mut *mut Error,
    ) -> *mut ObjectProperty;
    pub fn object_property_add_child(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        child: *mut Object,
    ) -> *mut ObjectProperty;
    pub fn object_property_allow_set_link(
        obj: *const Object,
        name: *const core::ffi::c_char,
        child: *mut Object,
        errp: *mut *mut Error,
    );
    pub fn object_property_add_link(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        type_: *const core::ffi::c_char,
        targetp: *mut *mut Object,
        check: ::core::option::Option<
            unsafe extern "C" fn(
                obj: *const Object,
                name: *const core::ffi::c_char,
                val: *mut Object,
                errp: *mut *mut Error,
            ),
        >,
        flags: ObjectPropertyLinkFlags,
    ) -> *mut ObjectProperty;
    pub fn object_class_property_add_link(
        oc: *mut ObjectClass,
        name: *const core::ffi::c_char,
        type_: *const core::ffi::c_char,
        offset: isize,
        check: ::core::option::Option<
            unsafe extern "C" fn(
                obj: *const Object,
                name: *const core::ffi::c_char,
                val: *mut Object,
                errp: *mut *mut Error,
            ),
        >,
        flags: ObjectPropertyLinkFlags,
    ) -> *mut ObjectProperty;
    pub fn object_property_add_str(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        get: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Object,
                arg2: *mut *mut Error,
            ) -> *mut core::ffi::c_char,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Object,
                arg2: *const core::ffi::c_char,
                arg3: *mut *mut Error,
            ),
        >,
    ) -> *mut ObjectProperty;
    pub fn object_class_property_add_str(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
        get: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Object,
                arg2: *mut *mut Error,
            ) -> *mut core::ffi::c_char,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Object,
                arg2: *const core::ffi::c_char,
                arg3: *mut *mut Error,
            ),
        >,
    ) -> *mut ObjectProperty;
    pub fn object_property_add_bool(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        get: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut *mut Error) -> bool,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: bool, arg3: *mut *mut Error),
        >,
    ) -> *mut ObjectProperty;
    pub fn object_class_property_add_bool(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
        get: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut *mut Error) -> bool,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: bool, arg3: *mut *mut Error),
        >,
    ) -> *mut ObjectProperty;
    pub fn object_property_add_enum(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        typename: *const core::ffi::c_char,
        lookup: *const QEnumLookup,
        get: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut *mut Error) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: core::ffi::c_int, arg3: *mut *mut Error),
        >,
    ) -> *mut ObjectProperty;
    pub fn object_class_property_add_enum(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
        typename: *const core::ffi::c_char,
        lookup: *const QEnumLookup,
        get: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut *mut Error) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: core::ffi::c_int, arg3: *mut *mut Error),
        >,
    ) -> *mut ObjectProperty;
    pub fn object_property_add_tm(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        get: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut tm, arg3: *mut *mut Error),
        >,
    ) -> *mut ObjectProperty;
    pub fn object_class_property_add_tm(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
        get: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut Object, arg2: *mut tm, arg3: *mut *mut Error),
        >,
    ) -> *mut ObjectProperty;
    pub fn object_property_add_uint8_ptr(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        v: *const u8,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
    pub fn object_class_property_add_uint8_ptr(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
        v: *const u8,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
    pub fn object_property_add_uint16_ptr(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        v: *const u16,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
    pub fn object_class_property_add_uint16_ptr(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
        v: *const u16,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
    pub fn object_property_add_uint32_ptr(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        v: *const u32,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
    pub fn object_class_property_add_uint32_ptr(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
        v: *const u32,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
    pub fn object_property_add_uint64_ptr(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        v: *const u64,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
    pub fn object_class_property_add_uint64_ptr(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
        v: *const u64,
        flags: ObjectPropertyFlags,
    ) -> *mut ObjectProperty;
    pub fn object_property_add_alias(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        target_obj: *mut Object,
        target_name: *const core::ffi::c_char,
    ) -> *mut ObjectProperty;
    pub fn object_property_add_const_link(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        target: *mut Object,
    ) -> *mut ObjectProperty;
    pub fn object_property_set_description(
        obj: *mut Object,
        name: *const core::ffi::c_char,
        description: *const core::ffi::c_char,
    );
    pub fn object_class_property_set_description(
        klass: *mut ObjectClass,
        name: *const core::ffi::c_char,
        description: *const core::ffi::c_char,
    );
    pub fn object_child_foreach(
        obj: *mut Object,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                child: *mut Object,
                opaque: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn object_child_foreach_recursive(
        obj: *mut Object,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                child: *mut Object,
                opaque: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn container_get(root: *mut Object, path: *const core::ffi::c_char) -> *mut Object;
    pub fn object_type_get_instance_size(typename: *const core::ffi::c_char) -> usize;
    pub fn object_property_help(
        name: *const core::ffi::c_char,
        type_: *const core::ffi::c_char,
        defval: *mut QObject,
        description: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
    pub fn hotplug_handler_plug(
        plug_handler: *mut HotplugHandler,
        plugged_dev: *mut DeviceState,
        errp: *mut *mut Error,
    );
    pub fn hotplug_handler_pre_plug(
        plug_handler: *mut HotplugHandler,
        plugged_dev: *mut DeviceState,
        errp: *mut *mut Error,
    );
    pub fn hotplug_handler_unplug_request(
        plug_handler: *mut HotplugHandler,
        plugged_dev: *mut DeviceState,
        errp: *mut *mut Error,
    );
    pub fn hotplug_handler_unplug(
        plug_handler: *mut HotplugHandler,
        plugged_dev: *mut DeviceState,
        errp: *mut *mut Error,
    );
    pub fn resettable_reset(obj: *mut Object, type_: ResetType);
    pub fn resettable_assert_reset(obj: *mut Object, type_: ResetType);
    pub fn resettable_release_reset(obj: *mut Object, type_: ResetType);
    pub fn resettable_is_in_reset(obj: *mut Object) -> bool;
    pub fn resettable_change_parent(obj: *mut Object, newp: *mut Object, oldp: *mut Object);
    pub fn resettable_cold_reset_fn(opaque: *mut core::ffi::c_void);
    pub fn resettable_class_set_parent_phases(
        rc: *mut ResettableClass,
        enter: ResettableEnterPhase,
        hold: ResettableHoldPhase,
        exit: ResettableExitPhase,
        parent_phases: *mut ResettablePhases,
    );
    pub fn qdev_new(name: *const core::ffi::c_char) -> *mut DeviceState;
    pub fn qdev_try_new(name: *const core::ffi::c_char) -> *mut DeviceState;
    pub fn qdev_realize(dev: *mut DeviceState, bus: *mut BusState, errp: *mut *mut Error) -> bool;
    pub fn qdev_realize_and_unref(
        dev: *mut DeviceState,
        bus: *mut BusState,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn qdev_unrealize(dev: *mut DeviceState);
    pub fn qdev_set_legacy_instance_id(
        dev: *mut DeviceState,
        alias_id: core::ffi::c_int,
        required_for_version: core::ffi::c_int,
    );
    pub fn qdev_get_bus_hotplug_handler(dev: *mut DeviceState) -> *mut HotplugHandler;
    pub fn qdev_get_machine_hotplug_handler(dev: *mut DeviceState) -> *mut HotplugHandler;
    pub fn qdev_hotplug_allowed(dev: *mut DeviceState, errp: *mut *mut Error) -> bool;
    pub fn qdev_get_hotplug_handler(dev: *mut DeviceState) -> *mut HotplugHandler;
    pub fn qdev_unplug(dev: *mut DeviceState, errp: *mut *mut Error);
    pub fn qdev_simple_device_unplug_cb(
        hotplug_dev: *mut HotplugHandler,
        dev: *mut DeviceState,
        errp: *mut *mut Error,
    );
    pub fn qdev_machine_creation_done();
    pub fn qdev_machine_modified() -> bool;
    pub fn qdev_add_unplug_blocker(dev: *mut DeviceState, reason: *mut Error);
    pub fn qdev_del_unplug_blocker(dev: *mut DeviceState, reason: *mut Error);
    pub fn qdev_unplug_blocked(dev: *mut DeviceState, errp: *mut *mut Error) -> bool;
    pub fn qdev_get_gpio_in(dev: *mut DeviceState, n: core::ffi::c_int) -> qemu_irq;
    pub fn qdev_get_gpio_in_named(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        n: core::ffi::c_int,
    ) -> qemu_irq;
    pub fn qdev_connect_gpio_out(dev: *mut DeviceState, n: core::ffi::c_int, pin: qemu_irq);
    pub fn qdev_connect_gpio_out_named(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        n: core::ffi::c_int,
        input_pin: qemu_irq,
    );
    pub fn qdev_get_gpio_out_connector(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        n: core::ffi::c_int,
    ) -> qemu_irq;
    pub fn qdev_intercept_gpio_out(
        dev: *mut DeviceState,
        icpt: qemu_irq,
        name: *const core::ffi::c_char,
        n: core::ffi::c_int,
    ) -> qemu_irq;
    pub fn qdev_get_child_bus(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
    ) -> *mut BusState;
    pub fn qdev_init_gpio_in(dev: *mut DeviceState, handler: qemu_irq_handler, n: core::ffi::c_int);
    pub fn qdev_init_gpio_out(dev: *mut DeviceState, pins: *mut qemu_irq, n: core::ffi::c_int);
    pub fn qdev_init_gpio_out_named(
        dev: *mut DeviceState,
        pins: *mut qemu_irq,
        name: *const core::ffi::c_char,
        n: core::ffi::c_int,
    );
    pub fn qdev_init_gpio_in_named_with_opaque(
        dev: *mut DeviceState,
        handler: qemu_irq_handler,
        opaque: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
        n: core::ffi::c_int,
    );
    pub fn qdev_pass_gpios(
        dev: *mut DeviceState,
        container: *mut DeviceState,
        name: *const core::ffi::c_char,
    );
    pub fn qdev_get_parent_bus(dev: *const DeviceState) -> *mut BusState;
    pub fn qdev_find_recursive(
        bus: *mut BusState,
        id: *const core::ffi::c_char,
    ) -> *mut DeviceState;
    pub fn qbus_init(
        bus: *mut core::ffi::c_void,
        size: usize,
        typename: *const core::ffi::c_char,
        parent: *mut DeviceState,
        name: *const core::ffi::c_char,
    );
    pub fn qbus_new(
        typename: *const core::ffi::c_char,
        parent: *mut DeviceState,
        name: *const core::ffi::c_char,
    ) -> *mut BusState;
    pub fn qbus_realize(bus: *mut BusState, errp: *mut *mut Error) -> bool;
    pub fn qbus_unrealize(bus: *mut BusState);
    pub fn qbus_walk_children(
        bus: *mut BusState,
        pre_devfn: qdev_walkerfn,
        pre_busfn: qbus_walkerfn,
        post_devfn: qdev_walkerfn,
        post_busfn: qbus_walkerfn,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn qdev_walk_children(
        dev: *mut DeviceState,
        pre_devfn: qdev_walkerfn,
        pre_busfn: qbus_walkerfn,
        post_devfn: qdev_walkerfn,
        post_busfn: qbus_walkerfn,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn device_cold_reset(dev: *mut DeviceState);
    pub fn bus_cold_reset(bus: *mut BusState);
    pub fn device_is_in_reset(dev: *mut DeviceState) -> bool;
    pub fn bus_is_in_reset(bus: *mut BusState) -> bool;
    pub fn sysbus_get_default() -> *mut BusState;
    pub fn qdev_get_fw_dev_path(dev: *mut DeviceState) -> *mut core::ffi::c_char;
    pub fn qdev_get_own_fw_dev_path_from_handler(
        bus: *mut BusState,
        dev: *mut DeviceState,
    ) -> *mut core::ffi::c_char;
    pub fn device_class_set_props(dc: *mut DeviceClass, props: *mut Property);
    pub fn device_class_set_parent_reset(
        dc: *mut DeviceClass,
        dev_reset: DeviceReset,
        parent_reset: *mut DeviceReset,
    );
    pub fn device_class_set_parent_realize(
        dc: *mut DeviceClass,
        dev_realize: DeviceRealize,
        parent_realize: *mut DeviceRealize,
    );
    pub fn device_class_set_parent_unrealize(
        dc: *mut DeviceClass,
        dev_unrealize: DeviceUnrealize,
        parent_unrealize: *mut DeviceUnrealize,
    );
    pub fn qdev_get_vmsd(dev: *mut DeviceState) -> *const VMStateDescription;
    pub fn qdev_fw_name(dev: *mut DeviceState) -> *const core::ffi::c_char;
    pub fn qdev_assert_realized_properly();
    pub fn qdev_get_machine() -> *mut Object;
    pub fn qdev_get_human_name(dev: *mut DeviceState) -> *mut core::ffi::c_char;
    pub fn qdev_set_parent_bus(
        dev: *mut DeviceState,
        bus: *mut BusState,
        errp: *mut *mut Error,
    ) -> bool;
    pub static mut qdev_hot_removed: bool;
    pub fn qdev_get_dev_path(dev: *mut DeviceState) -> *mut core::ffi::c_char;
    pub fn qbus_set_hotplug_handler(bus: *mut BusState, handler: *mut Object);
    pub fn qbus_set_bus_hotplug_handler(bus: *mut BusState);
    pub fn device_listener_register(listener: *mut DeviceListener);
    pub fn device_listener_unregister(listener: *mut DeviceListener);
    pub fn qdev_should_hide_device(
        opts: *const QDict,
        from_json: bool,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn phase_check(phase: MachineInitPhase) -> bool;
    pub fn phase_advance(phase: MachineInitPhase);
    pub fn print_insn_tci(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_big_mips(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_little_mips(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_nanomips(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_m68k(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_z8001(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_z8002(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_h8300(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_h8300h(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_h8300s(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_h8500(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_arm_a64(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_alpha(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn arc_get_disassembler(
        arg1: core::ffi::c_int,
        arg2: core::ffi::c_int,
    ) -> disassembler_ftype;
    pub fn print_insn_sparc(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_big_a29k(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_little_a29k(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_i960(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_sh(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_shl(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_hppa(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_m32r(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_m88k(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_mn10200(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_mn10300(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_ns32k(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_big_powerpc(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_little_powerpc(
        arg1: bfd_vma,
        arg2: *mut disassemble_info,
    ) -> core::ffi::c_int;
    pub fn print_insn_rs6000(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_w65(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_d10v(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_v850(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_tic30(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_crisv32(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_crisv10(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_microblaze(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_ia64(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_xtensa(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_riscv32(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_riscv64(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_riscv128(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_rx(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_hexagon(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn print_insn_loongarch(arg1: bfd_vma, arg2: *mut disassemble_info) -> core::ffi::c_int;
    pub fn cap_disas_target(info: *mut disassemble_info, pc: u64, size: usize) -> bool;
    pub fn cap_disas_host(
        info: *mut disassemble_info,
        code: *const core::ffi::c_void,
        size: usize,
    ) -> bool;
    pub fn cap_disas_monitor(info: *mut disassemble_info, pc: u64, count: core::ffi::c_int)
        -> bool;
    pub fn cap_disas_plugin(info: *mut disassemble_info, pc: u64, size: usize) -> bool;
    pub static IoOperationType_lookup: QEnumLookup;
    pub static OnOffAuto_lookup: QEnumLookup;
    pub static OnOffSplit_lookup: QEnumLookup;
    pub static OffAutoPCIBAR_lookup: QEnumLookup;
    pub static PCIELinkSpeed_lookup: QEnumLookup;
    pub static PCIELinkWidth_lookup: QEnumLookup;
    pub static HostMemPolicy_lookup: QEnumLookup;
    pub static NetFilterDirection_lookup: QEnumLookup;
    pub static GrabToggleKeys_lookup: QEnumLookup;
    pub fn qapi_free_StrOrNull(obj: *mut StrOrNull);
    pub fn qapi_free_HumanReadableText(obj: *mut HumanReadableText);
    pub static CpuS390Entitlement_lookup: QEnumLookup;
    pub static SysEmuTarget_lookup: QEnumLookup;
    pub static CpuS390State_lookup: QEnumLookup;
    pub static LostTickPolicy_lookup: QEnumLookup;
    pub static NumaOptionsType_lookup: QEnumLookup;
    pub static X86CPURegister32_lookup: QEnumLookup;
    pub static HmatLBMemoryHierarchy_lookup: QEnumLookup;
    pub static HmatLBDataType_lookup: QEnumLookup;
    pub static HmatCacheAssociativity_lookup: QEnumLookup;
    pub static HmatCacheWritePolicy_lookup: QEnumLookup;
    pub static MemoryDeviceInfoKind_lookup: QEnumLookup;
    pub static SmbiosEntryPointType_lookup: QEnumLookup;
    pub fn qapi_free_CpuInfoS390(obj: *mut CpuInfoS390);
    pub fn qapi_free_CpuInfoFast(obj: *mut CpuInfoFast);
    pub fn qapi_free_CpuInfoFastList(obj: *mut CpuInfoFastList);
    pub fn qapi_free_CompatProperty(obj: *mut CompatProperty);
    pub fn qapi_free_CompatPropertyList(obj: *mut CompatPropertyList);
    pub fn qapi_free_MachineInfo(obj: *mut MachineInfo);
    pub fn qapi_free_MachineInfoList(obj: *mut MachineInfoList);
    pub fn qapi_free_CurrentMachineParams(obj: *mut CurrentMachineParams);
    pub fn qapi_free_TargetInfo(obj: *mut TargetInfo);
    pub fn qapi_free_UuidInfo(obj: *mut UuidInfo);
    pub fn qapi_free_GuidInfo(obj: *mut GuidInfo);
    pub fn qapi_free_KvmInfo(obj: *mut KvmInfo);
    pub fn qapi_free_NumaOptions(obj: *mut NumaOptions);
    pub fn qapi_free_NumaNodeOptions(obj: *mut NumaNodeOptions);
    pub fn qapi_free_NumaDistOptions(obj: *mut NumaDistOptions);
    pub fn qapi_free_CXLFixedMemoryWindowOptions(obj: *mut CXLFixedMemoryWindowOptions);
    pub fn qapi_free_CXLFixedMemoryWindowOptionsList(obj: *mut CXLFixedMemoryWindowOptionsList);
    pub fn qapi_free_CXLFMWProperties(obj: *mut CXLFMWProperties);
    pub fn qapi_free_X86CPUFeatureWordInfo(obj: *mut X86CPUFeatureWordInfo);
    pub fn qapi_free_X86CPUFeatureWordInfoList(obj: *mut X86CPUFeatureWordInfoList);
    pub fn qapi_free_DummyForceArrays(obj: *mut DummyForceArrays);
    pub fn qapi_free_NumaCpuOptions(obj: *mut NumaCpuOptions);
    pub fn qapi_free_NumaHmatLBOptions(obj: *mut NumaHmatLBOptions);
    pub fn qapi_free_NumaHmatCacheOptions(obj: *mut NumaHmatCacheOptions);
    pub fn qapi_free_Memdev(obj: *mut Memdev);
    pub fn qapi_free_MemdevList(obj: *mut MemdevList);
    pub fn qapi_free_CpuInstanceProperties(obj: *mut CpuInstanceProperties);
    pub fn qapi_free_HotpluggableCPU(obj: *mut HotpluggableCPU);
    pub fn qapi_free_HotpluggableCPUList(obj: *mut HotpluggableCPUList);
    pub fn qapi_free_BalloonInfo(obj: *mut BalloonInfo);
    pub fn qapi_free_HvBalloonInfo(obj: *mut HvBalloonInfo);
    pub fn qapi_free_MemoryInfo(obj: *mut MemoryInfo);
    pub fn qapi_free_PCDIMMDeviceInfo(obj: *mut PCDIMMDeviceInfo);
    pub fn qapi_free_VirtioPMEMDeviceInfo(obj: *mut VirtioPMEMDeviceInfo);
    pub fn qapi_free_VirtioMEMDeviceInfo(obj: *mut VirtioMEMDeviceInfo);
    pub fn qapi_free_SgxEPCDeviceInfo(obj: *mut SgxEPCDeviceInfo);
    pub fn qapi_free_HvBalloonDeviceInfo(obj: *mut HvBalloonDeviceInfo);
    pub fn qapi_free_PCDIMMDeviceInfoWrapper(obj: *mut PCDIMMDeviceInfoWrapper);
    pub fn qapi_free_VirtioPMEMDeviceInfoWrapper(obj: *mut VirtioPMEMDeviceInfoWrapper);
    pub fn qapi_free_VirtioMEMDeviceInfoWrapper(obj: *mut VirtioMEMDeviceInfoWrapper);
    pub fn qapi_free_SgxEPCDeviceInfoWrapper(obj: *mut SgxEPCDeviceInfoWrapper);
    pub fn qapi_free_HvBalloonDeviceInfoWrapper(obj: *mut HvBalloonDeviceInfoWrapper);
    pub fn qapi_free_MemoryDeviceInfo(obj: *mut MemoryDeviceInfo);
    pub fn qapi_free_SgxEPC(obj: *mut SgxEPC);
    pub fn qapi_free_SgxEPCList(obj: *mut SgxEPCList);
    pub fn qapi_free_SgxEPCProperties(obj: *mut SgxEPCProperties);
    pub fn qapi_free_MemoryDeviceInfoList(obj: *mut MemoryDeviceInfoList);
    pub fn qapi_free_BootConfiguration(obj: *mut BootConfiguration);
    pub fn qapi_free_SMPConfiguration(obj: *mut SMPConfiguration);
    pub fn qapi_free_MemorySizeConfiguration(obj: *mut MemorySizeConfiguration);
    pub static RunState_lookup: QEnumLookup;
    pub static ShutdownCause_lookup: QEnumLookup;
    pub static WatchdogAction_lookup: QEnumLookup;
    pub static RebootAction_lookup: QEnumLookup;
    pub static ShutdownAction_lookup: QEnumLookup;
    pub static PanicAction_lookup: QEnumLookup;
    pub static GuestPanicAction_lookup: QEnumLookup;
    pub static GuestPanicInformationType_lookup: QEnumLookup;
    pub static S390CrashReason_lookup: QEnumLookup;
    pub static MemoryFailureRecipient_lookup: QEnumLookup;
    pub static MemoryFailureAction_lookup: QEnumLookup;
    pub static NotifyVmexitOption_lookup: QEnumLookup;
    pub fn qapi_free_StatusInfo(obj: *mut StatusInfo);
    pub fn qapi_free_GuestPanicInformation(obj: *mut GuestPanicInformation);
    pub fn qapi_free_GuestPanicInformationHyperV(obj: *mut GuestPanicInformationHyperV);
    pub fn qapi_free_GuestPanicInformationS390(obj: *mut GuestPanicInformationS390);
    pub fn qapi_free_MemoryFailureFlags(obj: *mut MemoryFailureFlags);
    pub static mut cpus_queue: CPUTailQ;
    pub static mut current_cpu: *mut CPUState;
    pub static mut mttcg_enabled: bool;
    pub fn cpu_paging_enabled(cpu: *const CPUState) -> bool;
    pub fn cpu_get_memory_mapping(
        cpu: *mut CPUState,
        list: *mut MemoryMappingList,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn cpu_write_elf64_note(
        f: WriteCoreDumpFunction,
        cpu: *mut CPUState,
        cpuid: core::ffi::c_int,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn cpu_write_elf64_qemunote(
        f: WriteCoreDumpFunction,
        cpu: *mut CPUState,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn cpu_write_elf32_note(
        f: WriteCoreDumpFunction,
        cpu: *mut CPUState,
        cpuid: core::ffi::c_int,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn cpu_write_elf32_qemunote(
        f: WriteCoreDumpFunction,
        cpu: *mut CPUState,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn cpu_get_crash_info(cpu: *mut CPUState) -> *mut GuestPanicInformation;
    pub fn cpu_dump_state(cpu: *mut CPUState, f: *mut FILE, flags: core::ffi::c_int);
    pub fn cpu_get_phys_page_attrs_debug(
        cpu: *mut CPUState,
        addr: vaddr,
        attrs: *mut MemTxAttrs,
    ) -> hwaddr;
    pub fn cpu_get_phys_page_debug(cpu: *mut CPUState, addr: vaddr) -> hwaddr;
    pub fn cpu_asidx_from_attrs(cpu: *mut CPUState, attrs: MemTxAttrs) -> core::ffi::c_int;
    pub fn cpu_virtio_is_big_endian(cpu: *mut CPUState) -> bool;
    pub fn cpu_list_add(cpu: *mut CPUState);
    pub fn cpu_list_remove(cpu: *mut CPUState);
    pub fn cpu_reset(cpu: *mut CPUState);
    pub fn cpu_class_by_name(
        typename: *const core::ffi::c_char,
        cpu_model: *const core::ffi::c_char,
    ) -> *mut ObjectClass;
    pub fn cpu_model_from_type(typename: *const core::ffi::c_char) -> *mut core::ffi::c_char;
    pub fn cpu_create(typename: *const core::ffi::c_char) -> *mut CPUState;
    pub fn parse_cpu_option(cpu_option: *const core::ffi::c_char) -> *const core::ffi::c_char;
    pub fn qemu_cpu_is_self(cpu: *mut CPUState) -> bool;
    pub fn qemu_cpu_kick(cpu: *mut CPUState);
    pub fn cpu_is_stopped(cpu: *mut CPUState) -> bool;
    pub fn do_run_on_cpu(
        cpu: *mut CPUState,
        func: run_on_cpu_func,
        data: run_on_cpu_data,
        mutex: *mut QemuMutex,
    );
    pub fn run_on_cpu(cpu: *mut CPUState, func: run_on_cpu_func, data: run_on_cpu_data);
    pub fn async_run_on_cpu(cpu: *mut CPUState, func: run_on_cpu_func, data: run_on_cpu_data);
    pub fn async_safe_run_on_cpu(cpu: *mut CPUState, func: run_on_cpu_func, data: run_on_cpu_data);
    pub fn qemu_get_cpu(index: core::ffi::c_int) -> *mut CPUState;
    pub fn cpu_exists(id: i64) -> bool;
    pub fn cpu_by_arch_id(id: i64) -> *mut CPUState;
    pub fn cpu_interrupt(cpu: *mut CPUState, mask: core::ffi::c_int);
    pub fn cpu_reset_interrupt(cpu: *mut CPUState, mask: core::ffi::c_int);
    pub fn cpu_exit(cpu: *mut CPUState);
    pub fn cpu_resume(cpu: *mut CPUState);
    pub fn cpu_remove_sync(cpu: *mut CPUState);
    pub fn process_queued_cpu_work(cpu: *mut CPUState);
    pub fn cpu_exec_start(cpu: *mut CPUState);
    pub fn cpu_exec_end(cpu: *mut CPUState);
    pub fn start_exclusive();
    pub fn end_exclusive();
    pub fn qemu_init_vcpu(cpu: *mut CPUState);
    pub fn cpu_single_step(cpu: *mut CPUState, enabled: core::ffi::c_int);
    pub fn cpu_breakpoint_insert(
        cpu: *mut CPUState,
        pc: vaddr,
        flags: core::ffi::c_int,
        breakpoint: *mut *mut CPUBreakpoint,
    ) -> core::ffi::c_int;
    pub fn cpu_breakpoint_remove(
        cpu: *mut CPUState,
        pc: vaddr,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn cpu_breakpoint_remove_by_ref(cpu: *mut CPUState, breakpoint: *mut CPUBreakpoint);
    pub fn cpu_breakpoint_remove_all(cpu: *mut CPUState, mask: core::ffi::c_int);
    pub fn cpu_watchpoint_insert(
        cpu: *mut CPUState,
        addr: vaddr,
        len: vaddr,
        flags: core::ffi::c_int,
        watchpoint: *mut *mut CPUWatchpoint,
    ) -> core::ffi::c_int;
    pub fn cpu_watchpoint_remove(
        cpu: *mut CPUState,
        addr: vaddr,
        len: vaddr,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn cpu_watchpoint_remove_by_ref(cpu: *mut CPUState, watchpoint: *mut CPUWatchpoint);
    pub fn cpu_watchpoint_remove_all(cpu: *mut CPUState, mask: core::ffi::c_int);
    pub fn cpu_get_address_space(cpu: *mut CPUState, asidx: core::ffi::c_int) -> *mut AddressSpace;
    pub fn cpu_abort(cpu: *mut CPUState, fmt: *const core::ffi::c_char, ...) -> !;
    pub fn cpu_class_init_props(dc: *mut DeviceClass);
    pub fn cpu_exec_initfn(cpu: *mut CPUState);
    pub fn cpu_exec_realizefn(cpu: *mut CPUState, errp: *mut *mut Error) -> bool;
    pub fn cpu_exec_unrealizefn(cpu: *mut CPUState);
    pub fn cpu_exec_reset_hold(cpu: *mut CPUState);
    pub fn target_name() -> *const core::ffi::c_char;
    pub static vmstate_cpu_common: VMStateDescription;
    pub fn cpu_exec_init_all();
    pub fn cpu_exec_step_atomic(cpu: *mut CPUState);
    pub static mut qemu_cpu_list_lock: QemuMutex;
    pub fn qemu_init_cpu_list();
    pub fn cpu_list_lock();
    pub fn cpu_list_unlock();
    pub fn cpu_list_generation_id_get() -> core::ffi::c_uint;
    pub fn tcg_iommu_init_notifier_list(cpu: *mut CPUState);
    pub fn tcg_iommu_free_notifier_list(cpu: *mut CPUState);
    pub fn qemu_ram_remap(addr: ram_addr_t, length: ram_addr_t);
    pub fn qemu_ram_addr_from_host(ptr: *mut core::ffi::c_void) -> ram_addr_t;
    pub fn qemu_ram_addr_from_host_nofail(ptr: *mut core::ffi::c_void) -> ram_addr_t;
    pub fn qemu_ram_block_by_name(name: *const core::ffi::c_char) -> *mut RAMBlock;
    pub fn qemu_ram_block_from_host(
        ptr: *mut core::ffi::c_void,
        round_offset: bool,
        offset: *mut ram_addr_t,
    ) -> *mut RAMBlock;
    pub fn qemu_ram_block_host_offset(
        rb: *mut RAMBlock,
        host: *mut core::ffi::c_void,
    ) -> ram_addr_t;
    pub fn qemu_ram_set_idstr(
        block: *mut RAMBlock,
        name: *const core::ffi::c_char,
        dev: *mut DeviceState,
    );
    pub fn qemu_ram_unset_idstr(block: *mut RAMBlock);
    pub fn qemu_ram_get_idstr(rb: *mut RAMBlock) -> *const core::ffi::c_char;
    pub fn qemu_ram_get_host_addr(rb: *mut RAMBlock) -> *mut core::ffi::c_void;
    pub fn qemu_ram_get_offset(rb: *mut RAMBlock) -> ram_addr_t;
    pub fn qemu_ram_get_used_length(rb: *mut RAMBlock) -> ram_addr_t;
    pub fn qemu_ram_get_max_length(rb: *mut RAMBlock) -> ram_addr_t;
    pub fn qemu_ram_is_shared(rb: *mut RAMBlock) -> bool;
    pub fn qemu_ram_is_noreserve(rb: *mut RAMBlock) -> bool;
    pub fn qemu_ram_is_uf_zeroable(rb: *mut RAMBlock) -> bool;
    pub fn qemu_ram_set_uf_zeroable(rb: *mut RAMBlock);
    pub fn qemu_ram_is_migratable(rb: *mut RAMBlock) -> bool;
    pub fn qemu_ram_set_migratable(rb: *mut RAMBlock);
    pub fn qemu_ram_unset_migratable(rb: *mut RAMBlock);
    pub fn qemu_ram_is_named_file(rb: *mut RAMBlock) -> bool;
    pub fn qemu_ram_get_fd(rb: *mut RAMBlock) -> core::ffi::c_int;
    pub fn qemu_ram_pagesize(block: *mut RAMBlock) -> usize;
    pub fn qemu_ram_pagesize_largest() -> usize;
    pub fn cpu_address_space_init(
        cpu: *mut CPUState,
        asidx: core::ffi::c_int,
        prefix: *const core::ffi::c_char,
        mr: *mut MemoryRegion,
    );
    pub fn cpu_physical_memory_rw(
        addr: hwaddr,
        buf: *mut core::ffi::c_void,
        len: hwaddr,
        is_write: bool,
    );
    pub fn cpu_physical_memory_map(
        addr: hwaddr,
        plen: *mut hwaddr,
        is_write: bool,
    ) -> *mut core::ffi::c_void;
    pub fn cpu_physical_memory_unmap(
        buffer: *mut core::ffi::c_void,
        len: hwaddr,
        is_write: bool,
        access_len: hwaddr,
    );
    pub fn cpu_physical_memory_is_io(phys_addr: hwaddr) -> bool;
    pub fn qemu_flush_coalesced_mmio_buffer();
    pub fn cpu_flush_icache_range(start: hwaddr, len: hwaddr);
    pub fn qemu_ram_foreach_block(
        func: RAMBlockIterFunc,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn ram_block_discard_range(
        rb: *mut RAMBlock,
        start: u64,
        length: usize,
    ) -> core::ffi::c_int;
    pub fn ram_block_discard_guest_memfd_range(
        rb: *mut RAMBlock,
        start: u64,
        length: usize,
    ) -> core::ffi::c_int;
    pub fn cpu_memory_rw_debug(
        cpu: *mut CPUState,
        addr: vaddr,
        ptr: *mut core::ffi::c_void,
        len: usize,
        is_write: bool,
    ) -> core::ffi::c_int;
    pub fn list_cpus();
    pub fn tcg_cflags_has(cpu: *mut CPUState, flags: u32) -> bool;
    pub fn tcg_cflags_set(cpu: *mut CPUState, flags: u32);
    pub fn curr_cflags(cpu: *mut CPUState) -> u32;
    pub fn cpu_unwind_state_data(cpu: *mut CPUState, host_pc: usize, data: *mut u64) -> bool;
    pub fn cpu_restore_state(cpu: *mut CPUState, host_pc: usize) -> bool;
    pub fn cpu_loop_exit_noexc(cpu: *mut CPUState) -> !;
    pub fn cpu_loop_exit_atomic(cpu: *mut CPUState, pc: usize) -> !;
    pub fn cpu_loop_exit(cpu: *mut CPUState) -> !;
    pub fn cpu_loop_exit_restore(cpu: *mut CPUState, pc: usize) -> !;
    pub fn cpu_exec(cpu: *mut CPUState) -> core::ffi::c_int;
    pub static mut ram_list: RAMList;
    pub fn qemu_mutex_lock_ramlist();
    pub fn qemu_mutex_unlock_ramlist();
    pub fn ram_block_notifier_add(n: *mut RAMBlockNotifier);
    pub fn ram_block_notifier_remove(n: *mut RAMBlockNotifier);
    pub fn ram_block_notify_add(host: *mut core::ffi::c_void, size: usize, max_size: usize);
    pub fn ram_block_notify_remove(host: *mut core::ffi::c_void, size: usize, max_size: usize);
    pub fn ram_block_notify_resize(host: *mut core::ffi::c_void, old_size: usize, new_size: usize);
    pub fn ram_block_format() -> *mut GString;
    pub fn range_compare(a: *mut Range, b: *mut Range) -> core::ffi::c_int;
    pub fn range_list_insert(list: *mut GList, data: *mut Range) -> *mut GList;
    pub fn range_inverse_array(
        in_ranges: *mut GList,
        out_ranges: *mut *mut GList,
        low: u64,
        high: u64,
    );
    pub static mut global_dirty_tracking: core::ffi::c_uint;
    pub fn ram_discard_manager_get_min_granularity(
        rdm: *const RamDiscardManager,
        mr: *const MemoryRegion,
    ) -> u64;
    pub fn ram_discard_manager_is_populated(
        rdm: *const RamDiscardManager,
        section: *const MemoryRegionSection,
    ) -> bool;
    pub fn ram_discard_manager_replay_populated(
        rdm: *const RamDiscardManager,
        section: *mut MemoryRegionSection,
        replay_fn: ReplayRamPopulate,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn ram_discard_manager_replay_discarded(
        rdm: *const RamDiscardManager,
        section: *mut MemoryRegionSection,
        replay_fn: ReplayRamDiscard,
        opaque: *mut core::ffi::c_void,
    );
    pub fn ram_discard_manager_register_listener(
        rdm: *mut RamDiscardManager,
        rdl: *mut RamDiscardListener,
        section: *mut MemoryRegionSection,
    );
    pub fn ram_discard_manager_unregister_listener(
        rdm: *mut RamDiscardManager,
        rdl: *mut RamDiscardListener,
    );
    pub fn memory_get_xlat_addr(
        iotlb: *mut IOMMUTLBEntry,
        vaddr: *mut *mut core::ffi::c_void,
        ram_addr: *mut ram_addr_t,
        read_only: *mut bool,
        mr_has_discard_manager: *mut bool,
    ) -> bool;
    pub fn flatview_for_each_range(
        fv: *mut FlatView,
        cb: flatview_cb,
        opaque: *mut core::ffi::c_void,
    );
    pub fn memory_region_section_new_copy(s: *mut MemoryRegionSection) -> *mut MemoryRegionSection;
    pub fn memory_region_section_free_copy(s: *mut MemoryRegionSection);
    pub fn memory_region_init(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
    );
    pub fn memory_region_ref(mr: *mut MemoryRegion);
    pub fn memory_region_unref(mr: *mut MemoryRegion);
    pub fn memory_region_init_io(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        ops: *const MemoryRegionOps,
        opaque: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
        size: u64,
    );
    pub fn memory_region_init_ram_nomigrate(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn memory_region_init_ram_flags_nomigrate(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
        ram_flags: u32,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn memory_region_init_resizeable_ram(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
        max_size: u64,
        resized: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const core::ffi::c_char,
                length: u64,
                host: *mut core::ffi::c_void,
            ),
        >,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn memory_region_init_ram_from_file(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
        align: u64,
        ram_flags: u32,
        path: *const core::ffi::c_char,
        offset: ram_addr_t,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn memory_region_init_ram_from_fd(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
        ram_flags: u32,
        fd: core::ffi::c_int,
        offset: ram_addr_t,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn memory_region_init_ram_ptr(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
        ptr: *mut core::ffi::c_void,
    );
    pub fn memory_region_init_ram_device_ptr(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
        ptr: *mut core::ffi::c_void,
    );
    pub fn memory_region_init_alias(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        orig: *mut MemoryRegion,
        offset: hwaddr,
        size: u64,
    );
    pub fn memory_region_init_rom_nomigrate(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn memory_region_init_rom_device_nomigrate(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        ops: *const MemoryRegionOps,
        opaque: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn memory_region_init_iommu(
        _iommu_mr: *mut core::ffi::c_void,
        instance_size: usize,
        mrtypename: *const core::ffi::c_char,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
    );
    pub fn memory_region_init_ram(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn memory_region_init_rom(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        name: *const core::ffi::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn memory_region_init_rom_device(
        mr: *mut MemoryRegion,
        owner: *mut Object,
        ops: *const MemoryRegionOps,
        opaque: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
        size: u64,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn memory_region_owner(mr: *mut MemoryRegion) -> *mut Object;
    pub fn memory_region_size(mr: *mut MemoryRegion) -> u64;
    pub fn memory_region_is_ram_device(mr: *mut MemoryRegion) -> bool;
    pub fn memory_region_is_protected(mr: *mut MemoryRegion) -> bool;
    pub fn memory_region_has_guest_memfd(mr: *mut MemoryRegion) -> bool;
    pub fn memory_region_iommu_get_min_page_size(iommu_mr: *mut IOMMUMemoryRegion) -> u64;
    pub fn memory_region_notify_iommu(
        iommu_mr: *mut IOMMUMemoryRegion,
        iommu_idx: core::ffi::c_int,
        event: IOMMUTLBEvent,
    );
    pub fn memory_region_notify_iommu_one(notifier: *mut IOMMUNotifier, event: *mut IOMMUTLBEvent);
    pub fn memory_region_unmap_iommu_notifier_range(notifier: *mut IOMMUNotifier);
    pub fn memory_region_register_iommu_notifier(
        mr: *mut MemoryRegion,
        n: *mut IOMMUNotifier,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn memory_region_iommu_replay(iommu_mr: *mut IOMMUMemoryRegion, n: *mut IOMMUNotifier);
    pub fn memory_region_unregister_iommu_notifier(mr: *mut MemoryRegion, n: *mut IOMMUNotifier);
    pub fn memory_region_iommu_get_attr(
        iommu_mr: *mut IOMMUMemoryRegion,
        attr: IOMMUMemoryRegionAttr,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn memory_region_iommu_attrs_to_index(
        iommu_mr: *mut IOMMUMemoryRegion,
        attrs: MemTxAttrs,
    ) -> core::ffi::c_int;
    pub fn memory_region_iommu_num_indexes(iommu_mr: *mut IOMMUMemoryRegion) -> core::ffi::c_int;
    pub fn memory_region_iommu_set_page_size_mask(
        iommu_mr: *mut IOMMUMemoryRegion,
        page_size_mask: u64,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn memory_region_iommu_set_iova_ranges(
        iommu: *mut IOMMUMemoryRegion,
        iova_ranges: *mut GList,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn memory_region_name(mr: *const MemoryRegion) -> *const core::ffi::c_char;
    pub fn memory_region_is_logging(mr: *mut MemoryRegion, client: u8) -> bool;
    pub fn memory_region_get_dirty_log_mask(mr: *mut MemoryRegion) -> u8;
    pub fn memory_region_get_fd(mr: *mut MemoryRegion) -> core::ffi::c_int;
    pub fn memory_region_from_host(
        ptr: *mut core::ffi::c_void,
        offset: *mut ram_addr_t,
    ) -> *mut MemoryRegion;
    pub fn memory_region_get_ram_ptr(mr: *mut MemoryRegion) -> *mut core::ffi::c_void;
    pub fn memory_region_ram_resize(
        mr: *mut MemoryRegion,
        newsize: ram_addr_t,
        errp: *mut *mut Error,
    );
    pub fn memory_region_msync(mr: *mut MemoryRegion, addr: hwaddr, size: hwaddr);
    pub fn memory_region_writeback(mr: *mut MemoryRegion, addr: hwaddr, size: hwaddr);
    pub fn memory_region_set_log(mr: *mut MemoryRegion, log: bool, client: core::ffi::c_uint);
    pub fn memory_region_set_dirty(mr: *mut MemoryRegion, addr: hwaddr, size: hwaddr);
    pub fn memory_region_clear_dirty_bitmap(mr: *mut MemoryRegion, start: hwaddr, len: hwaddr);
    pub fn memory_region_snapshot_and_clear_dirty(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: hwaddr,
        client: core::ffi::c_uint,
    ) -> *mut DirtyBitmapSnapshot;
    pub fn memory_region_snapshot_get_dirty(
        mr: *mut MemoryRegion,
        snap: *mut DirtyBitmapSnapshot,
        addr: hwaddr,
        size: hwaddr,
    ) -> bool;
    pub fn memory_region_reset_dirty(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: hwaddr,
        client: core::ffi::c_uint,
    );
    pub fn memory_region_flush_rom_device(mr: *mut MemoryRegion, addr: hwaddr, size: hwaddr);
    pub fn memory_region_set_readonly(mr: *mut MemoryRegion, readonly: bool);
    pub fn memory_region_set_nonvolatile(mr: *mut MemoryRegion, nonvolatile: bool);
    pub fn memory_region_rom_device_set_romd(mr: *mut MemoryRegion, romd_mode: bool);
    pub fn memory_region_set_coalescing(mr: *mut MemoryRegion);
    pub fn memory_region_add_coalescing(mr: *mut MemoryRegion, offset: hwaddr, size: u64);
    pub fn memory_region_clear_coalescing(mr: *mut MemoryRegion);
    pub fn memory_region_set_flush_coalesced(mr: *mut MemoryRegion);
    pub fn memory_region_clear_flush_coalesced(mr: *mut MemoryRegion);
    pub fn memory_region_add_eventfd(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: core::ffi::c_uint,
        match_data: bool,
        data: u64,
        e: *mut EventNotifier,
    );
    pub fn memory_region_del_eventfd(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: core::ffi::c_uint,
        match_data: bool,
        data: u64,
        e: *mut EventNotifier,
    );
    pub fn memory_region_add_subregion(
        mr: *mut MemoryRegion,
        offset: hwaddr,
        subregion: *mut MemoryRegion,
    );
    pub fn memory_region_add_subregion_overlap(
        mr: *mut MemoryRegion,
        offset: hwaddr,
        subregion: *mut MemoryRegion,
        priority: core::ffi::c_int,
    );
    pub fn memory_region_get_ram_addr(mr: *mut MemoryRegion) -> ram_addr_t;
    pub fn memory_region_get_alignment(mr: *const MemoryRegion) -> u64;
    pub fn memory_region_del_subregion(mr: *mut MemoryRegion, subregion: *mut MemoryRegion);
    pub fn memory_region_set_enabled(mr: *mut MemoryRegion, enabled: bool);
    pub fn memory_region_set_address(mr: *mut MemoryRegion, addr: hwaddr);
    pub fn memory_region_set_size(mr: *mut MemoryRegion, size: u64);
    pub fn memory_region_set_alias_offset(mr: *mut MemoryRegion, offset: hwaddr);
    pub fn memory_region_set_unmergeable(mr: *mut MemoryRegion, unmergeable: bool);
    pub fn memory_region_present(container: *mut MemoryRegion, addr: hwaddr) -> bool;
    pub fn memory_region_is_mapped(mr: *mut MemoryRegion) -> bool;
    pub fn memory_region_get_ram_discard_manager(mr: *mut MemoryRegion) -> *mut RamDiscardManager;
    pub fn memory_region_set_ram_discard_manager(
        mr: *mut MemoryRegion,
        rdm: *mut RamDiscardManager,
    );
    pub fn memory_region_find(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: u64,
    ) -> MemoryRegionSection;
    pub fn memory_global_dirty_log_sync(last_stage: bool);
    pub fn memory_global_after_dirty_log_sync();
    pub fn memory_region_transaction_begin();
    pub fn memory_region_transaction_commit();
    pub fn memory_listener_register(listener: *mut MemoryListener, filter: *mut AddressSpace);
    pub fn memory_listener_unregister(listener: *mut MemoryListener);
    pub fn memory_global_dirty_log_start(flags: core::ffi::c_uint, errp: *mut *mut Error) -> bool;
    pub fn memory_global_dirty_log_stop(flags: core::ffi::c_uint);
    pub fn mtree_info(flatview: bool, dispatch_tree: bool, owner: bool, disabled: bool);
    pub fn memory_region_access_valid(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        size: core::ffi::c_uint,
        is_write: bool,
        attrs: MemTxAttrs,
    ) -> bool;
    pub fn memory_region_dispatch_read(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        pval: *mut u64,
        op: MemOp,
        attrs: MemTxAttrs,
    ) -> MemTxResult;
    pub fn memory_region_dispatch_write(
        mr: *mut MemoryRegion,
        addr: hwaddr,
        data: u64,
        op: MemOp,
        attrs: MemTxAttrs,
    ) -> MemTxResult;
    pub fn address_space_init(
        as_: *mut AddressSpace,
        root: *mut MemoryRegion,
        name: *const core::ffi::c_char,
    );
    pub fn address_space_destroy(as_: *mut AddressSpace);
    pub fn address_space_remove_listeners(as_: *mut AddressSpace);
    pub fn address_space_rw(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        buf: *mut core::ffi::c_void,
        len: hwaddr,
        is_write: bool,
    ) -> MemTxResult;
    pub fn address_space_write(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        buf: *const core::ffi::c_void,
        len: hwaddr,
    ) -> MemTxResult;
    pub fn address_space_write_rom(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        buf: *const core::ffi::c_void,
        len: hwaddr,
    ) -> MemTxResult;
    pub fn address_space_ldub(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u8;
    pub fn address_space_lduw_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u16;
    pub fn address_space_lduw_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u16;
    pub fn address_space_ldl_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u32;
    pub fn address_space_ldl_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u32;
    pub fn address_space_ldq_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u64;
    pub fn address_space_ldq_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u64;
    pub fn address_space_stb(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u8,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stw_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u16,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stw_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u16,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stl_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stl_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stq_le(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u64,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stq_be(
        as_: *mut AddressSpace,
        addr: hwaddr,
        val: u64,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_ldub_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u8;
    pub fn address_space_lduw_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u16;
    pub fn address_space_lduw_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u16;
    pub fn address_space_ldl_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u32;
    pub fn address_space_ldl_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u32;
    pub fn address_space_ldq_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u64;
    pub fn address_space_ldq_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    ) -> u64;
    pub fn address_space_stb_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u8,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stw_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u16,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stw_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u16,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stl_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stl_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u32,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stq_le_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u64,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_stq_be_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        val: u64,
        attrs: MemTxAttrs,
        result: *mut MemTxResult,
    );
    pub fn address_space_cache_init(
        cache: *mut MemoryRegionCache,
        as_: *mut AddressSpace,
        addr: hwaddr,
        len: hwaddr,
        is_write: bool,
    ) -> i64;
    pub fn address_space_cache_invalidate(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        access_len: hwaddr,
    );
    pub fn address_space_cache_destroy(cache: *mut MemoryRegionCache);
    pub fn address_space_get_iotlb_entry(
        as_: *mut AddressSpace,
        addr: hwaddr,
        is_write: bool,
        attrs: MemTxAttrs,
    ) -> IOMMUTLBEntry;
    pub fn flatview_translate(
        fv: *mut FlatView,
        addr: hwaddr,
        xlat: *mut hwaddr,
        len: *mut hwaddr,
        is_write: bool,
        attrs: MemTxAttrs,
    ) -> *mut MemoryRegion;
    pub fn address_space_access_valid(
        as_: *mut AddressSpace,
        addr: hwaddr,
        len: hwaddr,
        is_write: bool,
        attrs: MemTxAttrs,
    ) -> bool;
    pub fn address_space_map(
        as_: *mut AddressSpace,
        addr: hwaddr,
        plen: *mut hwaddr,
        is_write: bool,
        attrs: MemTxAttrs,
    ) -> *mut core::ffi::c_void;
    pub fn address_space_unmap(
        as_: *mut AddressSpace,
        buffer: *mut core::ffi::c_void,
        len: hwaddr,
        is_write: bool,
        access_len: hwaddr,
    );
    pub fn address_space_register_map_client(as_: *mut AddressSpace, bh: *mut QEMUBH);
    pub fn address_space_unregister_map_client(as_: *mut AddressSpace, bh: *mut QEMUBH);
    pub fn address_space_read_full(
        as_: *mut AddressSpace,
        addr: hwaddr,
        attrs: MemTxAttrs,
        buf: *mut core::ffi::c_void,
        len: hwaddr,
    ) -> MemTxResult;
    pub fn flatview_read_continue(
        fv: *mut FlatView,
        addr: hwaddr,
        attrs: MemTxAttrs,
        buf: *mut core::ffi::c_void,
        len: hwaddr,
        addr1: hwaddr,
        l: hwaddr,
        mr: *mut MemoryRegion,
    ) -> MemTxResult;
    pub fn qemu_map_ram_ptr(ram_block: *mut RAMBlock, addr: ram_addr_t) -> *mut core::ffi::c_void;
    pub fn address_space_read_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        buf: *mut core::ffi::c_void,
        len: hwaddr,
    ) -> MemTxResult;
    pub fn address_space_write_cached_slow(
        cache: *mut MemoryRegionCache,
        addr: hwaddr,
        buf: *const core::ffi::c_void,
        len: hwaddr,
    ) -> MemTxResult;
    pub fn memory_access_size(
        mr: *mut MemoryRegion,
        l: core::ffi::c_uint,
        addr: hwaddr,
    ) -> core::ffi::c_int;
    pub fn prepare_mmio_access(mr: *mut MemoryRegion) -> bool;
    pub fn address_space_set(
        as_: *mut AddressSpace,
        addr: hwaddr,
        c: u8,
        len: hwaddr,
        attrs: MemTxAttrs,
    ) -> MemTxResult;
    pub fn ram_block_discard_disable(state: bool) -> core::ffi::c_int;
    pub fn ram_block_uncoordinated_discard_disable(state: bool) -> core::ffi::c_int;
    pub fn ram_block_discard_require(state: bool) -> core::ffi::c_int;
    pub fn ram_block_coordinated_discard_require(state: bool) -> core::ffi::c_int;
    pub fn ram_block_discard_is_disabled() -> bool;
    pub fn ram_block_discard_is_required() -> bool;
    pub fn sysbus_init_mmio(dev: *mut SysBusDevice, memory: *mut MemoryRegion);
    pub fn sysbus_mmio_get_region(dev: *mut SysBusDevice, n: core::ffi::c_int)
        -> *mut MemoryRegion;
    pub fn sysbus_init_irq(dev: *mut SysBusDevice, p: *mut qemu_irq);
    pub fn sysbus_pass_irq(dev: *mut SysBusDevice, target: *mut SysBusDevice);
    pub fn sysbus_init_ioports(dev: *mut SysBusDevice, ioport: u32, size: u32);
    pub fn sysbus_has_irq(dev: *mut SysBusDevice, n: core::ffi::c_int) -> bool;
    pub fn sysbus_has_mmio(dev: *mut SysBusDevice, n: core::ffi::c_uint) -> bool;
    pub fn sysbus_connect_irq(dev: *mut SysBusDevice, n: core::ffi::c_int, irq: qemu_irq);
    pub fn sysbus_is_irq_connected(dev: *mut SysBusDevice, n: core::ffi::c_int) -> bool;
    pub fn sysbus_get_connected_irq(dev: *mut SysBusDevice, n: core::ffi::c_int) -> qemu_irq;
    pub fn sysbus_mmio_map(dev: *mut SysBusDevice, n: core::ffi::c_int, addr: hwaddr);
    pub fn sysbus_mmio_map_overlap(
        dev: *mut SysBusDevice,
        n: core::ffi::c_int,
        addr: hwaddr,
        priority: core::ffi::c_int,
    );
    pub fn sysbus_mmio_unmap(dev: *mut SysBusDevice, n: core::ffi::c_int);
    pub fn sysbus_realize(dev: *mut SysBusDevice, errp: *mut *mut Error) -> bool;
    pub fn sysbus_realize_and_unref(dev: *mut SysBusDevice, errp: *mut *mut Error) -> bool;
    pub fn foreach_dynamic_sysbus_device(
        func: FindSysbusDeviceFunc,
        opaque: *mut core::ffi::c_void,
    );
    pub fn sysbus_create_varargs(
        name: *const core::ffi::c_char,
        addr: hwaddr,
        ...
    ) -> *mut DeviceState;
    pub static NetworkAddressFamily_lookup: QEnumLookup;
    pub static SocketAddressType_lookup: QEnumLookup;
    pub fn qapi_free_InetSocketAddressBase(obj: *mut InetSocketAddressBase);
    pub fn qapi_free_InetSocketAddress(obj: *mut InetSocketAddress);
    pub fn qapi_free_UnixSocketAddress(obj: *mut UnixSocketAddress);
    pub fn qapi_free_VsockSocketAddress(obj: *mut VsockSocketAddress);
    pub fn qapi_free_FdSocketAddress(obj: *mut FdSocketAddress);
    pub fn qapi_free_InetSocketAddressWrapper(obj: *mut InetSocketAddressWrapper);
    pub fn qapi_free_UnixSocketAddressWrapper(obj: *mut UnixSocketAddressWrapper);
    pub fn qapi_free_VsockSocketAddressWrapper(obj: *mut VsockSocketAddressWrapper);
    pub fn qapi_free_FdSocketAddressWrapper(obj: *mut FdSocketAddressWrapper);
    pub fn qapi_free_SocketAddressLegacy(obj: *mut SocketAddressLegacy);
    pub fn qapi_free_SocketAddress(obj: *mut SocketAddress);
    pub fn qapi_free_SocketAddressList(obj: *mut SocketAddressList);
    pub fn qapi_free_InetSocketAddressBaseList(obj: *mut InetSocketAddressBaseList);
    pub static DataFormat_lookup: QEnumLookup;
    pub static ChardevBackendKind_lookup: QEnumLookup;
    pub fn qapi_free_ChardevInfo(obj: *mut ChardevInfo);
    pub fn qapi_free_ChardevInfoList(obj: *mut ChardevInfoList);
    pub fn qapi_free_ChardevBackendInfo(obj: *mut ChardevBackendInfo);
    pub fn qapi_free_ChardevBackendInfoList(obj: *mut ChardevBackendInfoList);
    pub fn qapi_free_ChardevCommon(obj: *mut ChardevCommon);
    pub fn qapi_free_ChardevFile(obj: *mut ChardevFile);
    pub fn qapi_free_ChardevHostdev(obj: *mut ChardevHostdev);
    pub fn qapi_free_ChardevSocket(obj: *mut ChardevSocket);
    pub fn qapi_free_ChardevUdp(obj: *mut ChardevUdp);
    pub fn qapi_free_ChardevMux(obj: *mut ChardevMux);
    pub fn qapi_free_ChardevStdio(obj: *mut ChardevStdio);
    pub fn qapi_free_ChardevDBus(obj: *mut ChardevDBus);
    pub fn qapi_free_ChardevVC(obj: *mut ChardevVC);
    pub fn qapi_free_ChardevRingbuf(obj: *mut ChardevRingbuf);
    pub fn qapi_free_ChardevFileWrapper(obj: *mut ChardevFileWrapper);
    pub fn qapi_free_ChardevHostdevWrapper(obj: *mut ChardevHostdevWrapper);
    pub fn qapi_free_ChardevSocketWrapper(obj: *mut ChardevSocketWrapper);
    pub fn qapi_free_ChardevUdpWrapper(obj: *mut ChardevUdpWrapper);
    pub fn qapi_free_ChardevCommonWrapper(obj: *mut ChardevCommonWrapper);
    pub fn qapi_free_ChardevMuxWrapper(obj: *mut ChardevMuxWrapper);
    pub fn qapi_free_ChardevStdioWrapper(obj: *mut ChardevStdioWrapper);
    pub fn qapi_free_ChardevDBusWrapper(obj: *mut ChardevDBusWrapper);
    pub fn qapi_free_ChardevVCWrapper(obj: *mut ChardevVCWrapper);
    pub fn qapi_free_ChardevRingbufWrapper(obj: *mut ChardevRingbufWrapper);
    pub fn qapi_free_ChardevBackend(obj: *mut ChardevBackend);
    pub fn qapi_free_ChardevReturn(obj: *mut ChardevReturn);
    pub fn qemu_chr_new_from_opts(
        opts: *mut QemuOpts,
        context: *mut GMainContext,
        errp: *mut *mut Error,
    ) -> *mut Chardev;
    pub fn qemu_chr_parse_common(opts: *mut QemuOpts, backend: *mut ChardevCommon);
    pub fn qemu_chr_parse_opts(opts: *mut QemuOpts, errp: *mut *mut Error) -> *mut ChardevBackend;
    pub fn qemu_chr_new(
        label: *const core::ffi::c_char,
        filename: *const core::ffi::c_char,
        context: *mut GMainContext,
    ) -> *mut Chardev;
    pub fn qemu_chr_new_mux_mon(
        label: *const core::ffi::c_char,
        filename: *const core::ffi::c_char,
        context: *mut GMainContext,
    ) -> *mut Chardev;
    pub fn qemu_chr_change(opts: *mut QemuOpts, errp: *mut *mut Error);
    pub fn qemu_chr_cleanup();
    pub fn qemu_chr_new_noreplay(
        label: *const core::ffi::c_char,
        filename: *const core::ffi::c_char,
        permit_mux_mon: bool,
        context: *mut GMainContext,
    ) -> *mut Chardev;
    pub fn qemu_chr_be_can_write(s: *mut Chardev) -> core::ffi::c_int;
    pub fn qemu_chr_be_write(s: *mut Chardev, buf: *const u8, len: core::ffi::c_int);
    pub fn qemu_chr_be_write_impl(s: *mut Chardev, buf: *const u8, len: core::ffi::c_int);
    pub fn qemu_chr_be_update_read_handlers(s: *mut Chardev, context: *mut GMainContext);
    pub fn qemu_chr_be_event(s: *mut Chardev, event: QEMUChrEvent);
    pub fn qemu_chr_add_client(s: *mut Chardev, fd: core::ffi::c_int) -> core::ffi::c_int;
    pub fn qemu_chr_find(name: *const core::ffi::c_char) -> *mut Chardev;
    pub fn qemu_chr_has_feature(chr: *mut Chardev, feature: ChardevFeature) -> bool;
    pub fn qemu_chr_set_feature(chr: *mut Chardev, feature: ChardevFeature);
    pub fn qemu_chr_parse_compat(
        label: *const core::ffi::c_char,
        filename: *const core::ffi::c_char,
        permit_mux_mon: bool,
    ) -> *mut QemuOpts;
    pub fn qemu_chr_write(
        s: *mut Chardev,
        buf: *const u8,
        len: core::ffi::c_int,
        write_all: bool,
    ) -> core::ffi::c_int;
    pub fn qemu_chr_wait_connected(chr: *mut Chardev, errp: *mut *mut Error) -> core::ffi::c_int;
    pub fn qemu_chardev_new(
        id: *const core::ffi::c_char,
        typename: *const core::ffi::c_char,
        backend: *mut ChardevBackend,
        context: *mut GMainContext,
        errp: *mut *mut Error,
    ) -> *mut Chardev;
    pub static mut term_escape_char: core::ffi::c_int;
    pub fn qemu_chr_timeout_add_ms(
        chr: *mut Chardev,
        ms: guint,
        func: GSourceFunc,
        private: *mut core::ffi::c_void,
    ) -> *mut GSource;
    pub fn suspend_mux_open();
    pub fn resume_mux_open();
    pub fn qemu_coroutine_create(
        entry: CoroutineEntry,
        opaque: *mut core::ffi::c_void,
    ) -> *mut Coroutine;
    pub fn qemu_coroutine_enter(coroutine: *mut Coroutine);
    pub fn qemu_coroutine_enter_if_inactive(co: *mut Coroutine);
    pub fn qemu_aio_coroutine_enter(ctx: *mut AioContext, co: *mut Coroutine);
    pub fn qemu_coroutine_yield();
    pub fn qemu_coroutine_get_aio_context(co: *mut Coroutine) -> *mut AioContext;
    pub fn qemu_coroutine_self() -> *mut Coroutine;
    pub fn qemu_in_coroutine() -> bool;
    pub fn qemu_coroutine_entered(co: *mut Coroutine) -> bool;
    pub fn qemu_co_mutex_init(mutex: *mut CoMutex);
    pub fn qemu_co_mutex_lock(mutex: *mut CoMutex);
    pub fn qemu_co_mutex_unlock(mutex: *mut CoMutex);
    pub fn event_notifier_init(
        arg1: *mut EventNotifier,
        active: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn event_notifier_cleanup(arg1: *mut EventNotifier);
    pub fn event_notifier_set(arg1: *mut EventNotifier) -> core::ffi::c_int;
    pub fn event_notifier_test_and_clear(arg1: *mut EventNotifier) -> core::ffi::c_int;
    pub fn event_notifier_init_fd(arg1: *mut EventNotifier, fd: core::ffi::c_int);
    pub fn event_notifier_get_fd(arg1: *const EventNotifier) -> core::ffi::c_int;
    pub fn event_notifier_get_wfd(arg1: *const EventNotifier) -> core::ffi::c_int;
    pub static mut graph_lock: BdrvGraphLock;
    pub fn register_aiocontext(ctx: *mut AioContext);
    pub fn unregister_aiocontext(ctx: *mut AioContext);
    pub fn bdrv_graph_wrlock();
    pub fn bdrv_graph_wrunlock();
    pub fn bdrv_graph_co_rdlock();
    pub fn bdrv_graph_co_rdunlock();
    pub fn bdrv_graph_rdlock_main_loop();
    pub fn bdrv_graph_rdunlock_main_loop();
    pub fn assert_bdrv_graph_readable();
    pub fn assert_bdrv_graph_writable();
    pub fn qemu_aio_get(
        aiocb_info: *const AIOCBInfo,
        bs: *mut BlockDriverState,
        cb: BlockCompletionFunc,
        opaque: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
    pub fn qemu_aio_unref(p: *mut core::ffi::c_void);
    pub fn qemu_aio_ref(p: *mut core::ffi::c_void);
    pub fn aio_poll_disabled(ctx: *mut AioContext) -> bool;
    pub fn aio_context_new(errp: *mut *mut Error) -> *mut AioContext;
    pub fn aio_context_ref(ctx: *mut AioContext);
    pub fn aio_context_unref(ctx: *mut AioContext);
    pub fn aio_bh_schedule_oneshot_full(
        ctx: *mut AioContext,
        cb: QEMUBHFunc,
        opaque: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
    );
    pub fn aio_bh_new_full(
        ctx: *mut AioContext,
        cb: QEMUBHFunc,
        opaque: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
        reentrancy_guard: *mut MemReentrancyGuard,
    ) -> *mut QEMUBH;
    pub fn aio_notify(ctx: *mut AioContext);
    pub fn aio_notify_accept(ctx: *mut AioContext);
    pub fn aio_bh_call(bh: *mut QEMUBH);
    pub fn aio_bh_poll(ctx: *mut AioContext) -> core::ffi::c_int;
    pub fn qemu_bh_schedule(bh: *mut QEMUBH);
    pub fn qemu_bh_cancel(bh: *mut QEMUBH);
    pub fn qemu_bh_delete(bh: *mut QEMUBH);
    pub fn aio_prepare(ctx: *mut AioContext) -> bool;
    pub fn aio_pending(ctx: *mut AioContext) -> bool;
    pub fn aio_dispatch(ctx: *mut AioContext);
    pub fn aio_poll(ctx: *mut AioContext, blocking: bool) -> bool;
    pub fn aio_set_fd_handler(
        ctx: *mut AioContext,
        fd: core::ffi::c_int,
        io_read: IOHandler,
        io_write: IOHandler,
        io_poll: AioPollFn,
        io_poll_ready: IOHandler,
        opaque: *mut core::ffi::c_void,
    );
    pub fn aio_set_event_notifier(
        ctx: *mut AioContext,
        notifier: *mut EventNotifier,
        io_read: EventNotifierHandler,
        io_poll: AioPollFn,
        io_poll_ready: EventNotifierHandler,
    );
    pub fn aio_set_event_notifier_poll(
        ctx: *mut AioContext,
        notifier: *mut EventNotifier,
        io_poll_begin: EventNotifierHandler,
        io_poll_end: EventNotifierHandler,
    );
    pub fn aio_get_g_source(ctx: *mut AioContext) -> *mut GSource;
    pub fn aio_get_thread_pool(ctx: *mut AioContext) -> *mut ThreadPool;
    pub fn aio_setup_linux_aio(ctx: *mut AioContext, errp: *mut *mut Error) -> *mut LinuxAioState;
    pub fn aio_get_linux_aio(ctx: *mut AioContext) -> *mut LinuxAioState;
    pub fn aio_setup_linux_io_uring(
        ctx: *mut AioContext,
        errp: *mut *mut Error,
    ) -> *mut LuringState;
    pub fn aio_get_linux_io_uring(ctx: *mut AioContext) -> *mut LuringState;
    pub fn aio_compute_timeout(ctx: *mut AioContext) -> i64;
    pub fn aio_co_schedule(ctx: *mut AioContext, co: *mut Coroutine);
    pub fn aio_co_reschedule_self(new_ctx: *mut AioContext);
    pub fn aio_co_wake(co: *mut Coroutine);
    pub fn aio_co_enter(ctx: *mut AioContext, co: *mut Coroutine);
    pub fn qemu_get_current_aio_context() -> *mut AioContext;
    pub fn qemu_set_current_aio_context(ctx: *mut AioContext);
    pub fn aio_context_setup(ctx: *mut AioContext);
    pub fn aio_context_destroy(ctx: *mut AioContext);
    pub fn aio_context_use_g_source(ctx: *mut AioContext);
    pub fn aio_context_set_poll_params(
        ctx: *mut AioContext,
        max_ns: i64,
        grow: i64,
        shrink: i64,
        errp: *mut *mut Error,
    );
    pub fn aio_context_set_aio_params(ctx: *mut AioContext, max_batch: i64);
    pub fn aio_context_set_thread_pool_params(
        ctx: *mut AioContext,
        min: i64,
        max: i64,
        errp: *mut *mut Error,
    );
    pub fn qemu_init_main_loop(errp: *mut *mut Error) -> core::ffi::c_int;
    pub fn main_loop_wait(nonblocking: core::ffi::c_int);
    pub fn qemu_get_aio_context() -> *mut AioContext;
    pub fn qemu_notify_event();
    pub fn qemu_set_fd_handler(
        fd: core::ffi::c_int,
        fd_read: IOHandler,
        fd_write: IOHandler,
        opaque: *mut core::ffi::c_void,
    );
    pub fn event_notifier_set_handler(e: *mut EventNotifier, handler: EventNotifierHandler);
    pub fn iohandler_get_g_source() -> *mut GSource;
    pub fn iohandler_get_aio_context() -> *mut AioContext;
    pub fn bql_locked() -> bool;
    pub fn qemu_in_main_thread() -> bool;
    pub fn bql_lock_impl(file: *const core::ffi::c_char, line: core::ffi::c_int);
    pub fn bql_unlock();
    pub fn qemu_cond_wait_bql(cond: *mut QemuCond);
    pub fn qemu_cond_timedwait_bql(cond: *mut QemuCond, ms: core::ffi::c_int);
    pub fn qemu_bh_new_full(
        cb: QEMUBHFunc,
        opaque: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
        reentrancy_guard: *mut MemReentrancyGuard,
    ) -> *mut QEMUBH;
    pub fn qemu_bh_schedule_idle(bh: *mut QEMUBH);
    pub fn main_loop_poll_add_notifier(notify: *mut Notifier);
    pub fn main_loop_poll_remove_notifier(notify: *mut Notifier);
    pub fn qemu_chr_fe_init(b: *mut CharBackend, s: *mut Chardev, errp: *mut *mut Error) -> bool;
    pub fn qemu_chr_fe_deinit(b: *mut CharBackend, del: bool);
    pub fn qemu_chr_fe_get_driver(be: *mut CharBackend) -> *mut Chardev;
    pub fn qemu_chr_fe_backend_connected(be: *mut CharBackend) -> bool;
    pub fn qemu_chr_fe_backend_open(be: *mut CharBackend) -> bool;
    pub fn qemu_chr_fe_set_handlers_full(
        b: *mut CharBackend,
        fd_can_read: IOCanReadHandler,
        fd_read: IOReadHandler,
        fd_event: IOEventHandler,
        be_change: BackendChangeHandler,
        opaque: *mut core::ffi::c_void,
        context: *mut GMainContext,
        set_open: bool,
        sync_state: bool,
    );
    pub fn qemu_chr_fe_set_handlers(
        b: *mut CharBackend,
        fd_can_read: IOCanReadHandler,
        fd_read: IOReadHandler,
        fd_event: IOEventHandler,
        be_change: BackendChangeHandler,
        opaque: *mut core::ffi::c_void,
        context: *mut GMainContext,
        set_open: bool,
    );
    pub fn qemu_chr_fe_take_focus(b: *mut CharBackend);
    pub fn qemu_chr_fe_accept_input(be: *mut CharBackend);
    pub fn qemu_chr_fe_disconnect(be: *mut CharBackend);
    pub fn qemu_chr_fe_wait_connected(
        be: *mut CharBackend,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn qemu_chr_fe_set_echo(be: *mut CharBackend, echo: bool);
    pub fn qemu_chr_fe_set_open(be: *mut CharBackend, is_open: bool);
    pub fn qemu_chr_fe_printf(be: *mut CharBackend, fmt: *const core::ffi::c_char, ...);
    pub fn qemu_chr_fe_add_watch(
        be: *mut CharBackend,
        cond: GIOCondition,
        func: FEWatchFunc,
        user_data: *mut core::ffi::c_void,
    ) -> guint;
    pub fn qemu_chr_fe_write(
        be: *mut CharBackend,
        buf: *const u8,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn qemu_chr_fe_write_all(
        be: *mut CharBackend,
        buf: *const u8,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn qemu_chr_fe_read_all(
        be: *mut CharBackend,
        buf: *mut u8,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn qemu_chr_fe_ioctl(
        be: *mut CharBackend,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn qemu_chr_fe_get_msgfd(be: *mut CharBackend) -> core::ffi::c_int;
    pub fn qemu_chr_fe_get_msgfds(
        be: *mut CharBackend,
        fds: *mut core::ffi::c_int,
        num: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn qemu_chr_fe_set_msgfds(
        be: *mut CharBackend,
        fds: *mut core::ffi::c_int,
        num: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub static vmstate_clock: VMStateDescription;
    pub fn clock_setup_canonical_path(clk: *mut Clock);
    pub fn clock_new(parent: *mut Object, name: *const core::ffi::c_char) -> *mut Clock;
    pub fn clock_set_callback(
        clk: *mut Clock,
        cb: ClockCallback,
        opaque: *mut core::ffi::c_void,
        events: core::ffi::c_uint,
    );
    pub fn clock_clear_callback(clk: *mut Clock);
    pub fn clock_set_source(clk: *mut Clock, src: *mut Clock);
    pub fn clock_set(clk: *mut Clock, value: u64) -> bool;
    pub fn clock_propagate(clk: *mut Clock);
    pub fn clock_display_freq(clk: *mut Clock) -> *mut core::ffi::c_char;
    pub fn clock_set_mul_div(clk: *mut Clock, multiplier: u32, divider: u32) -> bool;
    pub fn qdev_init_clock_in(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        callback: ClockCallback,
        opaque: *mut core::ffi::c_void,
        events: core::ffi::c_uint,
    ) -> *mut Clock;
    pub fn qdev_init_clock_out(dev: *mut DeviceState, name: *const core::ffi::c_char)
        -> *mut Clock;
    pub fn qdev_get_clock_in(dev: *mut DeviceState, name: *const core::ffi::c_char) -> *mut Clock;
    pub fn qdev_get_clock_out(dev: *mut DeviceState, name: *const core::ffi::c_char) -> *mut Clock;
    pub fn qdev_connect_clock_in(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        source: *mut Clock,
    );
    pub fn qdev_alias_clock(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        alias_dev: *mut DeviceState,
        alias_name: *const core::ffi::c_char,
    ) -> *mut Clock;
    pub fn qdev_finalize_clocklist(dev: *mut DeviceState);
    pub fn qdev_init_clocks(dev: *mut DeviceState, clocks: *mut ClockPortInitElem);
    pub static qdev_prop_bit: PropertyInfo;
    pub static qdev_prop_bit64: PropertyInfo;
    pub static qdev_prop_bool: PropertyInfo;
    pub static qdev_prop_enum: PropertyInfo;
    pub static qdev_prop_uint8: PropertyInfo;
    pub static qdev_prop_uint16: PropertyInfo;
    pub static qdev_prop_uint32: PropertyInfo;
    pub static qdev_prop_int32: PropertyInfo;
    pub static qdev_prop_uint64: PropertyInfo;
    pub static qdev_prop_uint64_checkmask: PropertyInfo;
    pub static qdev_prop_int64: PropertyInfo;
    pub static qdev_prop_size: PropertyInfo;
    pub static qdev_prop_string: PropertyInfo;
    pub static qdev_prop_on_off_auto: PropertyInfo;
    pub static qdev_prop_size32: PropertyInfo;
    pub static qdev_prop_array: PropertyInfo;
    pub static qdev_prop_link: PropertyInfo;
    pub fn qdev_prop_set_drive_err(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        value: *mut BlockBackend,
        errp: *mut *mut Error,
    ) -> bool;
    pub fn qdev_prop_set_bit(dev: *mut DeviceState, name: *const core::ffi::c_char, value: bool);
    pub fn qdev_prop_set_uint8(dev: *mut DeviceState, name: *const core::ffi::c_char, value: u8);
    pub fn qdev_prop_set_uint16(dev: *mut DeviceState, name: *const core::ffi::c_char, value: u16);
    pub fn qdev_prop_set_uint32(dev: *mut DeviceState, name: *const core::ffi::c_char, value: u32);
    pub fn qdev_prop_set_int32(dev: *mut DeviceState, name: *const core::ffi::c_char, value: i32);
    pub fn qdev_prop_set_uint64(dev: *mut DeviceState, name: *const core::ffi::c_char, value: u64);
    pub fn qdev_prop_set_string(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_char,
    );
    pub fn qdev_prop_set_chr(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        value: *mut Chardev,
    );
    pub fn qdev_prop_set_netdev(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        value: *mut NetClientState,
    );
    pub fn qdev_prop_set_drive(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        value: *mut BlockBackend,
    );
    pub fn qdev_prop_set_macaddr(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        value: *const u8,
    );
    pub fn qdev_prop_set_enum(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        value: core::ffi::c_int,
    );
    pub fn qdev_prop_set_array(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        values: *mut QList,
    );
    pub fn object_field_prop_ptr(obj: *mut Object, prop: *mut Property) -> *mut core::ffi::c_void;
    pub fn qdev_prop_register_global(prop: *mut GlobalProperty);
    pub fn qdev_find_global_prop(
        obj: *mut Object,
        name: *const core::ffi::c_char,
    ) -> *const GlobalProperty;
    pub fn qdev_prop_check_globals() -> core::ffi::c_int;
    pub fn qdev_prop_set_globals(dev: *mut DeviceState);
    pub fn error_set_from_qdev_prop_error(
        errp: *mut *mut Error,
        ret: core::ffi::c_int,
        obj: *mut Object,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_char,
    );
    pub fn qdev_property_add_static(dev: *mut DeviceState, prop: *mut Property);
    pub fn qdev_alias_all_properties(target: *mut DeviceState, source: *mut Object);
    pub fn qdev_prop_set_after_realize(
        dev: *mut DeviceState,
        name: *const core::ffi::c_char,
        errp: *mut *mut Error,
    );
    pub fn qdev_prop_allow_set_link_before_realize(
        obj: *const Object,
        name: *const core::ffi::c_char,
        val: *mut Object,
        errp: *mut *mut Error,
    );
    pub static qdev_prop_chr: PropertyInfo;
    pub static qdev_prop_macaddr: PropertyInfo;
    pub static qdev_prop_reserved_region: PropertyInfo;
    pub static qdev_prop_multifd_compression: PropertyInfo;
    pub static qdev_prop_mig_mode: PropertyInfo;
    pub static qdev_prop_granule_mode: PropertyInfo;
    pub static qdev_prop_zero_page_detection: PropertyInfo;
    pub static qdev_prop_losttickpolicy: PropertyInfo;
    pub static qdev_prop_blockdev_on_error: PropertyInfo;
    pub static qdev_prop_bios_chs_trans: PropertyInfo;
    pub static qdev_prop_fdc_drive_type: PropertyInfo;
    pub static qdev_prop_drive: PropertyInfo;
    pub static qdev_prop_drive_iothread: PropertyInfo;
    pub static qdev_prop_netdev: PropertyInfo;
    pub static qdev_prop_pci_devfn: PropertyInfo;
    pub static qdev_prop_blocksize: PropertyInfo;
    pub static qdev_prop_pci_host_devaddr: PropertyInfo;
    pub static qdev_prop_uuid: PropertyInfo;
    pub static qdev_prop_audiodev: PropertyInfo;
    pub static qdev_prop_off_auto_pcibar: PropertyInfo;
    pub static qdev_prop_pcie_link_speed: PropertyInfo;
    pub static qdev_prop_pcie_link_width: PropertyInfo;
    pub static qdev_prop_cpus390entitlement: PropertyInfo;
    pub static qdev_prop_iothread_vq_mapping_list: PropertyInfo;
    pub fn qemu_set_irq(irq: qemu_irq, level: core::ffi::c_int);
    pub fn qemu_allocate_irqs(
        handler: qemu_irq_handler,
        opaque: *mut core::ffi::c_void,
        n: core::ffi::c_int,
    ) -> *mut qemu_irq;
    pub fn qemu_allocate_irq(
        handler: qemu_irq_handler,
        opaque: *mut core::ffi::c_void,
        n: core::ffi::c_int,
    ) -> qemu_irq;
    pub fn qemu_extend_irqs(
        old: *mut qemu_irq,
        n_old: core::ffi::c_int,
        handler: qemu_irq_handler,
        opaque: *mut core::ffi::c_void,
        n: core::ffi::c_int,
    ) -> *mut qemu_irq;
    pub fn qemu_free_irqs(s: *mut qemu_irq, n: core::ffi::c_int);
    pub fn qemu_free_irq(irq: qemu_irq);
    pub fn qemu_irq_invert(irq: qemu_irq) -> qemu_irq;
    pub fn qemu_irq_intercept_in(
        gpio_in: *mut qemu_irq,
        handler: qemu_irq_handler,
        n: core::ffi::c_int,
    );
    pub static QapiErrorClass_lookup: QEnumLookup;
    pub fn error_get_pretty(err: *const Error) -> *const core::ffi::c_char;
    pub fn error_get_class(err: *const Error) -> ErrorClass;
    pub fn error_setg_internal(
        errp: *mut *mut Error,
        src: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        fmt: *const core::ffi::c_char,
        ...
    );
    pub fn error_setg_errno_internal(
        errp: *mut *mut Error,
        fname: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        os_error: core::ffi::c_int,
        fmt: *const core::ffi::c_char,
        ...
    );
    pub fn error_propagate(dst_errp: *mut *mut Error, local_err: *mut Error);
    pub fn error_propagate_prepend(
        dst_errp: *mut *mut Error,
        local_err: *mut Error,
        fmt: *const core::ffi::c_char,
        ...
    );
    pub fn error_vprepend(
        errp: *const *mut Error,
        fmt: *const core::ffi::c_char,
        ap: *mut __va_list_tag,
    );
    pub fn error_prepend(errp: *const *mut Error, fmt: *const core::ffi::c_char, ...);
    pub fn error_append_hint(errp: *const *mut Error, fmt: *const core::ffi::c_char, ...);
    pub fn error_setg_file_open_internal(
        errp: *mut *mut Error,
        src: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        os_errno: core::ffi::c_int,
        filename: *const core::ffi::c_char,
    );
    pub fn error_copy(err: *const Error) -> *mut Error;
    pub fn error_free(err: *mut Error);
    pub fn error_free_or_abort(errp: *mut *mut Error);
    pub fn warn_report_err(err: *mut Error);
    pub fn error_report_err(err: *mut Error);
    pub fn warn_reportf_err(err: *mut Error, fmt: *const core::ffi::c_char, ...);
    pub fn error_reportf_err(err: *mut Error, fmt: *const core::ffi::c_char, ...);
    pub fn error_set_internal(
        errp: *mut *mut Error,
        src: *const core::ffi::c_char,
        line: core::ffi::c_int,
        func: *const core::ffi::c_char,
        err_class: ErrorClass,
        fmt: *const core::ffi::c_char,
        ...
    );
    pub static mut error_warn: *mut Error;
    pub static mut error_abort: *mut Error;
    pub static mut error_fatal: *mut Error;
    pub static vmstate_info_bool: VMStateInfo;
    pub static vmstate_info_int8: VMStateInfo;
    pub static vmstate_info_int16: VMStateInfo;
    pub static vmstate_info_int32: VMStateInfo;
    pub static vmstate_info_int64: VMStateInfo;
    pub static vmstate_info_uint8_equal: VMStateInfo;
    pub static vmstate_info_uint16_equal: VMStateInfo;
    pub static vmstate_info_int32_equal: VMStateInfo;
    pub static vmstate_info_uint32_equal: VMStateInfo;
    pub static vmstate_info_uint64_equal: VMStateInfo;
    pub static vmstate_info_int32_le: VMStateInfo;
    pub static vmstate_info_uint8: VMStateInfo;
    pub static vmstate_info_uint16: VMStateInfo;
    pub static vmstate_info_uint32: VMStateInfo;
    pub static vmstate_info_uint64: VMStateInfo;
    pub static vmstate_info_nullptr: VMStateInfo;
    pub static vmstate_info_cpudouble: VMStateInfo;
    pub static vmstate_info_timer: VMStateInfo;
    pub static vmstate_info_buffer: VMStateInfo;
    pub static vmstate_info_unused_buffer: VMStateInfo;
    pub static vmstate_info_tmp: VMStateInfo;
    pub static vmstate_info_bitmap: VMStateInfo;
    pub static vmstate_info_qtailq: VMStateInfo;
    pub static vmstate_info_gtree: VMStateInfo;
    pub static vmstate_info_qlist: VMStateInfo;
    pub fn vmstate_load_state(
        f: *mut QEMUFile,
        vmsd: *const VMStateDescription,
        opaque: *mut core::ffi::c_void,
        version_id: core::ffi::c_int,
    ) -> core::ffi::c_int;
    pub fn vmstate_save_state(
        f: *mut QEMUFile,
        vmsd: *const VMStateDescription,
        opaque: *mut core::ffi::c_void,
        vmdesc: *mut JSONWriter,
    ) -> core::ffi::c_int;
    pub fn vmstate_save_state_with_err(
        f: *mut QEMUFile,
        vmsd: *const VMStateDescription,
        opaque: *mut core::ffi::c_void,
        vmdesc: *mut JSONWriter,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn vmstate_save_state_v(
        f: *mut QEMUFile,
        vmsd: *const VMStateDescription,
        opaque: *mut core::ffi::c_void,
        vmdesc: *mut JSONWriter,
        version_id: core::ffi::c_int,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn vmstate_section_needed(
        vmsd: *const VMStateDescription,
        opaque: *mut core::ffi::c_void,
    ) -> bool;
    pub fn vmstate_register_with_alias_id(
        obj: *mut VMStateIf,
        instance_id: u32,
        vmsd: *const VMStateDescription,
        base: *mut core::ffi::c_void,
        alias_id: core::ffi::c_int,
        required_for_version: core::ffi::c_int,
        errp: *mut *mut Error,
    ) -> core::ffi::c_int;
    pub fn vmstate_replace_hack_for_ppc(
        obj: *mut VMStateIf,
        instance_id: core::ffi::c_int,
        vmsd: *const VMStateDescription,
        opaque: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
    pub fn vmstate_unregister(
        obj: *mut VMStateIf,
        vmsd: *const VMStateDescription,
        opaque: *mut core::ffi::c_void,
    );
    pub fn vmstate_register_ram(memory: *mut MemoryRegion, dev: *mut DeviceState);
    pub fn vmstate_unregister_ram(memory: *mut MemoryRegion, dev: *mut DeviceState);
    pub fn vmstate_register_ram_global(memory: *mut MemoryRegion);
    pub fn vmstate_check_only_migratable(vmsd: *const VMStateDescription) -> bool;
}
