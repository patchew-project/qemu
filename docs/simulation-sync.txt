= Synchronizing the virtual clock with an external source =

QEMU has a protocol for synchronizing its virtual clock
with the clock of a simulator in which QEMU is embedded
as a component. This options is enabled with the -qqq
argument, and it should generally be accompanied by the
following additional command line arguments:

-icount 1,sleep=off -rtc clock=vm

The -qqq argument is used to supply file descriptors
for two Unix pipes. The read pipe is used by QEMU to
receive synchronization data from the external simulator.
The write pipe is used by QEMU to supply synchronization
data to the external emulator. The typical procedure for
launching QEMU in is synchronization mode has three steps:

(1) Create two pairs of pipes with the Linux pipe function.
    The code segment that does this might look like

       int pipefd1[2];
       int pipefd2[2];
       pipe(pipefd1);
       pipe(pipefd2);

(2) Fork QEMU with the appropriate command line arguments.
    The -qqq part of the argument will look something like

       -qqq write=pipefd1[1],read=pipefd2[0]

(3) After forking QEMU, close pipefd1[1] and pipefd2[0].
    Retain the other pair of pipes for communicating with QEMU.

The synchronization protocol is very simple. To start, the
external simulator writes an integer to its write pipe with
the amount of time in microseconds that QEMU is allowed to
advance. The code segment that does this might look like:

    int ta = 1000; // Advance by 1 millisecond
    write(pipefd2[1],&ta,sizeof(int));

The external simulator can then advance its clock by this
same amount. During this time, QEMU and the external simulator
will be executing in parallel. When the external simulator
completes its time advance, it waits for QEMU by reading from
its read pipe. The value read will be the actual number of
virtual microseconds by which QEMU has advanced its virtual clock.
This will be greater than or equal to the requested advance.
The code that does this might look like:

   read(pipefd1[0],&ta,sizeof(int));

These steps are repeated until either (1) the external simulator
closes its pipes thereby causing QEMU to terminate or (2) QEMU
stops executing (e.g., if the emulated computer is shutdown) and
causes SIGPIPE to be generated by the closing of its pipes.

You can find an example of a simulator using this protocol in
the adevs simulation package at http://sourceforge.net/projects/adevs/
