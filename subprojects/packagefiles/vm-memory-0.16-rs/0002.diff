From 2af7ea12a589fde619690e5060c01710cb6f2e0e Mon Sep 17 00:00:00 2001
From: Zhao Liu <zhao1.liu@intel.com>
Date: Wed, 6 Aug 2025 14:27:14 +0800
Subject: [PATCH 2/2] guest_memory: Add is_write argument for
 GuestMemory::try_access()

QEMU needs to know whether the memory access is for write or not, e.g.,
memory region may be read-only, or iommu needs to distinguish write
access.

The alternative option is to move try_access() into Bytes trait, and
implement Bytes<(GuestAddress, is_write)> for QEMU's GuestMemory
abstraction. However, try_access() seems to lack generality in the
abstraction of Bytes, as only GuestMemory needs it.

Therefore, just add another argument in try_access() to help handle
more complex memory backend.

Signed-off-by: Zhao Liu <zhao1.liu@intel.com>
---
 src/bitmap/mod.rs   | 17 +++++++++++------
 src/guest_memory.rs | 10 ++++++----
 2 files changed, 17 insertions(+), 10 deletions(-)

diff --git a/src/bitmap/mod.rs b/src/bitmap/mod.rs
index cf1555b29350..de4203166304 100644
--- a/src/bitmap/mod.rs
+++ b/src/bitmap/mod.rs
@@ -287,12 +287,17 @@ pub(crate) mod tests {
         // Finally, let's invoke the generic tests for `Bytes`.
         let check_range_closure = |m: &M, start: usize, len: usize, clean: bool| -> bool {
             let mut check_result = true;
-            m.try_access(len, GuestAddress(start as u64), |_, size, reg_addr, reg| {
-                if !check_range(&reg.bitmap(), reg_addr.0 as usize, size, clean) {
-                    check_result = false;
-                }
-                Ok(size)
-            })
+            m.try_access(
+                len,
+                GuestAddress(start as u64),
+                false,
+                |_, size, reg_addr, reg| {
+                    if !check_range(&reg.bitmap(), reg_addr.0 as usize, size, clean) {
+                        check_result = false;
+                    }
+                    Ok(size)
+                },
+            )
             .unwrap();
 
             check_result
diff --git a/src/guest_memory.rs b/src/guest_memory.rs
index 5b78038c3c92..53981c4e8e94 100644
--- a/src/guest_memory.rs
+++ b/src/guest_memory.rs
@@ -353,7 +353,7 @@ pub trait GuestMemory {
 
     /// Check whether the range [base, base + len) is valid.
     fn check_range(&self, base: GuestAddress, len: usize) -> bool {
-        match self.try_access(len, base, |_, count, _, _| -> Result<usize> { Ok(count) }) {
+        match self.try_access(len, base, false, |_, count, _, _| -> Result<usize> { Ok(count) }) {
             Ok(count) => count == len,
             _ => false,
         }
@@ -374,7 +374,7 @@ pub trait GuestMemory {
     /// - the error code returned by the callback 'f'
     /// - the size of the already handled data when encountering the first hole
     /// - the size of the already handled data when the whole range has been handled
-    fn try_access<F>(&self, count: usize, addr: GuestAddress, mut f: F) -> Result<usize>
+    fn try_access<F>(&self, count: usize, addr: GuestAddress, _is_write: bool, mut f: F) -> Result<usize>
     where
         F: FnMut(usize, usize, MemoryRegionAddress, &Self::R) -> Result<usize>,
     {
@@ -470,6 +470,7 @@ impl<M: GuestMemoryBytes + ?Sized> Bytes<GuestAddress> for M {
         self.try_access(
             buf.len(),
             addr,
+            true,
             |offset, _count, caddr, region| -> Result<usize> {
                 region.write(&buf[offset..], caddr)
             },
@@ -480,6 +481,7 @@ impl<M: GuestMemoryBytes + ?Sized> Bytes<GuestAddress> for M {
         self.try_access(
             buf.len(),
             addr,
+            false,
             |offset, _count, caddr, region| -> Result<usize> {
                 region.read(&mut buf[offset..], caddr)
             },
@@ -547,7 +549,7 @@ impl<M: GuestMemoryBytes + ?Sized> Bytes<GuestAddress> for M {
     where
         F: ReadVolatile,
     {
-        self.try_access(count, addr, |_, len, caddr, region| -> Result<usize> {
+        self.try_access(count, addr, false, |_, len, caddr, region| -> Result<usize> {
             region.read_volatile_from(caddr, src, len)
         })
     }
@@ -575,7 +577,7 @@ impl<M: GuestMemoryBytes + ?Sized> Bytes<GuestAddress> for M {
     where
         F: WriteVolatile,
     {
-        self.try_access(count, addr, |_, len, caddr, region| -> Result<usize> {
+        self.try_access(count, addr, true, |_, len, caddr, region| -> Result<usize> {
             // For a non-RAM region, reading could have side effects, so we
             // must use write_all().
             region.write_all_volatile_to(caddr, dst, len).map(|()| len)
-- 
2.34.1

