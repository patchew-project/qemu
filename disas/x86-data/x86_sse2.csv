"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
"ADDPD xmm1, xmm2/m128","LEX.66.0F.W0 58 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed double-precision floating-point values from xmm2/mem to xmm1 and store result in xmm1."
"ADDSD xmm1, xmm2/m64","LEX.F2.0F.W0 58 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add the low double-precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1."
"ANDNPD xmm1, xmm2/m128","LEX.66.0F.W0 55 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm1 and xmm2/mem."
"ANDPD xmm1, xmm2/m128","LEX.66.0F.W0 54 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/mem."
"CMPPD xmm1, xmm2/m128, ib","LEX.66.0F.W0 C2 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Compare packed double-precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of ib as a comparison predicate."
"CMPSD xmm1, xmm2/m64, ib","LEX.F2.0F.W0 C2 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Compare low double-precision floating-point value in xmm2/m64 and xmm1 using bits 2:0 of ib as comparison predicate."
"COMISD xmm1, xmm2/m64","LEX.66.0F.W0 2F /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
"CVTDQ2PD xmm1, xmm2/m64","LEX.F3.0F.W0 E6 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1."
"CVTDQ2PS xmm1, xmm2/m128","LEX.0F.W0 5B /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed signed doubleword integers from xmm2/mem to four packed single-precision floating-point values in xmm1."
"CVTPD2DQ xmm1, xmm2/m128","LEX.F2.0F.W0 E6 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1."
"CVTPD2PS xmm1, xmm2/m128","LEX.66.0F.W0 5A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed double-precision floating-point values in xmm2/mem to two single-precision floating-point values in xmm1."
"CVTPS2DQ xmm1, xmm2/m128","LEX.66.0F.W0 5B /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1."
"CVTPS2PD xmm1, xmm2/m64","LEX.0F.W0 5A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed single-precision floating-point values in xmm2/m64 to two packed double-precision floating-point values in xmm1."
"CVTSD2SI rw, xmm1/m64","LEX.F2.0F.W0 2D /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r."
"CVTSD2SI rw, xmm1/m64","LEX.F2.0F.W1 2D /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer signextended into r."
"CVTSD2SS xmm1, xmm2/m64","LEX.F2.0F.W0 5A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1."
"CVTSI2SD xmm1, rw/mw","LEX.F2.0F.W0 2A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one signed doubleword integer from r/m to one double-precision floating-point value in xmm1."
"CVTSI2SD xmm1, rw/mw","LEX.F2.0F.W1 2A /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one signed quadword integer from r/m to one double-precision floating-point value in xmm1."
"CVTSI2SS xmm1, rw/mw","LEX.F3.0F.W0 2A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one signed doubleword integer from r/m to one single-precision floating-point value in xmm1."
"CVTSI2SS xmm1, rw/mw","LEX.F3.0F.W1 2A /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one signed quadword integer from r/m to one single-precision floating-point value in xmm1."
"CVTSS2SD xmm1, xmm2/m32","LEX.F3.0F.W0 5A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1."
"CVTSS2SI rw, xmm1/m32","LEX.F3.0F.W0 2D /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r."
"CVTSS2SI rw, xmm1/m32","LEX.F3.0F.W1 2D /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r."
"CVTTPD2DQ xmm1, xmm2/m128","LEX.66.0F.W0 E6 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation."
"CVTTPS2DQ xmm1, xmm2/m128","LEX.F3.0F.W0 5B /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation."
"CVTTSD2SI rw, xmm1/m64","LEX.F2.0F.W0 2C /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r using truncation."
"CVTTSD2SI rw, xmm1/m64","LEX.F2.0F.W1 2C /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r using truncation."
"CVTTSS2SI rw, xmm1/m32","LEX.F3.0F.W0 2C /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r using truncation."
"CVTTSS2SI rw, xmm1/m32","LEX.F3.0F.W1 2C /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r using truncation."
"DIVPD xmm1, xmm2/m128","LEX.66.0F.W0 5E /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values in xmm2/mem."
"DIVSD xmm1, xmm2/m64","LEX.F2.0F.W0 5E /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/m64."
"MASKMOVDQU xmm1, xmm2","LEX.66.0F.W0 F7 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r)","ModRM:r/m (r)","RDI (r)","","","Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI."
"MAXPD xmm1, xmm2/m128","LEX.66.0F.W0 5F /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the maximum double-precision floating-point values between xmm1 and xmm2/m128."
"MAXSD xmm1, xmm2/m64","LEX.F2.0F.W0 5F /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the maximum scalar double-precision floating-point value between xmm2/m64 and xmm1."
"MINPD xmm1, xmm2/m128","LEX.66.0F.W0 5D /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the minimum double-precision floating-point values between xmm1 and xmm2/mem"
"MINSD xmm1, xmm2/m64","LEX.F2.0F.W0 5D /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the minimum scalar double-precision floating-point value between xmm2/m64 and xmm1."
"MOVAPD xmm1, xmm2/m128","LEX.66.0F.W0 28 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed double-precision floating-point values from xmm2/mem to xmm1."
"MOVAPD xmm2/m128, xmm1","LEX.66.0F.W0 29 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem."
"MOVD xmm, rw/mw","LEX.66.0F.W0 6E /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move doubleword from r/m to xmm."
"MOVD rw/mw, xmm","LEX.66.0F.W0 7E /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move doubleword from xmm register to r/m."
"MOVDQA xmm1, xmm2/m128","LEX.66.0F.W0 6F /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed integer values from xmm2/mem to xmm1."
"MOVDQA xmm2/m128, xmm1","LEX.66.0F.W0 7F /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed integer values from xmm1 to xmm2/mem."
"MOVDQU xmm1, xmm2/m128","LEX.F3.0F.W0 6F /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed integer values from xmm2/m128 to xmm1."
"MOVDQU xmm2/m128, xmm1","LEX.F3.0F.W0 7F /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (r)","ModRM:reg (w)","","","","Move unaligned packed integer values from xmm1 to xmm2/m128."
"MOVHPD xmm1, m64","LEX.66.0F.W0 16 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move double-precision floating-point value from m64 to high quadword of xmm1."
"MOVHPD m64, xmm1","LEX.66.0F.W0 17 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move double-precision floating-point value from high quadword of xmm1 to m64."
"MOVLPD xmm1, m64","LEX.66.0F.W0 12 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move double-precision floating-point value from m64 to low quadword of xmm1."
"MOVLPD m64, xmm1","LEX.66.0F.W0 13 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move double-precision floating-point value from low quadword of xmm1 to m64."
"MOVMSKPD rw, xmm","LEX.66.0F.W0 50 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Extract 2-bit sign mask from xmm and store in reg. The upper bits of r are zeroed."
"MOVNTDQ m128, xmm1","LEX.66.0F.W0 E7 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed integer values in xmm1 to m128 using non-temporal hint."
"MOVNTPD m128, xmm1","LEX.66.0F.W0 2B /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed double-precision values in xmm1 to m128 using non-temporal hint."
"MOVQ xmm, rw/mw","LEX.66.0F.W1 6E /r","Valid","Invalid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move quadword from r/m to xmm."
"MOVQ rw/mw, xmm","LEX.66.0F.W1 7E /r","Valid","Invalid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from xmm register to r/m."
"MOVQ xmm1, xmm2/m64","LEX.F3.0F.W0 7E /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move quadword from xmm2/mem64 to xmm1."
"MOVQ xmm2/m64, xmm1","LEX.66.0F.W0 D6 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from xmm1 to xmm2/mem64."
"MOVSD xmm1, m64","LEX.F2.0F.W0 10 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Load scalar double-precision floating-point value from m64 to xmm1 register."
"MOVSD xmm1, xmm2","LEX.F2.0F.W0 10 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move scalar double-precision floating-point value from xmm2 to xmm1 register."
"MOVSD xmm1/m64, xmm2","LEX.F2.0F.W0 11 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move scalar double-precision floating-point value from xmm2 register to xmm1/m64."
"MOVUPD xmm1, xmm2/m128","LEX.66.0F.W0 10 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed double-precision floating-point from xmm2/mem to xmm1."
"MOVUPD xmm2/m128, xmm1","LEX.66.0F.W0 11 /r","Valid","Valid","Invalid","SSE2","ModRM:r/m (w)","ModRM:reg (r)","","","","Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem."
"MULPD xmm1, xmm2/m128","LEX.66.0F.W0 59 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply packed double-precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1."
"MULSD xmm1, xmm2/m64","LEX.F2.0F.W0 59 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the low double-precision floating-point value in xmm2/m64 by low double-precision floating-point value in xmm1."
"ORPD xmm1, xmm2/m128","LEX.66.0F.W0 56 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical OR of packed double-precision floating-point values in xmm1 and xmm2/mem."
"PACKSSDW xmm1, xmm2/m128","LEX.66.0F.W0 6B /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation."
"PACKSSWB xmm1, xmm2/m128","LEX.66.0F.W0 63 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation."
"PACKUSWB xmm1, xmm2/m128","LEX.66.0F.W0 67 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation."
"PADDB xmm1, xmm2/m128","LEX.66.0F.W0 FC /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed byte integers from xmm2/m128 and xmm1."
"PADDD xmm1, xmm2/m128","LEX.66.0F.W0 FE /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed doubleword integers from xmm2/m128 and xmm1."
"PADDQ xmm1, xmm2/m128","LEX.66.0F.W0 D4 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed quadword integers from xmm2/m128 and xmm1."
"PADDSB xmm1, xmm2/m128","LEX.66.0F.W0 EC /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results."
"PADDSW xmm1, xmm2/m128","LEX.66.0F.W0 ED /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results."
"PADDUSB xmm1, xmm2/m128","LEX.66.0F.W0 DC /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results."
"PADDUSW xmm1, xmm2/m128","LEX.66.0F.W0 DD /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results."
"PADDW xmm1, xmm2/m128","LEX.66.0F.W0 FD /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed word integers from xmm2/m128 and xmm1."
"PAND xmm1, xmm2/m128","LEX.66.0F.W0 DB /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise AND of xmm2/m128 and xmm1."
"PANDN xmm1, xmm2/m128","LEX.66.0F.W0 DF /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise AND NOT of xmm2/m128 and xmm1."
"PAVGB xmm1, xmm2/m128","LEX.66.0F.W0 E0 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding."
"PAVGW xmm1, xmm2/m128","LEX.66.0F.W0 E3 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding."
"PCMPEQB xmm1, xmm2/m128","LEX.66.0F.W0 74 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed bytes in xmm2/m128 and xmm1 for equality."
"PCMPEQD xmm1, xmm2/m128","LEX.66.0F.W0 76 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed doublewords in xmm2/m128 and xmm1 for equality."
"PCMPEQW xmm1, xmm2/m128","LEX.66.0F.W0 75 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed words in xmm2/m128 and xmm1 for equality."
"PCMPGTB xmm1, xmm2/m128","LEX.66.0F.W0 64 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than."
"PCMPGTD xmm1, xmm2/m128","LEX.66.0F.W0 66 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than."
"PCMPGTW xmm1, xmm2/m128","LEX.66.0F.W0 65 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed word integers in xmm1 and xmm2/m128 for greater than."
"PEXTRW r32, xmm, ib","LEX.66.0F.W0 C5 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Extract the word specified by ib from xmm and move it to reg, bits 15-0. The upper bits of r are zeroed."
"PINSRW xmm, r32/m16, ib","LEX.66.0F.W0 C4 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Move the low word of r32 or from m16 into xmm at the word position specified by ib."
"PMADDWD xmm1, xmm2/m128","LEX.66.0F.W0 F5 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1."
"PMAXSW xmm1, xmm2/m128","LEX.66.0F.W0 EE /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed word integers in xmm2/m128 and xmm1 and stores maximum packed values in xmm1."
"PMAXUB xmm1, xmm2/m128","LEX.66.0F.W0 DE /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
"PMINSW xmm1, xmm2/m128","LEX.66.0F.W0 EA /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed word integers in xmm2/m128 and xmm1 and store packed minimum values in xmm1."
"PMINUB xmm1, xmm2/m128","LEX.66.0F.W0 DA /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
"PMOVMSKB r32, xmm","LEX.66.0F.W0 D7 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Move a byte mask of xmm to reg. The upper bits of r are zeroed"
"PMULHUW xmm1, xmm2/m128","LEX.66.0F.W0 E4 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."
"PMULHW xmm1, xmm2/m128","LEX.66.0F.W0 E5 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."
"PMULLW xmm1, xmm2/m128","LEX.66.0F.W0 D5 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1."
"PMULUDQ mm1, mm2/m64","LEX.0F.W0 F4 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1."
"PMULUDQ xmm1, xmm2/m128","LEX.66.0F.W0 F4 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1."
"POR xmm1, xmm2/m128","LEX.66.0F.W0 EB /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise OR of xmm2/m128 and xmm1."
"PSADBW xmm1, xmm2/m128","LEX.66.0F.W0 F6 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Computes the absolute differences of the packed unsigned byte integers from xmm2/m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results."
"PSHUFD xmm1, xmm2/m128, ib","LEX.66.0F.W0 70 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the doublewords in xmm2/m128 based on the encoding in ib and store the result in xmm1."
"PSHUFHW xmm1, xmm2/m128, ib","LEX.F3.0F.W0 70 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the high words in xmm2/m128 based on the encoding in ib and store the result in xmm1."
"PSHUFLW xmm1, xmm2/m128, ib","LEX.F2.0F.W0 70 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the low words in xmm2/m128 based on the encoding in ib and store the result in xmm1."
"PSLLD xmm1, ib","LEX.66.0F.W0 72 /6 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift doublewords in xmm1 left by ib while shifting in 0s."
"PSLLD xmm1, xmm2/m128","LEX.66.0F.W0 F2 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s."
"PSLLDQ xmm1, ib","LEX.66.0F.W0 73 /7 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift xmm1 left by ib bytes while shifting in 0s."
"PSLLQ xmm1, ib","LEX.66.0F.W0 73 /6 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift quadwords in xmm1 left by ib while shifting in 0s."
"PSLLQ xmm1, xmm2/m128","LEX.66.0F.W0 F3 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s."
"PSLLW xmm1, ib","LEX.66.0F.W0 71 /6 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift words in xmm1 left by ib while shifting in 0s."
"PSLLW xmm1, xmm2/m128","LEX.66.0F.W0 F1 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift words in xmm1 left by xmm2/m128 while shifting in 0s."
"PSRAD xmm1, ib","LEX.66.0F.W0 72 /4 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift doublewords in xmm1 right by ib while shifting in sign bits."
"PSRAD xmm1, xmm2/m128","LEX.66.0F.W0 E2 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits."
"PSRAW xmm1, ib","LEX.66.0F.W0 71 /4 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift words in xmm1 right by ib while shifting in sign bits"
"PSRAW xmm1, xmm2/m128","LEX.66.0F.W0 E1 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift words in xmm1 right by xmm2/m128 while shifting in sign bits."
"PSRLD xmm1, ib","LEX.66.0F.W0 72 /2 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift doublewords in xmm1 right by ib while shifting in 0s."
"PSRLD xmm1, xmm2/m128","LEX.66.0F.W0 D2 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift doublewords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
"PSRLDQ xmm1, ib","LEX.66.0F.W0 73 /3 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift xmm1 right by ib while shifting in 0s."
"PSRLQ xmm1, ib","LEX.66.0F.W0 73 /2 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift quadwords in xmm1 right by ib while shifting in 0s."
"PSRLQ xmm1, xmm2/m128","LEX.66.0F.W0 D3 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
"PSRLW xmm1, ib","LEX.66.0F.W0 71 /2 ib","Valid","Valid","Invalid","SSE2","ModRM:r/m (r, w)","ib","","","","Shift words in xmm1 right by ib while shifting in 0s."
"PSRLW xmm1, xmm2/m128","LEX.66.0F.W0 D1 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
"PSUBB xmm1, xmm2/m128","LEX.66.0F.W0 F8 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1."
"PSUBD xmm1, xmm2/m128","LEX.66.0F.W0 FA /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1."
"PSUBQ mm1, mm2/m64","LEX.0F.W0 FB /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract quadword integer in mm1 from mm2 /m64."
"PSUBQ xmm1, xmm2/m128","LEX.66.0F.W0 FB /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed quadword integers in xmm1 from xmm2/m128."
"PSUBSB xmm1, xmm2/m128","LEX.66.0F.W0 E8 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results."
"PSUBSW xmm1, xmm2/m128","LEX.66.0F.W0 E9 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results."
"PSUBUSB xmm1, xmm2/m128","LEX.66.0F.W0 D8 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result."
"PSUBUSW xmm1, xmm2/m128","LEX.66.0F.W0 D9 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result."
"PSUBW xmm1, xmm2/m128","LEX.66.0F.W0 F9 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed word integers in xmm2/m128 from packed word integers in xmm1."
"PUNPCKHBW xmm1, xmm2/m128","LEX.66.0F.W0 68 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1."
"PUNPCKHDQ xmm1, xmm2/m128","LEX.66.0F.W0 6A /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1."
"PUNPCKHQDQ xmm1, xmm2/m128","LEX.66.0F.W0 6D /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1."
"PUNPCKHWD xmm1, xmm2/m128","LEX.66.0F.W0 69 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1."
"PUNPCKLBW xmm1, xmm2/m128","LEX.66.0F.W0 60 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1."
"PUNPCKLDQ xmm1, xmm2/m128","LEX.66.0F.W0 62 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1."
"PUNPCKLQDQ xmm1, xmm2/m128","LEX.66.0F.W0 6C /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register."
"PUNPCKLWD xmm1, xmm2/m128","LEX.66.0F.W0 61 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Interleave low-order words from xmm1 and xmm2/m128 into xmm1."
"PXOR xmm1, xmm2/m128","LEX.66.0F.W0 EF /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Bitwise XOR of xmm2/m128 and xmm1."
"SHUFPD xmm1, xmm2/m128, ib","LEX.66.0F.W0 C6 /r ib","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Shuffle two pairs of double-precision floating-point values from xmm1 and xmm2/m128 using ib to select from each pair, interleaved result is stored in xmm1."
"SQRTPD xmm1, xmm2/m128","LEX.66.0F.W0 51 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes Square Roots of the packed double-precision floating-point values in xmm2/m128 and stores the result in xmm1."
"SQRTSD xmm1, xmm2/m64","LEX.F2.0F.W0 51 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes square root of the low double-precision floating-point value in xmm2/m64 and stores the results in xmm1."
"SUBPD xmm1, xmm2/m128","LEX.66.0F.W0 5C /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed double-precision floating-point values in xmm2/mem from xmm1 and store result in xmm1."
"SUBSD xmm1, xmm2/m64","LEX.F2.0F.W0 5C /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract the low double-precision floating-point value in xmm2/m64 from xmm1 and store the result in xmm1."
"UCOMISD xmm1, xmm2/m64","LEX.66.0F.W0 2E /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
"UNPCKHPD xmm1, xmm2/m128","LEX.66.0F.W0 15 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128."
"UNPCKLPD xmm1, xmm2/m128","LEX.66.0F.W0 14 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128."
"XORPD xmm1, xmm2/m128","LEX.66.0F.W0 57 /r","Valid","Valid","Invalid","SSE2","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical XOR of packed double-precision floating-point values in xmm1 and xmm2/mem."
