"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
"ADDPS xmm1, xmm2/m128","LEX.0F.W0 58 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add packed single-precision floating-point values from xmm2/m128 to xmm1 and store result in xmm1."
"ADDSS xmm1, xmm2/m32","LEX.F3.0F.W0 58 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add the low single-precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1."
"ANDNPS xmm1, xmm2/m128","LEX.0F.W0 55 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm1 and xmm2/mem."
"ANDPS xmm1, xmm2/m128","LEX.0F.W0 54 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical AND of packed single-precision floating-point values in xmm1 and xmm2/mem."
"CMPPS xmm1, xmm2/m128, ib","LEX.0F.W0 C2 /r ib","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Compare packed single-precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of ib as a comparison predicate."
"CMPSS xmm1, xmm2/m32, ib","LEX.F3.0F.W0 C2 /r ib","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Compare low single-precision floating-point value in xmm2/m32 and xmm1 using bits 2:0 of ib as comparison predicate."
"COMISS xmm1, xmm2/m32","LEX.0F.W0 2F /r","Valid","Valid","Invalid","SSE","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
"DIVPS xmm1, xmm2/m128","LEX.0F.W0 5E /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values in xmm2/mem."
"DIVSS xmm1, xmm2/m32","LEX.F3.0F.W0 5E /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32."
"LDMXCSR m32","LEX.0F.W0 AE /2","Valid","Valid","Invalid","SSE","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Load MXCSR register from m32."
"MAXPS xmm1, xmm2/m128","LEX.0F.W0 5F /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the maximum single-precision floating-point values between xmm1 and xmm2/mem."
"MAXSS xmm1, xmm2/m32","LEX.F3.0F.W0 5F /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the maximum scalar single-precision floating-point value between xmm2/m32 and xmm1."
"MINPS xmm1, xmm2/m128","LEX.0F.W0 5D /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the minimum single-precision floating-point values between xmm1 and xmm2/mem."
"MINSS xmm1, xmm2/m32","LEX.F3.0F.W0 5D /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the minimum scalar single-precision floating-point value between xmm2/m32 and xmm1."
"MOVAPS xmm1, xmm2/m128","LEX.0F.W0 28 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Move aligned packed single-precision floating-point values from xmm2/mem to xmm1."
"MOVAPS xmm2/m128, xmm1","LEX.0F.W0 29 /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem."
"MOVHLPS xmm1, xmm2","LEX.0F.W0 12 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1."
"MOVHPS xmm1, m64","LEX.0F.W0 16 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move two packed single-precision floating-point values from m64 to high quadword of xmm1."
"MOVHPS m64, xmm1","LEX.0F.W0 17 /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
"MOVLHPS xmm1, xmm2","LEX.0F.W0 16 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1."
"MOVLPS xmm1, m64","LEX.0F.W0 12 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move two packed single-precision floating-point values from m64 to low quadword of xmm1."
"MOVLPS m64, xmm1","LEX.0F.W0 13 /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
"MOVMSKPS rw, xmm","LEX.0F.W0 50 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Extract 4-bit sign mask from xmm and store in reg. The upper bits of r are are zeroed."
"MOVNTPS m128, xmm1","LEX.0F.W0 2B /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move packed single-precision values xmm1 to mem using non-temporal hint."
"MOVSS xmm1, m32","LEX.F3.0F.W0 10 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Load scalar single-precision floating-point value from m32 to xmm1 register."
"MOVSS xmm1, xmm2","LEX.F3.0F.W0 10 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Merge scalar single-precision floating-point value from xmm2 to xmm1 register."
"MOVSS xmm2/m32, xmm1","LEX.F3.0F.W0 11 /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move scalar single-precision floating-point value from xmm1 register to xmm2/m32."
"MOVUPS xmm1, xmm2/m128","LEX.0F.W0 10 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Move unaligned packed single-precision floating-point from xmm2/mem to xmm1."
"MOVUPS xmm2/m128, xmm1","LEX.0F.W0 11 /r","Valid","Valid","Invalid","SSE","ModRM:r/m (w)","ModRM:reg (r)","","","","Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem."
"MULPS xmm1, xmm2/m128","LEX.0F.W0 59 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply packed single-precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1."
"MULSS xmm1, xmm2/m32","LEX.F3.0F.W0 59 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the low single-precision floating-point value in xmm2/m32 by the low single-precision floating-point value in xmm1."
"ORPS xmm1, xmm2/m128","LEX.0F.W0 56 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical OR of packed single-precision floating-point values in xmm1 and xmm2/mem."
"PAVGB mm1, mm2/m64","LEX.0F.W0 E0 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Average packed unsigned byte integers from mm2/m64 and mm1 with rounding."
"PAVGW mm1, mm2/m64","LEX.0F.W0 E3 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Average packed unsigned word integers from mm2/m64 and mm1 with rounding."
"PEXTRW r32, mm, ib","LEX.0F.W0 C5 /r ib","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Extract the word specified by ib from mm and move it to reg, bits 15-0. The upper bits of r are zeroed."
"PINSRW mm, r32/m16, ib","LEX.0F.W0 C4 /r ib","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Insert the low word from r32 or from m16 into mm at the word position specified by ib."
"PMAXSW mm1, mm2/m64","LEX.0F.W0 EE /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare signed word integers in mm2/m64 and mm1 and return maximum values."
"PMAXUB mm1, mm2/m64","LEX.0F.W0 DE /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values."
"PMINSW mm1, mm2/m64","LEX.0F.W0 EA /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare signed word integers in mm2/m64 and mm1 and return minimum values."
"PMINUB mm1, mm2/m64","LEX.0F.W0 DA /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values."
"PMOVMSKB r32, mm","LEX.0F.W0 D7 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Move a byte mask of mm to reg. The upper bits of r are zeroed"
"PMULHUW mm1, mm2/m64","LEX.0F.W0 E4 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1."
"PSADBW mm1, mm2/m64","LEX.0F.W0 F6 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result."
"RCPPS xmm1, xmm2/m128","LEX.0F.W0 53 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1."
"RCPSS xmm1, xmm2/m32","LEX.F3.0F.W0 53 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm2/m32 and stores the result in xmm1."
"RSQRTPS xmm1, xmm2/m128","LEX.0F.W0 52 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocals of the square roots of the packed single-precision floating-point values in xmm2/m128 and stores the results in xmm1."
"RSQRTSS xmm1, xmm2/m32","LEX.F3.0F.W0 52 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes the approximate reciprocal of the square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1."
"SHUFPS xmm1, xmm3/m128, ib","LEX.0F.W0 C6 /r ib","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Select from quadruplet of single-precision floating-point values in xmm1 and xmm2/m128 using ib, interleaved result pairs are stored in xmm1."
"SQRTPS xmm1, xmm2/m128","LEX.0F.W0 51 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes Square Roots of the packed single-precision floating-point values in xmm2/m128 and stores the result in xmm1."
"SQRTSS xmm1, xmm2/m32","LEX.F3.0F.W0 51 /r","Valid","Valid","Invalid","SSE","ModRM:reg (w)","ModRM:r/m (r)","","","","Computes square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1."
"STMXCSR m32","LEX.0F.W0 AE /3","Valid","Valid","Invalid","SSE","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","","","","","Store contents of MXCSR register to m32."
"SUBPS xmm1, xmm2/m128","LEX.0F.W0 5C /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract packed single-precision floating-point values in xmm2/mem from xmm1 and store result in xmm1."
"SUBSS xmm1, xmm2/m32","LEX.F3.0F.W0 5C /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract the low single-precision floating-point value in xmm2/m32 from xmm1 and store the result in xmm1."
"UCOMISS xmm1, xmm2/m32","LEX.0F.W0 2E /r","Valid","Valid","Invalid","SSE","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
"UNPCKHPS xmm1, xmm2/m128","LEX.0F.W0 15 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/m128."
"UNPCKLPS xmm1, xmm2/m128","LEX.0F.W0 14 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/m128."
"XORPS xmm1, xmm2/m128","LEX.0F.W0 57 /r","Valid","Valid","Invalid","SSE","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Return the bitwise logical XOR of packed single-precision floating-point values in xmm1 and xmm2/mem."
