"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
"F2XM1","LEX.WN D9 F0","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with (2 ^ (ST(0)-1))."
"FABS","LEX.WN D9 E1","Valid","Valid","Valid","X87","","","","","","Replace ST with its absolute value."
"FADD ST(0), ST(i)","LEX.WN D8 C0+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Add ST(0) to ST(i) and store result in ST(0)."
"FADD m32fp","LEX.WN D8 /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Add m32fp to ST(0) and store result in ST(0)."
"FADD ST(i), ST(0)","LEX.WN DC C0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Add ST(i) to ST(0) and store result in ST(i)."
"FADD m64fp","LEX.WN DC /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Add m64fp to ST(0) and store result in ST(0)."
"FADDP ST(i), ST(0)","LEX.WN DE C0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Add ST(0) to ST(i), store result in ST(i), and pop the register stack."
"FBLD m80dec","LEX.WN DF /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Convert BCD value to floating-point and push onto the FPU stack."
"FBSTP m80bcd","LEX.WN DF /6","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m80bcd and pop ST(0)."
"FCHS","LEX.WN D9 E0","Valid","Valid","Valid","X87","","","","","","Complements sign of ST(0)."
"FCLEX","LEX.9B.WN DB E2","Valid","Valid","Valid","X87","","","","","","Clear floating-point exception flags after checking for pending unmasked floating-point exceptions."
"FCMOVB ST(0), ST(i)","LEX.WN DA C0+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if below (CF=1)."
"FCMOVBE ST(0), ST(i)","LEX.WN DA D0+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if below or equal (CF=1 or ZF=1)."
"FCMOVE ST(0), ST(i)","LEX.WN DA C8+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if equal (ZF=1)."
"FCMOVNB ST(0), ST(i)","LEX.WN DB C0+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if not below (CF=0)."
"FCMOVNBE ST(0), ST(i)","LEX.WN DB D0+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if not below or equal (CF=0 and ZF=0)."
"FCMOVNE ST(0), ST(i)","LEX.WN DB C8+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if not equal (ZF=0)."
"FCMOVNU ST(0), ST(i)","LEX.WN DB D8+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if not unordered (PF=0)."
"FCMOVU ST(0), ST(i)","LEX.WN DA D8+r","Valid","Valid","Valid","X87","ST0 (w)","opcode +r (r)","","","","Move if unordered (PF=1)."
"FCOM ST(i)","LEX.WN D8 D0+r","Valid","Valid","Valid","X87","opcode +r (r)","ST0 (r)","","","","Compare ST(0) with ST(i)."
"FCOM m32fp","LEX.WN D8 /2","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m32fp."
"FCOM m64fp","LEX.WN DC /2","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m64fp."
"FCOMI ST(0), ST(i)","LEX.WN DB F0+r","Valid","Valid","Valid","X87","ST0 (r)","opcode +r (r)","","","","Compare ST(0) with ST(i) and set status flags accordingly."
"FCOMIP ST(0), ST(i)","LEX.WN DF F0+r","Valid","Valid","Valid","X87","ST0 (r)","opcode +r (r)","","","","Compare ST(0) with ST(i), set status flags accordingly, and pop register stack."
"FCOMP ST(i)","LEX.WN D8 D8+r","Valid","Valid","Valid","X87","opcode +r (r)","ST0 (r)","","","","Compare ST(0) with ST(i) and pop register stack."
"FCOMP m32fp","LEX.WN D8 /3","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m32fp and pop register stack."
"FCOMP m64fp","LEX.WN DC /3","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m64fp and pop register stack."
"FCOMPP","LEX.WN DE D9","Valid","Valid","Valid","X87","","","","","","Compare ST(0) with ST(1) and pop register stack twice."
"FCOS","LEX.WN D9 FF","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with its approximate cosine."
"FDECSTP","LEX.WN D9 F6","Valid","Valid","Valid","X87","","","","","","Decrement TOP field in FPU status word."
"FDIV ST(0), ST(i)","LEX.WN D8 F0+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Divide ST(0) by ST(i) and store result in ST(0)."
"FDIV m32fp","LEX.WN D8 /6","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide ST(0) by m32fp and store result in ST(0)."
"FDIV ST(i), ST(0)","LEX.WN DC F8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Divide ST(i) by ST(0) and store result in ST(i)."
"FDIV m64fp","LEX.WN DC /6","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide ST(0) by m64fp and store result in ST(0)."
"FDIVP ST(i), ST(0)","LEX.WN DE F8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Divide ST(i) by ST(0), store result in ST(i), and pop the register stack."
"FDIVR ST(0), ST(i)","LEX.WN D8 F8+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Divide ST(i) by ST(0) and store result in ST(0)."
"FDIVR m32fp","LEX.WN D8 /7","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide m32fp by ST(0) and store result in ST(0)."
"FDIVR ST(i), ST(0)","LEX.WN DC F0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Divide ST(0) by ST(i) and store result in ST(i)."
"FDIVR m64fp","LEX.WN DC /7","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide m64fp by ST(0) and store result in ST(0)."
"FDIVRP ST(i), ST(0)","LEX.WN DE F0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Divide ST(0) by ST(i), store result in ST(i), and pop the register stack."
"FFREE ST(i)","LEX.WN DD C0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","","","","","Sets tag for ST(i) to empty."
"FIADD m32int","LEX.WN DA /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Add m32int to ST(0) and store result in ST(0)."
"FIADD m16int","LEX.WN DE /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Add m16int to ST(0) and store result in ST(0)."
"FICOM m32int","LEX.WN DA /2","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m32int."
"FICOM m16int","LEX.WN DE /2","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m16int."
"FICOMP m32int","LEX.WN DA /3","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m32int and pop stack register."
"FICOMP m16int","LEX.WN DE /3","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Compare ST(0) with m16int and pop stack register."
"FIDIV m32int","LEX.WN DA /6","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide ST(0) by m32int and store result in ST(0)."
"FIDIV m16int","LEX.WN DE /6","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide ST(0) by m16int and store result in ST(0)."
"FIDIVR m32int","LEX.WN DA /7","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide m32int by ST(0) and store result in ST(0)."
"FIDIVR m16int","LEX.WN DE /7","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Divide m16int by ST(0) and store result in ST(0)."
"FILD m32int","LEX.WN DB /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m32int onto the FPU register stack."
"FILD m16int","LEX.WN DF /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m16int onto the FPU register stack."
"FILD m64int","LEX.WN DF /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m64int onto the FPU register stack."
"FIMUL m32int","LEX.WN DA /1","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Multiply ST(0) by m32int and store result in ST(0)."
"FIMUL m16int","LEX.WN DE /1","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Multiply ST(0) by m16int and store result in ST(0)."
"FINCSTP","LEX.WN D9 F7","Valid","Valid","Valid","X87","","","","","","Increment the TOP field in the FPU status register."
"FINIT","LEX.9B.WN DB E3","Valid","Valid","Valid","X87","","","","","","Initialize FPU after checking for pending unmasked floating-point exceptions."
"FIST m32int","LEX.WN DB /2","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m32int."
"FIST m16int","LEX.WN DF /2","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m16int."
"FISTP m32int","LEX.WN DB /3","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m32int and pop register stack."
"FISTP m16int","LEX.WN DF /3","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m16int and pop register stack."
"FISTP m64int","LEX.WN DF /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m64int and pop register stack."
"FISTTP m32int","LEX.WN DB /1","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m32int with truncation."
"FISTTP m64int","LEX.WN DD /1","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m64int with truncation."
"FISTTP m16int","LEX.WN DF /1","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store ST(0) in m16int with truncation."
"FISUB m32int","LEX.WN DA /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract m32int from ST(0) and store result in ST(0)."
"FISUB m16int","LEX.WN DE /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract m16int from ST(0) and store result in ST(0)."
"FISUBR m32int","LEX.WN DA /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract ST(0) from m32int and store result in ST(0)."
"FISUBR m16int","LEX.WN DE /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract ST(0) from m16int and store result in ST(0)."
"FLD ST(i)","LEX.WN D9 C0+r","Valid","Valid","Valid","X87","opcode +r (r)","","","","","Push ST(i) onto the FPU register stack."
"FLD m32fp","LEX.WN D9 /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m32fp onto the FPU register stack."
"FLD m80fp","LEX.WN DB /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m80fp onto the FPU register stack."
"FLD m64fp","LEX.WN DD /0","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Push m64fp onto the FPU register stack."
"FLD1","LEX.WN D9 E8","Valid","Valid","Valid","X87","","","","","","Push +1.0 onto the FPU register stack."
"FLDCW m16","LEX.WN D9 /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Load FPU control word from m2byte."
"FLDENV mem","LEX.WN D9 /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Load FPU environment from m14byte or m28byte."
"FLDL2E","LEX.WN D9 EA","Valid","Valid","Valid","X87","","","","","","Push log 2 e onto the FPU register stack."
"FLDL2T","LEX.WN D9 E9","Valid","Valid","Valid","X87","","","","","","Push log 2 10 onto the FPU register stack."
"FLDLG2","LEX.WN D9 EC","Valid","Valid","Valid","X87","","","","","","Push log 10 2 onto the FPU register stack."
"FLDLN2","LEX.WN D9 ED","Valid","Valid","Valid","X87","","","","","","Push log e 2 onto the FPU register stack."
"FLDPI","LEX.WN D9 EB","Valid","Valid","Valid","X87","","","","","","Push Pi onto the FPU register stack."
"FLDZ","LEX.WN D9 EE","Valid","Valid","Valid","X87","","","","","","Push +0.0 onto the FPU register stack."
"FMUL ST(0), ST(i)","LEX.WN D8 C8+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Multiply ST(0) by ST(i) and store result in ST(0)."
"FMUL m32fp","LEX.WN D8 /1","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Multiply ST(0) by m32fp and store result in ST(0)."
"FMUL ST(i), ST(0)","LEX.WN DC C8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Multiply ST(i) by ST(0) and store result in ST(i)."
"FMUL m64fp","LEX.WN DC /1","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Multiply ST(0) by m64fp and store result in ST(0)."
"FMULP ST(i), ST(0)","LEX.WN DE C8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack."
"FNCLEX","LEX.WN DB E2","Valid","Valid","Valid","X87","","","","","","Clear floating-point exception flags without checking for pending unmasked floating-point exceptions."
"FNDISI","LEX.WN DB E1","Valid","Valid","Valid","X87","","","","","","Treated as Integer NOP."
"FNENI","LEX.WN DB E0","Valid","Valid","Valid","X87","","","","","","Treated as Integer NOP."
"FNINIT","LEX.WN DB E3","Valid","Valid","Valid","X87","","","","","","Initialize FPU without checking for pending unmasked floating-point exceptions."
"FNOP","LEX.WN D9 D0","Valid","Valid","Valid","X87","","","","","","No operation is performed."
"FNSAVE mem","LEX.WN DD /6","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU environment to m94byte or m108byte without checking for pending unmasked floating- point exceptions. Then re-initialize the FPU."
"FNSETPM","LEX.WN DB E4","Valid","Valid","Valid","X87","","","","","","Treated as Integer NOP."
"FNSTCW m16","LEX.WN D9 /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions."
"FNSTENV mem","LEX.WN D9 /6","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU environment to m14byte or m28byte without checking for pending unmasked floating- point exceptions. Then mask all floating- point exceptions."
"FNSTSW m16","LEX.WN DD /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions."
"FNSTSW ax","LEX.WN DF E0","Valid","Valid","Valid","X87","RAX (w)","","","","","Store FPU status word in AX register without checking for pending unmasked floating-point exceptions."
"FPATAN","LEX.WN D9 F3","Valid","Valid","Valid","X87","","","","","","Replace ST(1) with arctan(ST(1)/ST(0)) and pop the register stack."
"FPREM","LEX.WN D9 F8","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1)."
"FPREM1","LEX.WN D9 F5","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1)."
"FPTAN","LEX.WN D9 F2","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with its approximate tangent and push 1 onto the FPU stack."
"FRNDINT","LEX.WN D9 FC","Valid","Valid","Valid","X87","","","","","","Round ST(0) to an integer."
"FRSTOR mem","LEX.WN DD /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Load FPU state from m94byte or m108byte."
"FSAVE mem","LEX.9B.WN DD /6","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU."
"FSCALE","LEX.WN D9 FD","Valid","Valid","Valid","X87","","","","","","Scale ST(0) by ST(1)."
"FSIN","LEX.WN D9 FE","Valid","Valid","Valid","X87","","","","","","Replace ST(0) with the approximate of its sine."
"FSINCOS","LEX.WN D9 FB","Valid","Valid","Valid","X87","","","","","","Compute the sine and cosine of ST(0); replace ST(0) with the approximate sine, and push the approximate cosine onto the register stack."
"FSQRT","LEX.WN D9 FA","Valid","Valid","Valid","X87","","","","","","Computes square root of ST(0) and stores the result in ST(0)."
"FST m32fp","LEX.WN D9 /2","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Copy ST(0) to m32fp."
"FST ST(i)","LEX.WN DD D0+r","Valid","Valid","Valid","X87","opcode +r (w)","","","","","Copy ST(0) to ST(i)."
"FST m64fp","LEX.WN DD /2","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Copy ST(0) to m64fp."
"FSTCW m16","LEX.9B.WN D9 /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions."
"FSTENV mem","LEX.9B.WN D9 /6","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions."
"FSTP m32fp","LEX.WN D9 /3","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Copy ST(0) to m32fp and pop register stack."
"FSTP m80fp","LEX.WN DB /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Copy ST(0) to m80fp and pop register stack."
"FSTP ST(i)","LEX.WN DD D8+r","Valid","Valid","Valid","X87","opcode +r (w)","ST0 (r)","","","","Copy ST(0) to ST(i) and pop register stack.F"
"FSTP m64fp","LEX.WN DD /3","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Copy ST(0) to m64fp and pop register stack."
"FSTSW m16","LEX.9B.WN DD /7","Valid","Valid","Valid","X87","ModRM:r/m (w)","","","","","Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions."
"FSTSW ax","LEX.9B.WN DF E0","Valid","Valid","Valid","X87","RAX (w)","","","","","Store FPU status word in AX register after checking for pending unmasked floating-point exceptions."
"FSUB ST(0), ST(i)","LEX.WN D8 E0+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Subtract ST(i) from ST(0) and store result in ST(0)."
"FSUB m32fp","LEX.WN D8 /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract m32fp from ST(0) and store result in ST(0)."
"FSUB ST(i), ST(0)","LEX.WN DC E8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Subtract ST(0) from ST(i) and store result in ST(i)."
"FSUB m64fp","LEX.WN DC /4","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract m64fp from ST(0) and store result in ST(0)."
"FSUBP ST(i), ST(0)","LEX.WN DE E8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Subtract ST(0) from ST(i), store result in ST(i), and pop register stack."
"FSUBR ST(0), ST(i)","LEX.WN D8 E8+r","Valid","Valid","Valid","X87","ST0 (r, w)","opcode +r (r)","","","","Subtract ST(0) from ST(i) and store result in ST(0)."
"FSUBR m32fp","LEX.WN D8 /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract ST(0) from m32fp and store result in ST(0)."
"FSUBR ST(i), ST(0)","LEX.WN DC E0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Subtract ST(i) from ST(0) and store result in ST(i)."
"FSUBR m64fp","LEX.WN DC /5","Valid","Valid","Valid","X87","ModRM:r/m (r)","","","","","Subtract ST(0) from m64fp and store result in ST(0)."
"FSUBRP ST(i), ST(0)","LEX.WN DE E0+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r)","","","","Subtract ST(i) from ST(0), store result in ST(i), and pop register stack."
"FTST","LEX.WN D9 E4","Valid","Valid","Valid","X87","","","","","","Compare ST(0) with 0.0."
"FUCOM ST(i)","LEX.WN DD E0+r","Valid","Valid","Valid","X87","opcode +r (r)","ST0 (r)","","","","Compare ST(0) with ST(i)."
"FUCOMI ST(0), ST(i)","LEX.WN DB E8+r","Valid","Valid","Valid","X87","ST0 (r)","opcode +r (r)","","","","Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly."
"FUCOMIP ST(0), ST(i)","LEX.WN DF E8+r","Valid","Valid","Valid","X87","ST0 (r)","opcode +r (r)","","","","Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack."
"FUCOMP ST(i)","LEX.WN DD E8+r","Valid","Valid","Valid","X87","opcode +r (r)","ST0 (r)","","","","Compare ST(0) with ST(i) and pop register stack."
"FUCOMPP","LEX.WN DA E9","Valid","Valid","Valid","X87","","","","","","Compare ST(0) with ST(1) and pop register stack twice."
"FXAM","LEX.WN D9 E5","Valid","Valid","Valid","X87","","","","","","Classify value or number in ST(0)."
"FXCH ST(i)","LEX.WN D9 C8+r","Valid","Valid","Valid","X87","opcode +r (r, w)","ST0 (r, w)","","","","Exchange the contents of ST(0) and ST(i)."
"FXRSTOR mem","LEX.0F.W0 AE /1","Valid","Valid","Valid","X87","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."
"FXSAVE mem","LEX.0F.W0 AE /0","Valid","Valid","Valid","X87","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","","","","","Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."
"FXTRACT","LEX.WN D9 F4","Valid","Valid","Valid","X87","","","","","","Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack."
"FYL2X","LEX.WN D9 F1","Valid","Valid","Valid","X87","","","","","","Replace ST(1) with (ST(1) * log ST(0)) and pop the register stack."
"FYL2XP1","LEX.WN D9 F9","Valid","Valid","Valid","X87","","","","","","Replace ST(1) with ST(1) * log (ST(0) + 1.0) and pop the register stack."
