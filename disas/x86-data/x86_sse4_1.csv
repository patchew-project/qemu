"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
"BLENDPD xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 0D /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in ib and store the values into xmm1."
"BLENDPS xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 0C /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in ib and store the values into xmm1."
"BLENDVPD xmm1, xmm2/m128 , <XMM0>","LEX.66.0F38.W0 15 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","Implicit XMM0 (r)","","","Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1."
"BLENDVPS xmm1, xmm2/m128, <XMM0>","LEX.66.0F38.W0 14 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","Implicit XMM0 (r)","","","Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1."
"DPPD xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 41 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Selectively multiply packed DP floating-point values from xmm1 with packed DP floating-point values from xmm2, add and selectively store the packed DP floating-point values to xmm1."
"DPPS xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 40 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Selectively multiply packed SP floating-point values from xmm1 with packed SP floating-point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1."
"EXTRACTPS rw/mw, xmm1, ib","LEX.66.0F3A.W0 17 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract one single-precision floating-point value from xmm1 at the offset specified by ib and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
"INSERTPS xmm1, xmm2/m32, ib","LEX.66.0F3A.W0 21 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Insert a single-precision floating-point value selected by ib from xmm2/m32 into xmm1 at the specified destination element specified by ib and zero out destination elements in xmm1 as indicated in ib."
"MOVNTDQA xmm1, m128","LEX.66.0F38.W0 2A /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Move double quadword from m128 to xmm1 using non-temporal hint if WC memory type."
"MPSADBW xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 42 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by ib."
"PACKUSDW xmm1, xmm2/m128","LEX.66.0F38.W0 2B /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation."
"PBLENDVB xmm1, xmm2/m128, <XMM0>","LEX.66.0F38.W0 10 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","Implicit XMM0 (r)","","","Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1."
"PBLENDW xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 0E /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","ib","","","Select words from xmm1 and xmm2/m128 from mask specified in ib and store the values into xmm1."
"PCMPEQQ xmm1, xmm2/m128","LEX.66.0F38.W0 29 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed qwords in xmm2/m128 and xmm1 for equality."
"PEXTRB r32/m8, xmm2, ib","LEX.66.0F3A.W0 14 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract a byte integer value from xmm2 at the source byte offset specified by ib into reg or m8. The upper bits of r are zeroed."
"PEXTRW r32/m16, xmm, ib","LEX.66.0F3A.W0 15 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:r/m (w)","ModRM:reg (r)","ib","","","Extract the word specified by ib from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r."
"PHMINPOSUW xmm1, xmm2/m128","LEX.66.0F38.W0 41 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1."
"PINSRB xmm1, r32/m8, ib","LEX.66.0F3A.W0 20 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Insert a byte integer value from r8/m8 into xmm1 at the destination element in xmm1 specified by ib."
"PINSRD xmm1, r32/m32, ib","LEX.66.0F3A.W0 22 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by ib."
"PINSRQ xmm1, r64/m64, ib","LEX.66.0F3A.W1 22 /r ib","Valid","Invalid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Insert a qword integer value from r/m64 into the xmm1 at the destination element specified by ib."
"PMAXSB xmm1, xmm2/m128","LEX.66.0F38.W0 3C /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
"PMAXSD xmm1, xmm2/m128","LEX.66.0F38.W0 3D /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
"PMAXUD xmm1, xmm2/m128","LEX.66.0F38.W0 3F /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
"PMAXUW xmm1, xmm2/m128","LEX.66.0F38.W0 3E /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned word integers in xmm2/m128 and xmm1 and stores maximum packed values in xmm1."
"PMINSB xmm1, xmm2/m128","LEX.66.0F38.W0 38 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
"PMINSD xmm1, xmm2/m128","LEX.66.0F38.W0 39 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
"PMINUD xmm1, xmm2/m128","LEX.66.0F38.W0 3B /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
"PMINUW xmm1, xmm2/m128","LEX.66.0F38.W0 3A /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Compare packed unsigned word integers in xmm2/m128 and xmm1 and store packed minimum values in xmm1."
"PMOVSXBD xmm1, xmm2/m32","LEX.66.0F38.W0 21 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
"PMOVSXBQ xmm1, xmm2/m16","LEX.66.0F38.W0 22 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
"PMOVSXBW xmm1, xmm2/m64","LEX.66.0F38.W0 20 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
"PMOVSXDQ xmm1, xmm2/m64","LEX.66.0F38.W0 25 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
"PMOVSXWD xmm1, xmm2/m64","LEX.66.0F38.W0 23 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
"PMOVSXWQ xmm1, xmm2/m32","LEX.66.0F38.W0 24 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
"PMOVZXBD xmm1, xmm2/m32","LEX.66.0F38.W0 31 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
"PMOVZXBQ xmm1, xmm2/m16","LEX.66.0F38.W0 32 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
"PMOVZXBW xmm1, xmm2/m64","LEX.66.0F38.W0 30 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
"PMOVZXDQ xmm1, xmm2/m64","LEX.66.0F38.W0 35 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
"PMOVZXWD xmm1, xmm2/m64","LEX.66.0F38.W0 33 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
"PMOVZXWQ xmm1, xmm2/m32","LEX.66.0F38.W0 34 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","","","","Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
"PMULDQ xmm1, xmm2/m128","LEX.66.0F38.W0 28 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply packed signed doubleword integers in xmm1 by packed signed doubleword integers in xmm2/m128, and store the quadword results in xmm1."
"PMULLD xmm1, xmm2/m128","LEX.66.0F38.W0 40 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1."
"PTEST xmm1, xmm2/m128","LEX.66.0F38.W0 17 /r","Valid","Valid","Invalid","SSE4_1","ModRM:reg (r)","ModRM:r/m (r)","","","","Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s."
"ROUNDPD xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 09 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round packed double precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by ib."
"ROUNDPS xmm1, xmm2/m128, ib","LEX.66.0F3A.W0 08 /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round packed single precision floating-point values in xmm2/m128 and place the result in xmm1. The rounding mode is determined by ib."
"ROUNDSD xmm1, xmm2/m64, ib","LEX.66.0F3A.W0 0B /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round the low packed double precision floating-point value in xmm2/m64 and place the result in xmm1. The rounding mode is determined by ib."
"ROUNDSS xmm1, xmm2/m32, ib","LEX.66.0F3A.W0 0A /r ib","Valid","Valid","Invalid","SSE4_1","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Round the low packed single precision floating-point value in xmm2/m32 and place the result in xmm1. The rounding mode is determined by ib."
