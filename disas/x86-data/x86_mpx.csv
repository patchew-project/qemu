"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
"BNDCL bnd, rw/mw","LEX.F3.0F.W0 1A /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","ModRM:r/m (r)","","","","Generate a #BR if the address in r/m is lower than the lower bound in bnd.LB."
"BNDCN bnd, rw/mw","LEX.F2.0F.W0 1B /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","ModRM:r/m (r)","","","","Generate a #BR if the address in r/m is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form)."
"BNDCU bnd, rw/mw","LEX.F2.0F.W0 1A /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","ModRM:r/m (r)","","","","Generate a #BR if the address in r/m is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form)."
"BNDLDX bnd, mib","LEX.0F.W0 1A /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","SIB.base (r): Address of pointer SIB.index (r)","","","","Load the bounds stored in a bound table entry (BTE) into bnd with address translation using the base of mib and conditional on the index of mib matching the pointer value in the BTE."
"BNDMK bnd, mem","LEX.F3.0F.W0 1B /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","Make lower and upper bounds from m32 and store them in bnd."
"BNDMOV bnd, bnd/mem","LEX.66.0F.W0 1A /r","Valid","Valid","Invalid","MPX","ModRM:reg (w)","ModRM:r/m (r)","","","","Move lower and upper bound from bnd2/m64 to bound register bnd1."
"BNDMOV bnd/mem, bnd","LEX.66.0F.W0 1B /r","Valid","Valid","Invalid","MPX","ModRM:r/m (w)","ModRM:reg (r)","","","","Move lower and upper bound from bnd2 to bnd1/m64."
"BNDSTX mib, bnd","LEX.0F.W0 1B /r","Valid","Valid","Invalid","MPX","SIB.base (r): Address of pointer SIB.index (r)","ModRM:reg (r)","","","","Store the bounds in bnd and the pointer value in the index register of mib to a bound table entry (BTE) with address translation using the base of mib."
