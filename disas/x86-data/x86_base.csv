"Instruction","Opcode","Valid 64-bit","Valid 32-bit","Valid 16-bit","Feature Flags","Operand 1","Operand 2","Operand 3","Operand 4","Tuple Type","Description"
"AAA al","LEX.WN 37","Invalid","Valid","Valid","","RAX (r, w)","","","","","ASCII adjust AL after addition."
"AAD ax, ib","LEX.WN D5 ib","Invalid","Valid","Valid","","RAX (r, w)","ib","","","","Adjust AX before division to number base ib."
"AAM ax, ib","LEX.WN D4 ib","Invalid","Valid","Valid","","RAX (r, w)","ib","","","","Adjust AX after multiply to number base ib."
"AAS al","LEX.WN 3F","Invalid","Valid","Valid","","RAX (r, w)","","","","","ASCII adjust AL after subtraction."
"ADC r8/m8, r8","LEX.WB 10 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Add with carry byte register to r8/m8."
"ADC rw/mw, rw","LEX.WX 11 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Add with carry r to r/m."
"ADC r8, r8/m8","LEX.WB 12 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add with carry r8/m8 to byte register."
"ADC rw, rw/mw","LEX.WX 13 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add with carry r/m to r."
"ADC al, ib","LEX.WN 14 ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","Add with carry ib to AL."
"ADC aw, iw","LEX.WX 15 iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","Add with carry iw to EAX."
"ADC r8/m8, ib","LEX.WB 80 /2 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Add with carry ib to r8/m8."
"ADC rw/mw, iw","LEX.WX 81 /2 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","Add with CF iw to r/m."
"ADC rw/mw, ib","LEX.WX 83 /2 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Add with CF sign-extended ib into r/m."
"ADD r8/m8, r8","LEX.WB 00 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Add r8 to r8/m8."
"ADD rw/mw, rw","LEX.WX 01 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Add r to r/m."
"ADD r8, r8/m8","LEX.WB 02 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add r8/m8 to r8."
"ADD rw, rw/mw","LEX.WX 03 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Add r/m to r."
"ADD al, ib","LEX.WN 04 ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","Add ib to AL."
"ADD aw, iw","LEX.WX 05 iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","Add sign-extended iw to AX/EAX/RAX."
"ADD r8/m8, ib","LEX.WB 80 /0 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Add ib to r8/m8."
"ADD rw/mw, iw","LEX.WX 81 /0 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","Add sign-extended iw to r/m."
"ADD rw/mw, ib","LEX.WX 83 /0 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Add sign-extended ib to r/m."
"AND r8/m8, r8","LEX.WB 20 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r8/m8 AND r8."
"AND rw/mw, rw","LEX.WX 21 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r/m AND r16."
"AND r8, r8/m8","LEX.WB 22 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r8 AND r8/m8."
"AND rw, rw/mw","LEX.WX 23 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r AND r/m."
"AND al, ib","LEX.WN 24 ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","AL AND ib."
"AND aw, iw","LEX.WX 25 iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","AX/EAX/RAX AND sign-extend iw."
"AND r8/m8, ib","LEX.WB 80 /4 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r8/m8 AND ib."
"AND rw/mw, iw","LEX.WX 81 /4 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","r/m AND sign-extend iw."
"AND rw/mw, ib","LEX.WX 83 /4 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r/m AND sign-extend ib."
"ARPL r16/m16, r16","LEX.wn 63 /r","Invalid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Adjust RPL of r/m16 to not less than RPL of r16."
"BOUND r16, mem","LEX.WX 62 /r o16","Invalid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","Check if r (array index) is within bounds specified by m32&32."
"BOUND r32, mem","LEX.WX 62 /r o32","Invalid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","Check if r (array index) is within bounds specified by m32&32."
"BSF rw, rw/mw","LEX.0F.WX BC /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Bit scan forward on rw/mw."
"BSR rw, rw/mw","LEX.0F.WX BD /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Bit scan reverse on rw/mw."
"BSWAP r32","LEX.0F.W0 C8+r","Valid","Valid","Valid","","opcode +r (r, w)","","","","","Reverses the byte order of a 32-bit register."
"BSWAP r64","LEX.0F.W1 C8+r","Valid","Invalid","Invalid","","opcode +r (r, w)","","","","","Reverses the byte order of a 64-bit register."
"BT rw/mw, rw","LEX.0F.WX A3 /r","Valid","Valid","Valid","","ModRM:r/m (r)","ModRM:reg (r)","","","","Store selected bit in CF flag."
"BT rw/mw, ib","LEX.0F.WX BA /4 ib","Valid","Valid","Valid","","ModRM:r/m (r)","ib","","","","Store selected bit in CF flag."
"BTC rw/mw, ib","LEX.0F.WX BA /7 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Store selected bit in CF flag and complement."
"BTC rw/mw, rw","LEX.0F.WX BB /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Store selected bit in CF flag and complement."
"BTR rw/mw, rw","LEX.0F.WX B3 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Store selected bit in CF flag and clear."
"BTR rw/mw, ib","LEX.0F.WX BA /6 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Store selected bit in CF flag and clear."
"BTS rw/mw, rw","LEX.0F.WX AB /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Store selected bit in CF flag and set."
"BTS rw/mw, ib","LEX.0F.WX BA /5 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Store selected bit in CF flag and set."
"CALL relw","LEX.WX E8 iwd","Valid","Valid","Valid","","iwd","RSP (r, w, i)","","","","Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode."
"CALL rw/mw","LEX.WW FF /2","Valid","Valid","Valid","","ModRM:r/m (r)","RSP (r, w, i)","","","","Call near, absolute indirect, address given in rw/mw."
"LCALL far16:16","LEX.WW 9A iwd i16 o16","Invalid","Valid","Valid","","imm","ime","RSP (r, w, i)","","","Call far, absolute, address given in operand."
"LCALL far16:32","LEX.WW 9A iwd i16 o32","Invalid","Valid","Valid","","imm","ime","RSP (r, w, i)","","","Call far, absolute, address given in operand."
"LCALL memfar16:16","LEX.WW FF /3 o16","Valid","Valid","Valid","","ModRM:r/m (r)","RSP (r, w, i)","","","","Call far, absolute indirect address given in m16:16. In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate; else RIP = zero extended 16-bit offset from far pointer referenced in the instruction."
"LCALL memfar16:32","LEX.WW FF /3 o32","Invalid","Valid","Valid","","ModRM:r/m (r)","RSP (r, w, i)","","","","In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction."
"LCALL memfar16:64","LEX.WW FF /3 o64","Valid","Invalid","Invalid","","ModRM:r/m (r)","RSP (r, w, i)","","","","In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction."
"CBW","LEX.WX 98 o16","Valid","Valid","Valid","","RAX (r, w)","","","","","AX := sign-extend of AL."
"CDQ","LEX.WX 99 o32","Valid","Valid","Valid","","RDX (w)","RAX (r, w)","","","","EDX:EAX := sign-extend of EAX."
"CDQE","LEX.WX 98 o64","Valid","Invalid","Invalid","","RAX (r, w)","","","","","RAX := sign-extend of EAX."
"CLC","LEX.WN F8","Valid","Valid","Valid","","","","","","","Clear CF flag."
"CLD","LEX.WN FC","Valid","Valid","Valid","","","","","","","Clear DF flag."
"CLFLUSH m8","LEX.0F.W0 AE /7","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Flushes cache line containing m8."
"CLFLUSHOPT m8","LEX.66.0F.W0 AE /7","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Flushes cache line containing m8."
"CLI","LEX.WN FA","Valid","Valid","Valid","","","","","","","Clear interrupt flag; interrupts disabled when interrupt flag cleared."
"CLTS","LEX.0F.W0 06","Valid","Valid","Valid","","","","","","","Clears TS flag in CR0."
"CMC","LEX.WN F5","Valid","Valid","Valid","","","","","","","Complement CF flag."
"CMOVA rw, rw/mw","LEX.0F.WX 47 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if above (CF=0 and ZF=0)."
"CMOVAE rw, rw/mw","LEX.0F.WX 43 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if above or equal (CF=0)."
"CMOVB rw, rw/mw","LEX.0F.WX 42 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if below (CF=1)."
"CMOVBE rw, rw/mw","LEX.0F.WX 46 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if below or equal (CF=1 or ZF=1)."
"CMOVC rw, rw/mw","LEX.0F.WX 42 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if carry (CF=1)."
"CMOVE rw, rw/mw","LEX.0F.WX 44 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if equal (ZF=1)."
"CMOVG rw, rw/mw","LEX.0F.WX 4F /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if greater (ZF=0 and SF=OF)."
"CMOVGE rw, rw/mw","LEX.0F.WX 4D /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if greater or equal (SF=OF)."
"CMOVL rw, rw/mw","LEX.0F.WX 4C /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if less (SF!=OF)."
"CMOVLE rw, rw/mw","LEX.0F.WX 4E /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if less or equal (ZF=1 or SF!=OF)."
"CMOVNA rw, rw/mw","LEX.0F.WX 46 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not above (CF=1 or ZF=1)."
"CMOVNAE rw, rw/mw","LEX.0F.WX 42 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not above or equal (CF=1)."
"CMOVNB rw, rw/mw","LEX.0F.WX 43 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not below (CF=0)."
"CMOVNBE rw, rw/mw","LEX.0F.WX 47 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not below or equal (CF=0 and ZF=0)."
"CMOVNC rw, rw/mw","LEX.0F.WX 43 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not carry (CF=0)."
"CMOVNE rw, rw/mw","LEX.0F.WX 45 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not equal (ZF=0)."
"CMOVNG rw, rw/mw","LEX.0F.WX 4E /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not greater (ZF=1 or SF!=OF)."
"CMOVNGE rw, rw/mw","LEX.0F.WX 4C /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not greater or equal (SF!=OF)."
"CMOVNL rw, rw/mw","LEX.0F.WX 4D /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not less (SF=OF)."
"CMOVNLE rw, rw/mw","LEX.0F.WX 4F /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not less or equal (ZF=0 and SF=OF)."
"CMOVNO rw, rw/mw","LEX.0F.WX 41 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not overflow (OF=0)."
"CMOVNP rw, rw/mw","LEX.0F.WX 4B /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not parity (PF=0)."
"CMOVNS rw, rw/mw","LEX.0F.WX 49 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not sign (SF=0)."
"CMOVNZ rw, rw/mw","LEX.0F.WX 45 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if not zero (ZF=0)."
"CMOVO rw, rw/mw","LEX.0F.WX 40 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if overflow (OF=1)."
"CMOVP rw, rw/mw","LEX.0F.WX 4A /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if parity (PF=1)."
"CMOVPE rw, rw/mw","LEX.0F.WX 4A /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Move if parity even (PF=1)."
"CMP r8/m8, r8","LEX.WB 38 /r","Valid","Valid","Valid","","ModRM:r/m (r)","ModRM:reg (r)","","","","Compare r8 with r8/m8."
"CMP rw/mw, rw","LEX.WX 39 /r","Valid","Valid","Valid","","ModRM:r/m (r)","ModRM:reg (r)","","","","Compare rw with rw/mw."
"CMP r8, r8/m8","LEX.WB 3A /r","Valid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare r8/m8 with r8."
"CMP rw, rw/mw","LEX.WX 3B /r","Valid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r)","","","","Compare r/m with rw."
"CMP al, ib","LEX.WN 3C ib","Valid","Valid","Valid","","RAX (r)","ib","","","","Compare ib with AL."
"CMP aw, iw","LEX.WX 3D iw","Valid","Valid","Valid","","RAX (r)","iw","","","","Compare sign-extended iw with AX/EAX/RAX."
"CMP r8/m8, ib","LEX.WB 80 /7 ib","Valid","Valid","Valid","","ModRM:r/m (r)","ib","","","","Compare ib with r8/m8."
"CMP rw/mw, iw","LEX.WX 81 /7 iw","Valid","Valid","Valid","","ModRM:r/m (r)","iw","","","","Compare iw with rw/mw."
"CMP rw/mw, ib","LEX.WX 83 /7 ib","Valid","Valid","Valid","","ModRM:r/m (r)","ib","","","","Compare ib with rw/mw."
"CMPSB psi, pdi","LEX.WB A6 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","Compare byte at address DS:SI/ESI/RSI with byte at address ES:DI/EDI/RDI; The status flags are set accordingly."
"CMPSD psi, pdi","LEX.WX A7 o32 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","Compare dword at address DS:SI/ESI/RSI with word at address ES:DI/EDI/RDI; The status flags are set accordingly."
"CMPSQ psi, pdi","LEX.WX A7 o64 rep","Valid","Invalid","Invalid","","RDI (r)","RSI (r)","","","","Compares qword at address DS:RSI with quadword at address ES:RDI and sets the status flags accordingly."
"CMPSW psi, pdi","LEX.WX A7 o16 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","Compare word at address DS:SI/ESI/RSI with word at address ES:DI/EDI/RDI; The status flags are set accordingly."
"CMPXCHG r8/m8, r8","LEX.0F.WB B0 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","RAX (r, w)","","","Compare AL with r8/m8. If equal, ZF is set and r8 is loaded into r8/m8. Else, clear ZF and load r8/m8 into AL."
"CMPXCHG rw/mw, rw","LEX.0F.WX B1 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","RAX (r, w)","","","Compare AX/EAX/RAX with rw/mw. If equal, ZF is set and rw is loaded into rw/mw. Else, clear ZF and load r/m into EAX."
"CMPXCHG16B m128","LEX.0F.W1 C7 /1 lock","Valid","Invalid","Invalid","","ModRM:r/m (r, w)","RDX (r, w)","RAX (r, w)","","","Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX."
"CMPXCHG8B m64","LEX.0F.W0 C7 /1 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","RDX (r, w)","RAX (r, w)","","","Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX."
"CPUID","LEX.0F.W0 A2","Valid","Valid","Valid","","","","","","","Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well)."
"CQO","LEX.WX 99 o64","Valid","Invalid","Invalid","","RDX (w)","RAX (r, w)","","","","RDX:RAX:= sign-extend of RAX."
"CRC32 rw, r8/m8","LEX.F2.0F38.WX F0 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Accumulate CRC32 on r8/m8."
"CRC32 rw, rw/mw","LEX.F2.0F38.WX F1 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Accumulate CRC32 on r/m."
"CVTPD2PI mm, xmm/m128","LEX.66.0F.W0 2D /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm."
"CVTPI2PD xmm, mm/m64","LEX.66.0F.W0 2A /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm."
"CVTPI2PS xmm, mm/m64","LEX.0F.W0 2A /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm."
"CVTPS2PI mm, xmm/m64","LEX.0F.W0 2D /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packed single-precision floating-point values from xmm/m64 to two packed signed doubleword integers in mm."
"CVTTPD2PI mm, xmm/m128","LEX.66.0F.W0 2C /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two packer double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm using truncation."
"CVTTPS2PI mm, xmm/m64","LEX.0F.W0 2C /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation."
"CWD","LEX.WX 99 o16","Valid","Valid","Valid","","RDX (w)","RAX (r, w)","","","","DX:AX := sign-extend of AX."
"CWDE","LEX.WX 98 o32","Valid","Valid","Valid","","RAX (r, w)","","","","","EAX := sign-extend of AX."
"DAA al","LEX.WN 27","Invalid","Valid","Valid","","RAX (r, w)","","","","","Decimal adjust AL after addition."
"DAS al","LEX.WN 2F","Invalid","Valid","Valid","","RAX (r, w)","","","","","Decimal adjust AL after subtraction."
"DEC rw","LEX.WW 48+r","Invalid","Valid","Valid","","opcode +r (r, w)","","","","","Decrement rw by 1."
"DEC r8/m8","LEX.WB FE /1 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Decrement r8/m8 by 1."
"DEC rw/mw","LEX.WX FF /1 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Decrement r/m by 1."
"DIV r8/m8","LEX.WB F6 /6","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Unsigned divide AX by r8/m8, with result stored in AL := Quotient, AH := Remainder."
"DIV rw/mw","LEX.WX F7 /6","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Unsigned divide DX/EDX/RDX:AX/EAX/RAX by r/m, with result stored in AX/EAX/RAX := Quotient, DX/EDX/RDX := Remainder."
"EMMS","LEX.0F.W0 77","Valid","Valid","Valid","","","","","","","Set the x87 FPU tag word to empty."
"ENTER i16, ib","LEX.WW C8 i16 ib","Valid","Valid","Valid","","imm","ime","RSP (r, w, i)","RBP (r, w, i)","","Create a stack frame with nested pointers for a procedure."
"FXRSTOR64 mem","LEX.0F.W1 AE /1","Valid","Invalid","Invalid","","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."
"FXSAVE64 mem","LEX.0F.W1 AE /0","Valid","Invalid","Invalid","","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","","","","","Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."
"HLT","LEX.WN F4","Valid","Valid","Valid","","","","","","","Halt"
"IDIV r8/m8","LEX.WB F6 /7","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Signed divide AX by r8/m8, with result stored in: AL := Quotient, AH := Remainder."
"IDIV rw/mw","LEX.WX F7 /7","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Signed divide DX/EDX/RDX:AX/EAX/RAX by r/m, with result stored in AX/EAX/RAX := Quotient, DX/EDX/RDX := Remainder."
"IMUL rw, rw/mw, iw","LEX.WX 69 /r iw","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","iw","","","register := r/m * sign-extended immediate."
"IMUL rw, rw/mw, ib","LEX.WX 6B /r ib","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","ib","","","register := r/m * sign-extended immediate."
"IMUL rw, rw/mw","LEX.0F.W0 AF /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","register := register * r/m."
"IMUL r8/m8","LEX.WB F6 /5","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","AX:= AL * r/m byte."
"IMUL rw/mw","LEX.WX F7 /5","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","DX/EDX/RDX:AX/EAX/RAX := AX/EAX/RAX * r/m."
"IN al, ib","LEX.WB E4 ib","Valid","Valid","Valid","","RAX (w)","ib","","","","Input byte from ib I/O port address into AL."
"IN aw, ib","LEX.WX E5 ib o32","Valid","Valid","Valid","","RAX (w)","ib","","","","Input word from ib I/O port address into EAX."
"IN al, dx","LEX.WB EC","Valid","Valid","Valid","","RAX (w)","RDX (r)","","","","Input byte from I/O port in DX into AL."
"IN aw, dx","LEX.WX ED o32","Valid","Valid","Valid","","RAX (w)","RDX (r)","","","","Input word from I/O port in DX into EAX."
"INC rw","LEX.WW 40+r","Invalid","Valid","Valid","","opcode +r (r, w)","","","","","Increment word register by 1."
"INC r8/m8","LEX.WB FE /0 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Increment r/m byte by 1."
"INC rw/mw","LEX.WX FF /0 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Increment r/m doubleword by 1."
"INSB pdi, dx","LEX.WB 6C rep","Valid","Valid","Valid","","RDI (r)","RDX (r)","","","","Input byte from I/O port in DX into memory location specified in ES:(E)DI or RDI."
"INSD pdi, dx","LEX.WX 6D o32 rep","Valid","Valid","Valid","","RDI (r)","RDX (r)","","","","Input doubleword from I/O port in DX into memory location specified in ES:(E)DI or RDI."
"INSW pdi, dx","LEX.WX 6D o16 rep","Valid","Valid","Valid","","RDI (r)","RDX (r)","","","","Input word from I/O port in DX into memory location specified in ES:(E)DI or RDI."
"INT ib","LEX.WN CD ib","Valid","Valid","Valid","","ib","","","","","Generate software interrupt with vector specified by immediate byte."
"INT1","LEX.WN F1","Valid","Valid","Valid","","","","","","","Generate debug trap."
"INT3","LEX.WN CC","Valid","Valid","Valid","","","","","","","Interrupt 3, trap to debugger."
"INTO","LEX.WN CE","Invalid","Valid","Valid","","","","","","","Interrupt 4, if overflow flag is 1."
"INVD","LEX.0F.W0 08","Valid","Valid","Valid","","","","","","","Flush internal caches; initiate flushing of external caches."
"INVLPG m8","LEX.0F.W0 01 /7","Valid","Valid","Valid","","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Invalidate TLB entries for page containing m."
"IRETD","LEX.WX CF o32","Valid","Valid","Valid","","","","","","","Interrupt return (32-bit operand size)."
"IRETQ","LEX.WX CF o64","Valid","Invalid","Invalid","","","","","","","Interrupt return (64-bit operand size)."
"IRETW","LEX.WX CF o16","Valid","Valid","Valid","","","","","","","Interrupt return (16-bit operand size)."
"JA rel8","LEX.WN 77 ib","Valid","Valid","Valid","","ib","","","","","Jump short if above (CF=0 and ZF=0)."
"JA relw","LEX.0F.W0 87 iw","Valid","Valid","Valid","","iw","","","","","Jump near if above (CF=0 and ZF=0)."
"JAE rel8","LEX.WN 73 ib","Valid","Valid","Valid","","ib","","","","","Jump short if above or equal (CF=0)."
"JAE relw","LEX.0F.W0 83 iw","Valid","Valid","Valid","","iw","","","","","Jump near if above or equal (CF=0)."
"JB rel8","LEX.WN 72 ib","Valid","Valid","Valid","","ib","","","","","Jump short if below (CF=1)."
"JB relw","LEX.0F.W0 82 iw","Valid","Valid","Valid","","iw","","","","","Jump near if below (CF=1)."
"JBE rel8","LEX.WN 76 ib","Valid","Valid","Valid","","ib","","","","","Jump short if below or equal (CF=1 or ZF=1)."
"JBE relw","LEX.0F.W0 86 iw","Valid","Valid","Valid","","iw","","","","","Jump near if below or equal (CF=1 or ZF=1)."
"JC rel8","LEX.WN 72 ib","Valid","Valid","Valid","","ib","","","","","Jump short if carry (CF=1)."
"JC relw","LEX.0F.W0 82 iw","Valid","Valid","Valid","","iw","","","","","Jump near if carry (CF=1)."
"JCXZ rel8","LEX.WN E3 ib a16","Invalid","Valid","Valid","","ib","","","","","Jump short if CX register is 0."
"JE rel8","LEX.WN 74 ib","Valid","Valid","Valid","","ib","","","","","Jump short if equal (ZF=1)."
"JE relw","LEX.0F.W0 84 iw","Valid","Valid","Valid","","iw","","","","","Jump near if equal (ZF=1)."
"JECXZ rel8","LEX.WN E3 ib a32","Valid","Valid","Valid","","ib","","","","","Jump short if ECX register is 0."
"JG rel8","LEX.WN 7F ib","Valid","Valid","Valid","","ib","","","","","Jump short if greater (ZF=0 and SF=OF)."
"JG relw","LEX.0F.W0 8F iw","Valid","Valid","Valid","","iw","","","","","Jump near if greater (ZF=0 and SF=OF)."
"JGE rel8","LEX.WN 7D ib","Valid","Valid","Valid","","ib","","","","","Jump short if greater or equal (SF=OF)."
"JGE relw","LEX.0F.W0 8D iw","Valid","Valid","Valid","","iw","","","","","Jump near if greater or equal (SF=OF)."
"JL rel8","LEX.WN 7C ib","Valid","Valid","Valid","","ib","","","","","Jump short if less (SF!=OF)."
"JL relw","LEX.0F.W0 8C iw","Valid","Valid","Valid","","iw","","","","","Jump near if less (SF!=OF)."
"JLE rel8","LEX.WN 7E ib","Valid","Valid","Valid","","ib","","","","","Jump short if less or equal (ZF=1 or SF!=OF)."
"JLE relw","LEX.0F.W0 8E iw","Valid","Valid","Valid","","iw","","","","","Jump near if less or equal (ZF=1 or SF!=OF)."
"JMP relw","LEX.WX E9 iwd","Valid","Valid","Valid","","iwd","","","","","Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits"
"JMP rel8","LEX.WN EB ib","Valid","Valid","Valid","","ib","","","","","Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits"
"JMP rw/mw","LEX.WW FF /4","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Jump near, absolute indirect, address given in r/m."
"LJMP far16:16","LEX.WW EA iwd i16 o16","Invalid","Valid","Valid","","imm","ime","","","","Jump far, absolute, address given in operand"
"LJMP far16:32","LEX.WW EA iwd i16 o32","Invalid","Valid","Valid","","imm","ime","","","","Jump far, absolute, address given in operand"
"LJMP memfar16:16","LEX.WW FF /5 o16","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Jump far, absolute indirect, address given in m16:16"
"LJMP memfar16:32","LEX.WW FF /5 o32","Invalid","Valid","Valid","","ModRM:r/m (r)","","","","","Jump far, absolute indirect, address given in m16:32."
"LJMP memfar16:64","LEX.WW FF /5 o64","Valid","Invalid","Invalid","","ModRM:r/m (r)","","","","","Jump far, absolute indirect, address given in m16:64."
"JNA rel8","LEX.WN 76 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not above (CF=1 or ZF=1)."
"JNA relw","LEX.0F.W0 86 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not above (CF=1 or ZF=1)."
"JNAE rel8","LEX.WN 72 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not above or equal (CF=1)."
"JNAE relw","LEX.0F.W0 82 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not above or equal (CF=1)."
"JNB rel8","LEX.WN 73 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not below (CF=0)."
"JNB relw","LEX.0F.W0 83 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not below (CF=0)."
"JNBE rel8","LEX.WN 77 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not below or equal (CF=0 and ZF=0)."
"JNBE relw","LEX.0F.W0 87 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not below or equal (CF=0 and ZF=0)."
"JNC rel8","LEX.WN 73 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not carry (CF=0)."
"JNC relw","LEX.0F.W0 83 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not carry (CF=0)."
"JNE rel8","LEX.WN 75 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not equal (ZF=0)."
"JNE relw","LEX.0F.W0 85 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not equal (ZF=0)."
"JNG rel8","LEX.WN 7E ib","Valid","Valid","Valid","","ib","","","","","Jump short if not greater (ZF=1 or SF!=OF)."
"JNG relw","LEX.0F.W0 8E iw","Valid","Valid","Valid","","iw","","","","","Jump near if not greater (ZF=1 or SF!=OF)."
"JNGE rel8","LEX.WN 7C ib","Valid","Valid","Valid","","ib","","","","","Jump short if not greater or equal (SF!=OF)."
"JNGE relw","LEX.0F.W0 8C iw","Valid","Valid","Valid","","iw","","","","","Jump near if not greater or equal (SF!=OF)."
"JNL rel8","LEX.WN 7D ib","Valid","Valid","Valid","","ib","","","","","Jump short if not less (SF=OF)."
"JNL relw","LEX.0F.W0 8D iw","Valid","Valid","Valid","","iw","","","","","Jump near if not less (SF=OF)."
"JNLE rel8","LEX.WN 7F ib","Valid","Valid","Valid","","ib","","","","","Jump short if not less or equal (ZF=0 and SF=OF)."
"JNLE relw","LEX.0F.W0 8F iw","Valid","Valid","Valid","","iw","","","","","Jump near if not less or equal (ZF=0 and SF=OF)."
"JNO rel8","LEX.WN 71 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not overflow (OF=0)."
"JNO relw","LEX.0F.W0 81 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not overflow (OF=0)."
"JNP rel8","LEX.WN 7B ib","Valid","Valid","Valid","","ib","","","","","Jump short if not parity (PF=0)."
"JNP relw","LEX.0F.W0 8B iw","Valid","Valid","Valid","","iw","","","","","Jump near if not parity (PF=0)."
"JNS rel8","LEX.WN 79 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not sign (SF=0)."
"JNS relw","LEX.0F.W0 89 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not sign (SF=0)."
"JNZ rel8","LEX.WN 75 ib","Valid","Valid","Valid","","ib","","","","","Jump short if not zero (ZF=0)."
"JNZ relw","LEX.0F.W0 85 iw","Valid","Valid","Valid","","iw","","","","","Jump near if not zero (ZF=0)."
"JO rel8","LEX.WN 70 ib","Valid","Valid","Valid","","ib","","","","","Jump short if overflow (OF=1)."
"JO relw","LEX.0F.W0 80 iw","Valid","Valid","Valid","","iw","","","","","Jump near if overflow (OF=1)."
"JP rel8","LEX.WN 7A ib","Valid","Valid","Valid","","ib","","","","","Jump short if parity (PF=1)."
"JP relw","LEX.0F.W0 8A iw","Valid","Valid","Valid","","iw","","","","","Jump near if parity (PF=1)."
"JPE rel8","LEX.WN 7A ib","Valid","Valid","Valid","","ib","","","","","Jump short if parity even (PF=1)."
"JPE relw","LEX.0F.W0 8A iw","Valid","Valid","Valid","","iw","","","","","Jump near if parity even (PF=1)."
"JPO rel8","LEX.WN 7B ib","Valid","Valid","Valid","","ib","","","","","Jump short if parity odd (PF=0)."
"JPO relw","LEX.0F.W0 8B iw","Valid","Valid","Valid","","iw","","","","","Jump near if parity odd (PF=0)."
"JRCXZ rel8","LEX.WN E3 ib a64","Valid","Invalid","Invalid","","ib","","","","","Jump short if RCX register is 0."
"JS rel8","LEX.WN 78 ib","Valid","Valid","Valid","","ib","","","","","Jump short if sign (SF=1)."
"JZ rel8","LEX.WN 74 ib","Valid","Valid","Valid","","ib","","","","","Jump short if zero (ZF = 1)."
"JZ relw","LEX.0F.W0 84 iw","Valid","Valid","Valid","","iw","","","","","Jump near if 0 (ZF=1)."
"LAHF ah","LEX.WN 9F","Invalid","Valid","Valid","","RAX (w)","","","","","Load: AH := EFLAGS(SF:ZF:0:AF:0:PF:1:CF)."
"LAR rw, r16/m16","LEX.0F.W0 02 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","reg := access rights referenced by r/m"
"LDS r16, memfar16:16","LEX.WX C5 /r o16","Invalid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load DS:r16 with far pointer from memory."
"LDS r32, memfar16:32","LEX.WX C5 /r o32","Invalid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load DS:r32 with far pointer from memory."
"LEA rw, m","LEX.WX 8D /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Store effective address for m in register r."
"LEAVE","LEX.WW C9","Valid","Valid","Valid","","RSP (r, w, i)","RBP (r, w, i)","","","","Set SP/ESP/RSP to BP/EBP/RBP, then pop BP/EBP/RBP."
"LES r16, memfar16:16","LEX.WX C4 /r o16","Invalid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load ES:r16 with far pointer from memory."
"LES r32, memfar16:32","LEX.WX C4 /r o32","Invalid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load ES:r32 with far pointer from memory."
"LFENCE","LEX.0F.W0 AE E8","Valid","Valid","Valid","","","","","","","Serializes load operations."
"LFS r16, memfar16:16","LEX.0F.WX B4 /r o16","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load FS:r16 with far pointer from memory."
"LFS r32, memfar16:32","LEX.0F.WX B4 /r o32","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load FS:r32 with far pointer from memory."
"LFS r64, memfar16:64","LEX.0F.WX B4 /r o64","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load FS:r64 with far pointer from memory."
"LGDT m","LEX.0F.W0 01 /2","Valid","Valid","Valid","","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Load m into GDTR."
"LGS r16, memfar16:16","LEX.0F.WX B5 /r o16","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load GS:r16 with far pointer from memory."
"LGS r32, memfar16:32","LEX.0F.WX B5 /r o32","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load GS:r32 with far pointer from memory."
"LGS r64, memfar16:64","LEX.0F.WX B5 /r o64","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load GS:r64 with far pointer from memory."
"LIDT m","LEX.0F.W0 01 /3","Valid","Valid","Valid","","ModRM:r/m (r, ModRM:[7:6] must not be 11b)","","","","","Load m into IDTR."
"LLDT r32/m16","LEX.0F.W0 00 /2","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Load segment selector r/m into LDTR."
"LLDT r64/m16","LEX.0F.W1 00 /2","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Load segment selector r/m into LDTR."
"LMSW r32/m16","LEX.0F.W0 01 /6","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Loads r/m in machine status word of CR0."
"LMSW r64/m16","LEX.0F.W1 01 /6","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Loads r/m in machine status word of CR0."
"LODSB al, psi","LEX.WB AC rep","Valid","Valid","Valid","","RAX (w)","RSI (r)","","","","Load byte at address DS:SI/ESI/RSI into AL. "
"LODSD aw, psi","LEX.WX AD o32 rep","Valid","Valid","Valid","","RAX (w)","RSI (r)","","","","Load dword at address DS:SI/ESI/RSI into EAX."
"LODSQ aw, psi","LEX.WX AD o64 rep","Valid","Invalid","Invalid","","RAX (w)","RSI (r)","","","","Load qword at address DS:RSI into RAX."
"LODSW aw, psi","LEX.WX AD o16 rep","Valid","Valid","Valid","","RAX (w)","RSI (r)","","","","Load word at address DS:SI/ESI/RSI into AX."
"LOOP rel8","LEX.WN E2 ib","Valid","Valid","Valid","","ib","RCX (r, w)","","","","Decrement count; jump short if count !=0."
"LOOPE rel8","LEX.WN E1 ib","Valid","Valid","Valid","","ib","RCX (r, w)","","","","Decrement count; jump short if count !=0 and ZF = 1."
"LOOPNE rel8","LEX.WN E0 ib","Valid","Valid","Valid","","ib","RCX (r, w)","","","","Decrement count; jump short if count !=0 and ZF = 0."
"LOOPNZ rel8","LEX.WN E0 ib","Valid","Valid","Valid","","ib","RCX (r, w)","","","","Decrement count; jump short if count !=0 and ZF = 0."
"LOOPZ rel8","LEX.WN E1 ib","Valid","Valid","Valid","","ib","RCX (r, w)","","","","Decrement count; jump short if count !=0 and ZF = 0."
"LSL r32, r16/m16","LEX.0F.W0 03 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load: r := segment limit, selector r/m."
"LSL r64, r16/m16","LEX.0F.W1 03 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load: r := segment limit, selector r/m"
"LSS r16, memfar16:16","LEX.0F.WX B2 /r o16","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load SS:r16 with far pointer from memory."
"LSS r32, memfar16:32","LEX.0F.WX B2 /r o32","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load SS:r32 with far pointer from memory."
"LSS r64, memfar16:64","LEX.0F.WX B2 /r o64","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Load SS:r64 with far pointer from memory."
"LTR r32/m16","LEX.0F.W0 00 /3","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Load r/m into task register."
"LTR r64/m16","LEX.0F.W1 00 /3","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Load r/m into task register."
"MASKMOVQ mm1, mm2","LEX.0F.W0 F7 /r","Valid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r)","RDI (r)","","","Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:DI/EDI/RDI."
"MFENCE","LEX.0F.W0 AE F0","Valid","Valid","Valid","","","","","","","Serializes load and store operations."
"MONITOR","LEX.0F.W0 01 C8","Valid","Valid","Valid","","RAX (r)","","","","","Sets up a linear address range to be monitored by hardware and activates the monitor. The address range should be a write- back memory caching type. The address is DS:AX/EAX/RAX."
"MOV ra, CR0-CR15","LEX.0F.W0 20 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move control register to r (only CR0-CR8 are supported)."
"MOV ra, DR0-DR7","LEX.0F.W0 21 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move debug register to r."
"MOV CR0-CR15, ra","LEX.0F.W0 22 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move r to control register (only CR0-CR8 are supported)."
"MOV DR0-DR7, ra","LEX.0F.W0 23 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move r to debug register."
"MOV r8/m8, r8","LEX.WB 88 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move r8 to r8/m8."
"MOV rw/mw, rw","LEX.WX 89 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move r to r/m."
"MOV r8, r8/m8","LEX.WB 8A /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move r8/m8 to r8."
"MOV rw, rw/mw","LEX.WX 8B /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move r/m to r."
"MOV r32/m16, Sreg","LEX.WN 8C /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move segment register to r/m."
"MOV Sreg, r32/m16","LEX.WN 8E /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move r/m to segment register."
"MOVABS al, moffs","LEX.WB A0 iw","Invalid","Valid","Valid","","RAX (w)","iw","","","","Move byte at (seg:offset) to AL."
"MOVABS al, moffs","LEX.WB A0 i64","Valid","Invalid","Invalid","","RAX (w)","i64","","","","Move byte at (offset) to AL."
"MOVABS aw, moffs","LEX.WX A1 iw","Invalid","Valid","Valid","","RAX (w)","iw","","","","Move word at (seg:offset) to AX/EAX."
"MOVABS aw, moffs","LEX.WX A1 i64","Valid","Invalid","Invalid","","RAX (w)","i64","","","","Move quadword at (offset) to RAX."
"MOVABS moffs, al","LEX.WB A2 iw","Invalid","Valid","Valid","","iw","RAX (r)","","","","Move AL to byte at (seg:offset)."
"MOVABS moffs, al","LEX.WB A2 i64","Valid","Invalid","Invalid","","i64","RAX (r)","","","","Move AL to byte at (offset)."
"MOVABS moffs, aw","LEX.WX A3 iw","Invalid","Valid","Valid","","iw","RAX (r)","","","","Move AX/EAX to word at (seg:offset)."
"MOVABS moffs, aw","LEX.WX A3 i64","Valid","Invalid","Invalid","","i64","RAX (r)","","","","Move RAX to (offset)."
"MOV r8, ib","LEX.WB B0+r ib","Valid","Valid","Valid","","opcode +r (w)","ib","","","","Move ib to r8."
"MOV rw, i16","LEX.WX B8+r i16 o16","Valid","Valid","Valid","","opcode +r (w)","iw","","","","Move iw to r."
"MOV rw, i32","LEX.WX B8+r i32 o32","Valid","Valid","Valid","","opcode +r (w)","iw","","","","Move iw to r."
"MOVABS rw, i64","LEX.WX B8+r i64 o64","Valid","Invalid","Invalid","","opcode +r (w)","i64","","","","Move iq to r."
"MOV r8/m8, ib","LEX.WB C6 /0 ib","Valid","Valid","Valid","","ModRM:r/m (w)","ib","","","","Move ib to r8/m8."
"MOV rw/mw, iw","LEX.WX C7 /0 iw","Valid","Valid","Valid","","ModRM:r/m (w)","iw","","","","Move iw to r/m."
"MOVBE rw, mw","LEX.0F38.W0 F0 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Reverse byte order in m and move to r."
"MOVBE rw, mw","LEX.0F38.W1 F0 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Reverse byte order in m and move to r."
"MOVBE mw, rw","LEX.0F38.W0 F1 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Reverse byte order in r and move to m."
"MOVBE mw, rw","LEX.0F38.W1 F1 /r","Valid","Invalid","Invalid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Reverse byte order in r and move to m."
"MOVDQ2Q mm, xmm","LEX.F2.0F.W0 D6 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move low quadword from xmm to mmx register."
"MOVNTI mw, rw","LEX.0F.W0 C3 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move doubleword from r to m using non- temporal hint."
"MOVNTI mw, rw","LEX.0F.W1 C3 /r","Valid","Invalid","Invalid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from r to m using non- temporal hint."
"MOVNTQ m64, mm","LEX.0F.W0 E7 /r","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Move quadword from mm to m64 using non- temporal hint."
"MOVQ2DQ xmm, mm","LEX.F3.0F.W0 D6 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move quadword from mmx to low quadword of xmm."
"MOVSB pdi, psi","LEX.WB A4 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","For legacy mode, Move byte from address DS:SI/ESI/RSI to ES:DI/EDI/RDI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
"MOVSD pdi, psi","LEX.WX A5 o32 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","For legacy mode, move dword from address DS:SI/ESI/RSI to ES:DI/EDI/RDI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
"MOVSQ pdi, psi","LEX.WX A5 o64 rep","Valid","Invalid","Invalid","","RDI (r)","RSI (r)","","","","Move qword from address RSI to RDI."
"MOVSW pdi, psi","LEX.WX A5 o16 rep","Valid","Valid","Valid","","RDI (r)","RSI (r)","","","","For legacy mode, move word from address DS:SI/ESI/RSI to ES:DI/EDI/RDI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
"MOVSX rw, r8/m8","LEX.0F.W0 BE /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move byte to doubleword with sign-extension."
"MOVSX rw, r8/m8","LEX.0F.W1 BE /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move byte to quadword with sign-extension."
"MOVSX r32, r16/m16","LEX.0F.W0 BF /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move word to doubleword, with sign-extension."
"MOVSX r64, r16/m16","LEX.0F.W1 BF /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move word to quadword with sign-extension."
"MOVSXD r64, r32/m32","LEX.W1 63 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move doubleword to quadword with sign-extension."
"MOVZX rw, r8/m8","LEX.0F.W0 B6 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move byte to doubleword, zero-extension."
"MOVZX rw, r8/m8","LEX.0F.W1 B6 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move byte to quadword, zero-extension."
"MOVZX rw, r16/m16","LEX.0F.W0 B7 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move word to doubleword, zero-extension."
"MOVZX rw, r16/m16","LEX.0F.W1 B7 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Move word to quadword, zero-extension."
"MUL r8/m8","LEX.WB F6 /4","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Unsigned multiply (AX := AL * r8/m8)."
"MUL rw/mw","LEX.WX F7 /4","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Unsigned multiply (DX/EDX/RDX:AX/EAX/RAX := AX/EAX/RAX * r/m)."
"MWAIT","LEX.0F.W0 01 C9","Valid","Valid","Valid","","RAX (r)","RCX (r)","","","","A hint that allow the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events."
"NEG r8/m8","LEX.WB F6 /3 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Two's complement negate r8/m8."
"NEG rw/mw","LEX.WX F7 /3 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Two's complement negate r/m."
"NOP rw/mw","LEX.0F.W0 1F /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Multi-byte no-operation instruction."
"NOP","LEX.WN 90 norexb","Valid","Valid","Valid","","","","","","","One byte no-operation instruction."
"NOT r8/m8","LEX.WB F6 /2 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Reverse each bit of r8/m8."
"NOT rw/mw","LEX.WX F7 /2 lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","","","","","Reverse each bit of r/m."
"OR r8/m8, r8","LEX.WB 08 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r8/m8 OR r8."
"OR rw/mw, rw","LEX.WX 09 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r/m OR r."
"OR r8, r8/m8","LEX.WB 0A /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r8 OR r8/m8."
"OR rw, rw/mw","LEX.WX 0B /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r OR r/m."
"OR al, ib","LEX.WN 0C ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","AL OR ib."
"OR aw, iw","LEX.WX 0D iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","EAX OR sign-extended iw."
"OR r8/m8, ib","LEX.WB 80 /1 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r8/m8 OR ib."
"OR rw/mw, iw","LEX.WX 81 /1 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","r/m OR iw."
"OR rw/mw, ib","LEX.WX 83 /1 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r/m OR ib (sign-extended)."
"OUT ib, al","LEX.WB E6 ib","Valid","Valid","Valid","","ib","RAX (r)","","","","Output byte in AL to I/O port address ib."
"OUT ib, aw","LEX.WX E7 ib o32","Valid","Valid","Valid","","ib","RAX (r)","","","","Output word in AX/EAX/RAX to I/O port address ib."
"OUT dx, al","LEX.WB EE","Valid","Valid","Valid","","RDX (r)","RAX (r)","","","","Output byte in AL to I/O port address in DX."
"OUT dx, aw","LEX.WX EF o32","Valid","Valid","Valid","","RDX (r)","RAX (r)","","","","Output word in AX/EAX/RAX to I/O port address in DX."
"OUTSB dx, psi","LEX.WB 6E rep","Valid","Valid","Valid","","RDX (r)","RSI (r)","","","","Output byte from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."
"OUTSD dx, psi","LEX.WX 6F o32 rep","Valid","Valid","Valid","","RDX (r)","RSI (r)","","","","Output doubleword from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."
"OUTSW dx, psi","LEX.WX 6F o16 rep","Valid","Valid","Valid","","RDX (r)","RSI (r)","","","","Output word from memory location specified in DS:(E)SI or RSI to I/O port specified in DX."
"PAUSE","LEX.F3.WN 90 norexb","Valid","Valid","Valid","","","","","","","Gives hint to processor that improves performance of spin-wait loops."
"POP ES","LEX.WN 07","Invalid","Valid","Valid","","SEG (w)","RSP (r, w, i)","","","","Pop top of stack into ES; increment stack pointer."
"POP SS","LEX.WN 17","Invalid","Valid","Valid","","SEG (w)","RSP (r, w, i)","","","","Pop top of stack into SS; increment stack pointer."
"POP DS","LEX.WN 1F","Invalid","Valid","Valid","","SEG (w)","RSP (r, w, i)","","","","Pop top of stack into DS; increment stack pointer."
"POP rw","LEX.WW 58+r","Valid","Valid","Valid","","opcode +r (w)","RSP (r, w, i)","","","","Pop top of stack into r16; increment stack pointer."
"POP rw/mw","LEX.WW 8F /0","Valid","Valid","Valid","","ModRM:r/m (w)","RSP (r, w, i)","","","","Pop top of stack into r/m; increment stack pointer."
"POP FS","LEX.0F.W0 A1","Valid","Valid","Valid","","SEG (w)","RSP (r, w, i)","","","","Pop top of stack into FS; increment stack pointer."
"POP GS","LEX.0F.W0 A9","Valid","Valid","Valid","","SEG (w)","RSP (r, w, i)","","","","Pop top of stack into GS; increment stack pointer."
"POPA","LEX.WW 61","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Pop [E]DI, [E]SI, [E]BP, [E]BX, [E]DX, [E]CX, and [E]AX."
"POPAD","LEX.WW 61 o32","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX."
"POPAW","LEX.WW 61 o16","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Pop DI, SI, BP, BX, DX, CX, and AX."
"POPCNT rw, rw/mw","LEX.F3.0F.W0 B8 /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","POPCNT on r/m"
"POPCNT rw, rw/mw","LEX.F3.0F.W1 B8 /r","Valid","Invalid","Invalid","","ModRM:reg (w)","ModRM:r/m (r)","","","","POPCNT on r/m"
"POPFD","LEX.WW 9D o32","Invalid","Valid","Valid","","RFLAGS (w, i)","RSP (r, w, i)","","","","Pop word from stack into EFLAGS."
"POPFQ","LEX.WW 9D o64","Valid","Invalid","Invalid","","RFLAGS (w, i)","RSP (r, w, i)","","","","Pop word from stack into RFLAGS."
"POPFW","LEX.WW 9D o16","Valid","Valid","Valid","","RFLAGS (w, i)","RSP (r, w, i)","","","","Pop word from stack into FLAGS."
"PSHUFW mm1, mm2/m64, ib","LEX.0F.W0 70 /r ib","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","ib","","","Shuffle the words in mm2/m64 based on the encoding in ib and store the result in mm1."
"PTWRITE rw/mw","LEX.F3.0F.W0 AE /4","Valid","Valid","Invalid","","ModRM:r/m (r)","","","","","Reads the data from r/m to encode into a PTW packet if dependencies are met (see details below)."
"PTWRITE rw/mw","LEX.F3.0F.W1 AE /4","Valid","Invalid","Invalid","","ModRM:r/m (r)","","","","","Reads the data from r/m to encod into a PTW packet if dependencies are met (see details below)."
"PUSH ES","LEX.WN 06","Invalid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push ES."
"PUSH CS","LEX.WN 0E","Invalid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push CS."
"PUSH SS","LEX.WN 16","Invalid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push SS."
"PUSH DS","LEX.WN 1E","Invalid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push DS."
"PUSH rw","LEX.WW 50+r","Valid","Valid","Valid","","opcode +r (r)","RSP (r, w, i)","","","","Push r."
"PUSH iw","LEX.WN 68 iw","Valid","Valid","Valid","","iw","RSP (r, w, i)","","","","Push iw."
"PUSH ib","LEX.WN 6A ib","Valid","Valid","Valid","","ib","RSP (r, w, i)","","","","Push ib."
"PUSH FS","LEX.0F.W0 A0","Valid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push FS."
"PUSH GS","LEX.0F.W0 A8","Valid","Valid","Valid","","SEG (r)","RSP (r, w, i)","","","","Push GS."
"PUSH rw/mw","LEX.WW FF /6","Valid","Valid","Valid","","ModRM:r/m (r)","RSP (r, w, i)","","","","Push r/m."
"PUSHA","LEX.WW 60","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Push [E]AX, [E]CX, [E]DX, [E]BX, original [E]SP, [E]BP, [E]SI, and [E]DI."
"PUSHAD","LEX.WW 60 o32","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Push [E]AX, [E]CX, [E]DX, [E]BX, original [E]SP, [E]BP, [E]SI, and [E]DI."
"PUSHAW","LEX.WW 60 o16","Invalid","Valid","Valid","","RSP (r, w, i)","","","","","Push [E]AX, [E]CX, [E]DX, [E]BX, original [E]SP, [E]BP, [E]SI, and [E]DI."
"PUSHFD","LEX.WW 9C o32","Invalid","Valid","Valid","","RFLAGS (r, i)","RSP (r, w, i)","","","","Push EFLAGS word onto the stack."
"PUSHFQ","LEX.WW 9C o64","Valid","Invalid","Invalid","","RFLAGS (r, i)","RSP (r, w, i)","","","","Push RFLAGS word onto the stack."
"PUSHFW","LEX.WW 9C o16","Valid","Valid","Valid","","RFLAGS (r, i)","RSP (r, w, i)","","","","Push FLAGS word onto the stack."
"RCL r8/m8, ib","LEX.WB C0 /2 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 9 bits (CF, r8/m8) left ib times."
"RCL rw/mw, ib","LEX.WX C1 /2 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 33 bits (CF, r/m) left ib times."
"RCL r8/m8","LEX.WB D0 /2","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 9 bits (CF, r8/m8) left once."
"RCL rw/mw","LEX.WX D1 /2","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 33 bits (CF, r/m) left once."
"RCL r8/m8, CL","LEX.WB D2 /2","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 9 bits (CF, r8/m8) left CL times."
"RCL rw/mw, CL","LEX.WX D3 /2","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 33 bits (CF, r/m) left CL times."
"RCR r8/m8, ib","LEX.WB C0 /3 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 9 bits (CF, r8/m8) right ib times."
"RCR rw/mw, ib","LEX.WX C1 /3 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 33 bits (CF, r/m) right ib times."
"RCR r8/m8","LEX.WB D0 /3","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 9 bits (CF, r8/m8) right once."
"RCR rw/mw","LEX.WX D1 /3","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 33 bits (CF, r/m) right once. Uses a 6 bit count."
"RCR r8/m8, CL","LEX.WB D2 /3","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 9 bits (CF, r8/m8) right CL times."
"RCR rw/mw, CL","LEX.WX D3 /3","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 33 bits (CF, r/m) right CL times."
"RDMSR","LEX.0F.W0 32","Valid","Valid","Valid","","","","","","","Read MSR specified by ECX into EDX:EAX."
"RDPMC","LEX.0F.W0 33","Valid","Valid","Valid","","","","","","","Read performance-monitoring counter specified by ECX into EDX:EAX."
"RDTSC","LEX.0F.W0 31","Valid","Valid","Valid","","","","","","","Read time-stamp counter into EDX:EAX."
"RDTSCP","LEX.0F.W0 01 F9","Valid","Valid","Valid","","","","","","","Read 64-bit time-stamp counter and IA32_TSC_AUX value into EDX:EAX and ECX."
"RET","LEX.WW C3","Valid","Valid","Valid","","RSP (r, w, i)","","","","","Near return to calling procedure."
"RETF","LEX.WW CB","Valid","Valid","Valid","","RSP (r, w, i)","","","","","Far return to calling procedure."
"RETF i16","LEX.WW CA i16","Valid","Valid","Valid","","i16","RSP (r, w, i)","","","","Far return to calling procedure and pop iw bytes from stack."
"RET i16","LEX.WW C2 i16","Valid","Valid","Valid","","i16","RSP (r, w, i)","","","","Near return to calling procedure and pop iw bytes from stack."
"ROL r8/m8, ib","LEX.WB C0 /0 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 8 bits r8/m8 left ib times."
"ROL rw/mw, ib","LEX.WX C1 /0 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 32 bits r/m left ib times."
"ROL r8/m8","LEX.WB D0 /0","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 8 bits r8/m8 left once."
"ROL rw/mw","LEX.WX D1 /0","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 32 bits r/m left once."
"ROL r8/m8, CL","LEX.WB D2 /0","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 8 bits r8/m8 left CL times."
"ROL rw/mw, CL","LEX.WX D3 /0","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 32 bits r/m left CL times."
"ROR r8/m8, ib","LEX.WB C0 /1 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 8 bits r8/m8 right ib times."
"ROR rw/mw, ib","LEX.WX C1 /1 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Rotate 32 bits r/m right ib times."
"ROR r8/m8","LEX.WB D0 /1","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 8 bits r8/m8 right once."
"ROR rw/mw","LEX.WX D1 /1","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Rotate 32 bits r/m right once."
"ROR r8/m8, CL","LEX.WB D2 /1","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 8 bits r8/m8 right CL times."
"ROR rw/mw, CL","LEX.WX D3 /1","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Rotate 32 bits r/m right CL times."
"RSM","LEX.0F.W0 AA","Valid","Valid","Valid","","","","","","","Resume operation of interrupted program."
"SAHF ah","LEX.WN 9E","Invalid","Valid","Valid","","RAX (r)","","","","","Loads SF, ZF, AF, PF, and CF from AH into EFLAGS register."
"SAR r8/m8, ib","LEX.WB C0 /7 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Signed divide r8/m8 by 2, ib time."
"SAR rw/mw, ib","LEX.WX C1 /7 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Signed divide r/m by 2, ib times."
"SAR r8/m8","LEX.WB D0 /7","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Signed divide r8/m8 by 2, once."
"SAR rw/mw","LEX.WX D1 /7","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Signed divide r/m by 2, once."
"SAR r8/m8, CL","LEX.WB D2 /7","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Signed divide r8/m8 by 2, CL times."
"SAR rw/mw, CL","LEX.WX D3 /7","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Signed divide r/m by 2, CL times."
"SBB r8/m8, r8","LEX.WB 18 /r lock","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Subtract with borrow r8 from r8/m8."
"SBB rw/mw, rw","LEX.WX 19 /r lock","Valid","Valid","Valid","","ModRM:r/m (w)","ModRM:reg (r)","","","","Subtract with borrow r from r/m."
"SBB r8, r8/m8","LEX.WB 1A /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Subtract with borrow r8/m8 from r8."
"SBB rw, rw/mw","LEX.WX 1B /r","Valid","Valid","Valid","","ModRM:reg (w)","ModRM:r/m (r)","","","","Subtract with borrow r/m from r."
"SBB al, ib","LEX.WN 1C ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","Subtract with borrow ib from AL."
"SBB aw, iw","LEX.WX 1D iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","Subtract with borrow iw from EAX."
"SBB r8/m8, ib","LEX.WB 80 /3 ib lock","Valid","Valid","Valid","","ModRM:r/m (w)","ib","","","","Subtract with borrow ib from r8/m8."
"SBB rw/mw, iw","LEX.WX 81 /3 iw lock","Valid","Valid","Valid","","ModRM:r/m (w)","iw","","","","Subtract with borrow iw from r/m."
"SBB rw/mw, ib","LEX.WX 83 /3 ib lock","Valid","Valid","Valid","","ModRM:r/m (w)","ib","","","","Subtract with borrow sign-extended ib from r/m."
"SCASB al, pdi","LEX.WB AE rep","Valid","Valid","Valid","","RAX (r)","RDI (r)","","","","Compare AL with byte at ES:DI/EDI/RDI then set status flags."
"SCASD aw, pdi","LEX.WX AF o32 rep","Valid","Valid","Valid","","RAX (r)","RDI (r)","","","","Compare EAX with dword at ES:DI/EDI/RDI  then set status flags."
"SCASQ aw, pdi","LEX.WX AF o64 rep","Valid","Invalid","Invalid","","RAX (r)","RDI (r)","","","","Compare RAX with quadword at ES:RDI then set status flags."
"SCASW aw, pdi","LEX.WX AF o16 rep","Valid","Valid","Valid","","RAX (r)","RDI (r)","","","","Compare AX with word at ES:DI/EDI/RDI then set status flags."
"SETA r8/m8","LEX.0F.WB 97 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if above (CF=0 and ZF=0)."
"SETAE r8/m8","LEX.0F.WB 93 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if above or equal (CF=0)."
"SETB r8/m8","LEX.0F.WB 92 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if below (CF=1)."
"SETBE r8/m8","LEX.0F.WB 96 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if below or equal (CF=1 or ZF=1)."
"SETC r8/m8","LEX.0F.WB 92 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if carry (CF=1)."
"SETE r8/m8","LEX.0F.WB 94 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if equal (ZF=1)."
"SETG r8/m8","LEX.0F.WB 9F /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if greater (ZF=0 and SF=OF)."
"SETGE r8/m8","LEX.0F.WB 9D /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if greater or equal (SF=OF)."
"SETL r8/m8","LEX.0F.WB 9C /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if less (SF!=OF)."
"SETLE r8/m8","LEX.0F.WB 9E /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if less or equal (ZF=1 or SF!=OF)."
"SETNA r8/m8","LEX.0F.WB 96 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not above (CF=1 or ZF=1)."
"SETNAE r8/m8","LEX.0F.WB 92 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not above or equal (CF=1)."
"SETNB r8/m8","LEX.0F.WB 93 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not below (CF=0)."
"SETNBE r8/m8","LEX.0F.WB 97 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not below or equal (CF=0 and ZF=0)."
"SETNC r8/m8","LEX.0F.WB 93 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not carry (CF=0)."
"SETNE r8/m8","LEX.0F.WB 95 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not equal (ZF=0)."
"SETNG r8/m8","LEX.0F.WB 9E /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not greater (ZF=1 or SF!=OF)"
"SETNGE r8/m8","LEX.0F.WB 9C /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not greater or equal (SF!=OF)."
"SETNL r8/m8","LEX.0F.WB 9D /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not less (SF=OF)."
"SETNLE r8/m8","LEX.0F.WB 9F /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not less or equal (ZF=0 and SF=OF)."
"SETNO r8/m8","LEX.0F.WB 91 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not overflow (OF=0)."
"SETNP r8/m8","LEX.0F.WB 9B /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not parity (PF=0)."
"SETNS r8/m8","LEX.0F.WB 99 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not sign (SF=0)."
"SETNZ r8/m8","LEX.0F.WB 95 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if not zero (ZF=0)."
"SETO r8/m8","LEX.0F.WB 90 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if overflow (OF=1)."
"SETP r8/m8","LEX.0F.WB 9A /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if parity (PF=1)."
"SETPE r8/m8","LEX.0F.WB 9A /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if parity even (PF=1)."
"SETPO r8/m8","LEX.0F.WB 9B /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if parity odd (PF=0)."
"SETS r8/m8","LEX.0F.WB 98 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if sign (SF=1)."
"SETZ r8/m8","LEX.0F.WB 94 /0","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set byte if zero (ZF=1)."
"SFENCE","LEX.0F.W0 AE F8","Valid","Valid","Valid","","","","","","","Serializes store operations."
"SGDT m","LEX.0F.W0 01 /0","Valid","Valid","Valid","","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","","","","","Store GDTR to m."
"SHL r8/m8, ib","LEX.WB C0 /4 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Multiply r8/m8 by 2, ib times."
"SHL rw/mw, ib","LEX.WX C1 /4 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Multiply r/m by 2, ib times."
"SHL r8/m8","LEX.WB D0 /4","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Multiply r8/m8 by 2, once."
"SHL rw/mw","LEX.WX D1 /4","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Multiply r/m by 2, once."
"SHL r8/m8, CL","LEX.WB D2 /4","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Multiply r8/m8 by 2, CL times."
"SHL rw/mw, CL","LEX.WX D3 /4","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Multiply r/m by 2, CL times."
"SHLD rw/mw, rw, ib","LEX.0F.W0 A4 /r ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","ib","","","Shift r/m to left ib places while shifting bits from r in from the right."
"SHLD rw/mw, rw, ib","LEX.0F.W1 A4 /r ib","Valid","Invalid","Invalid","","ModRM:r/m (r, w)","ModRM:reg (r)","ib","","","Shift r/m to left ib places while shifting bits from r in from the right."
"SHLD rw/mw, rw, CL","LEX.0F.W0 A5 /r","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","RCX (r)","","","Shift r/m to left CL places while shifting bits from r in from the right."
"SHLD rw/mw, rw, CL","LEX.0F.W1 A5 /r","Valid","Invalid","Invalid","","ModRM:r/m (r, w)","ModRM:reg (r)","RCX (r)","","","Shift r/m to left CL places while shifting bits from r in from the right."
"SHR r8/m8, ib","LEX.WB C0 /5 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Unsigned divide r8/m8 by 2, ib times."
"SHR rw/mw, ib","LEX.WX C1 /5 ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Unsigned divide r/m by 2, ib times."
"SHR r8/m8","LEX.WB D0 /5","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Unsigned divide r8/m8 by 2, once."
"SHR rw/mw","LEX.WX D1 /5","Valid","Valid","Valid","","ModRM:r/m (r, w)","1","","","","Unsigned divide r/m by 2, once."
"SHR r8/m8, CL","LEX.WB D2 /5","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Unsigned divide r8/m8 by 2, CL times."
"SHR rw/mw, CL","LEX.WX D3 /5","Valid","Valid","Valid","","ModRM:r/m (r, w)","RCX (r)","","","","Unsigned divide r/m by 2, CL times."
"SHRD rw/mw, rw, ib","LEX.0F.W0 AC /r ib","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","ib","","","Shift r/m to right ib places while shifting bits from r in from the left."
"SHRD rw/mw, rw, ib","LEX.0F.W1 AC /r ib","Valid","Invalid","Invalid","","ModRM:r/m (r, w)","ModRM:reg (r)","ib","","","Shift r/m to right ib places while shifting bits from r in from the left."
"SHRD rw/mw, rw, CL","LEX.0F.W0 AD /r","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","RCX (r)","","","Shift r/m to right CL places while shifting bits from r in from the left."
"SHRD rw/mw, rw, CL","LEX.0F.W1 AD /r","Valid","Invalid","Invalid","","ModRM:r/m (r, w)","ModRM:reg (r)","RCX (r)","","","Shift r/m to right CL places while shifting bits from r in from the left."
"SIDT m","LEX.0F.W0 01 /1","Valid","Valid","Valid","","ModRM:r/m (w, ModRM:[7:6] must not be 11b)","","","","","Store IDTR to m."
"SLDT r32/m16","LEX.0F.W0 00 /0","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Stores segment selector from LDTR in r/m."
"SLDT r64/m16","LEX.0F.W1 00 /0","Valid","Invalid","Invalid","","ModRM:r/m (w)","","","","","Stores segment selector from LDTR in r/m."
"SMSW r32/m16","LEX.0F.W0 01 /4","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Store machine status word to r/m."
"SMSW r64/m16","LEX.0F.W1 01 /4","Valid","Invalid","Invalid","","ModRM:r/m (w)","","","","","Store machine status to r/m."
"STC","LEX.WN F9","Valid","Valid","Valid","","","","","","","Set CF flag."
"STD","LEX.WN FD","Valid","Valid","Valid","","","","","","","Set DF flag."
"STI","LEX.WN FB","Valid","Valid","Valid","","","","","","","Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction."
"STOSB pdi, al","LEX.WB AA rep","Valid","Valid","Valid","","RDI (r)","RAX (r)","","","","For legacy mode, store AL at address ES:DI/EDI/RDI."
"STOSD pdi, aw","LEX.WX AB o32 rep","Valid","Valid","Valid","","RDI (r)","RAX (r)","","","","For legacy mode, store EAX at address ES:DI/EDI/RDI."
"STOSQ pdi, aw","LEX.WX AB o64 rep","Valid","Invalid","Invalid","","RDI (r)","RAX (r)","","","","Store RAX at address ES:RDI."
"STOSW pdi, aw","LEX.WX AB o16 rep","Valid","Valid","Valid","","RDI (r)","RAX (r)","","","","For legacy mode, store AX at address ES:DI/EDI/RDI."
"STR r32/m16","LEX.0F.W0 00 /1","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Stores segment selector from TR in r/m."
"STR r64/m16","LEX.0F.W1 00 /1","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Stores segment selector from TR in r/m."
"SUB r8/m8, r8","LEX.WB 28 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Subtract r8 from r8/m8."
"SUB rw/mw, rw","LEX.WX 29 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Subtract r from r/m."
"SUB r8, r8/m8","LEX.WB 2A /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract r8/m8 from r8."
"SUB rw, rw/mw","LEX.WX 2B /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","Subtract r/m from r."
"SUB al, ib","LEX.WN 2C ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","Subtract ib from AL."
"SUB aw, iw","LEX.WX 2D iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","Subtract sign-extend iw from AX/EAX/RAX."
"SUB r8/m8, ib","LEX.WB 80 /5 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Subtract ib from r8/m8."
"SUB rw/mw, iw","LEX.WX 81 /5 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","Subtract iw from r/m."
"SUB rw/mw, ib","LEX.WX 83 /5 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","Subtract sign-extended ib from r/m."
"SWAPGS","LEX.0F.W0 01 F8","Valid","Invalid","Invalid","","","","","","","Exchanges the current GS base register value with the value contained in MSR address C0000102H."
"SYSCALL","LEX.0F.W0 05","Valid","Invalid","Invalid","","","","","","","Fast call to privilege level 0 system procedures."
"SYSENTER","LEX.0F.W0 34","Valid","Valid","Valid","","","","","","","Fast call to privilege level 0 system procedures."
"SYSEXIT","LEX.0F.W0 35","Valid","Valid","Valid","","","","","","","Fast return to privilege level 3 user code."
"SYSEXITQ","LEX.0F.W1 35","Valid","Invalid","Invalid","","","","","","","Fast return to 64-bit mode privilege level 3 user code."
"SYSRET","LEX.0F.W0 07","Valid","Invalid","Invalid","","","","","","","Return to compatibility mode from fast system call"
"SYSRETQ","LEX.0F.W1 07","Valid","Invalid","Invalid","","","","","","","Return to 64-bit mode from fast system call"
"TEST r8/m8, r8","LEX.WB 84 /r","Valid","Valid","Valid","","ModRM:r/m (r)","ModRM:reg (r)","","","","AND r8 with r8/m8; set SF, ZF, PF according to result."
"TEST rw/mw, rw","LEX.WX 85 /r","Valid","Valid","Valid","","ModRM:r/m (r)","ModRM:reg (r)","","","","AND r with r/m; set SF, ZF, PF according to result."
"TEST al, ib","LEX.WN A8 ib","Valid","Valid","Valid","","RAX (r)","ib","","","","AND ib with AL; set SF, ZF, PF according to result."
"TEST aw, iw","LEX.WX A9 iw","Valid","Valid","Valid","","RAX (r)","iw","","","","AND iw with EAX; set SF, ZF, PF according to result."
"TEST r8/m8, ib","LEX.WB F6 /0 ib","Valid","Valid","Valid","","ModRM:r/m (r)","ib","","","","AND ib with r8/m8; set SF, ZF, PF according to result."
"TEST rw/mw, iw","LEX.WX F7 /0 iw","Valid","Valid","Valid","","ModRM:r/m (r)","iw","","","","AND iw with r/m; set SF, ZF, PF according to result."
"UD0 rw, rw/mw","LEX.0F.W0 FF /r","Valid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r)","","","","Raise invalid opcode exception."
"UD1 rw, rw/mw","LEX.0F.W0 B9 /r","Valid","Valid","Valid","","ModRM:reg (r)","ModRM:r/m (r)","","","","Raise invalid opcode exception."
"UD2","LEX.0F.W0 0B","Valid","Valid","Valid","","","","","","","Raise invalid opcode exception."
"VERR r16/m16","LEX.0F.W0 00 /4","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set ZF=1 if segment specified with r/m can be read."
"VERW r16/m16","LEX.0F.W0 00 /5","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Set ZF=1 if segment specified with r/m can be written."
"WBINVD","LEX.0F.W0 09","Valid","Valid","Valid","","","","","","","Write back and flush Internal caches; initiate writing-back and flushing of external caches."
"WRMSR","LEX.0F.W0 30","Valid","Valid","Valid","","","","","","","Write the value in EDX:EAX to MSR specified by ECX."
"XADD r8/m8, r8","LEX.0F.W0 C0 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r, w)","","","","Exchange r8 and r8/m8; load sum into r8/m8."
"XADD rw/mw, rw","LEX.0F.WX C1 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r, w)","","","","Exchange r and r/m; load sum into r/m."
"XCHG r8/m8, r8","LEX.WB 86 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Exchange r8 (byte register) with byte from r8/m8."
"XCHG rw/mw, rw","LEX.WX 87 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","Exchange r with doubleword from r/m."
"XCHG rw, aw","LEX.WX 90+r","Valid","Valid","Valid","","opcode +r (r, w)","RAX (r, w)","","","","Exchange AX/EAX/RAX with r."
"XGETBV","LEX.0F.W0 01 D0","Valid","Valid","Valid","","","","","","","Reads an XCR specified by ECX into EDX:EAX."
"XLATB","LEX.WN D7","Valid","Valid","Valid","","","RAX (r, w)","RBX (r)","","","Set AL to memory byte DS:[(E)BX + unsigned AL]."
"XOR r8/m8, r8","LEX.WB 30 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r8/m8 XOR r8."
"XOR rw/mw, rw","LEX.WX 31 /r lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ModRM:reg (r)","","","","r/m XOR r."
"XOR r8, r8/m8","LEX.WB 32 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r8 XOR r8/m8."
"XOR rw, rw/mw","LEX.WX 33 /r","Valid","Valid","Valid","","ModRM:reg (r, w)","ModRM:r/m (r)","","","","r XOR r/m."
"XOR al, ib","LEX.WN 34 ib","Valid","Valid","Valid","","RAX (r, w)","ib","","","","AL XOR ib."
"XOR aw, iw","LEX.WX 35 iw","Valid","Valid","Valid","","RAX (r, w)","iw","","","","AX/EAX/RAX XOR sign-extend iw."
"XOR r8/m8, ib","LEX.WB 80 /6 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r8/m8 XOR ib."
"XOR rw/mw, iw","LEX.WX 81 /6 iw lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","iw","","","","r/m XOR sign-extend iw."
"XOR rw/mw, ib","LEX.WX 83 /6 ib lock","Valid","Valid","Valid","","ModRM:r/m (r, w)","ib","","","","r/m XOR sign-extend ib."
"XRSTOR mem","LEX.0F.W0 AE /5","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Restore state components specified by EDX:EAX from mem."
"XRSTOR64 mem","LEX.0F.W1 AE /5","Valid","Invalid","Invalid","","ModRM:r/m (r)","","","","","Restore state components specified by EDX:EAX from mem."
"XRSTORS mem","LEX.0F.W0 C7 /3","Valid","Valid","Valid","","ModRM:r/m (r)","","","","","Restore state components specified by EDX:EAX from mem."
"XRSTORS64 mem","LEX.0F.W1 C7 /3","Valid","Invalid","Invalid","","ModRM:r/m (r)","","","","","Restore state components specified by EDX:EAX from mem."
"XSAVE mem","LEX.0F.W0 AE /4","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem."
"XSAVE64 mem","LEX.0F.W1 AE /4","Valid","Invalid","Invalid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem."
"XSAVEC mem","LEX.0F.W0 C7 /4","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem with compaction."
"XSAVEC64 mem","LEX.0F.W1 C7 /4","Valid","Invalid","Invalid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem with compaction."
"XSAVES mem","LEX.0F.W0 C7 /5","Valid","Valid","Valid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem with compaction, optimizing if possible."
"XSAVES64 mem","LEX.0F.W1 C7 /5","Valid","Invalid","Invalid","","ModRM:r/m (w)","","","","","Save state components specified by EDX:EAX to mem with compaction, optimizing if possible."
"XSETBV","LEX.0F.W0 01 D1","Valid","Valid","Valid","","","","","","","Write the value in EDX:EAX to the XCR specified by ECX."
