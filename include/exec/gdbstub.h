#ifndef GDBSTUB_H
#define GDBSTUB_H

#define DEFAULT_GDBSTUB_PORT "1234"

/* GDB breakpoint/watchpoint types */
#define GDB_BREAKPOINT_SW        0
#define GDB_BREAKPOINT_HW        1
#define GDB_WATCHPOINT_WRITE     2
#define GDB_WATCHPOINT_READ      3
#define GDB_WATCHPOINT_ACCESS    4

typedef struct GDBFeature {
    const char *xmlname;
    const char *xml;
    const char *name;
    const char * const *regs;
    int num_regs;
} GDBFeature;

typedef struct GDBFeatureBuilder {
    GDBFeature *feature;
    GPtrArray *xml;
    GPtrArray *regs;
    int base_reg;
} GDBFeatureBuilder;


/* Get or set a register.  Returns the size of the register.  */
typedef int (*gdb_get_reg_cb)(CPUState *cpu, GByteArray *buf, int reg);
typedef int (*gdb_set_reg_cb)(CPUState *cpu, uint8_t *buf, int reg);

/**
 * gdb_init_cpu(): Initialize the CPU for gdbstub.
 * @cpu: The CPU to be initialized.
 */
void gdb_init_cpu(CPUState *cpu);

/**
 * gdb_register_coprocessor() - register a supplemental set of registers
 * @cpu - the CPU associated with registers
 * @get_reg - get function (gdb reading)
 * @set_reg - set function (gdb modifying)
 * @num_regs - number of registers in set
 * @xml - xml name of set
 * @gpos - non-zero to append to "general" register set at @gpos
 */
void gdb_register_coprocessor(CPUState *cpu,
                              gdb_get_reg_cb get_reg, gdb_set_reg_cb set_reg,
                              const GDBFeature *feature, int g_pos);

/**
 * gdbserver_start: start the gdb server
 * @port_or_device: connection spec for gdb
 *
 * For CONFIG_USER this is either a tcp port or a path to a fifo. For
 * system emulation you can use a full chardev spec for your gdbserver
 * port.
 */
int gdbserver_start(const char *port_or_device);

/**
 * gdb_feature_builder_init() - Initialize GDBFeatureBuilder.
 * @builder: The builder to be initialized.
 * @feature: The feature to be filled.
 * @name: The name of the feature.
 * @xmlname: The name of the XML.
 * @base_reg: The base number of the register ID.
 */
void gdb_feature_builder_init(GDBFeatureBuilder *builder, GDBFeature *feature,
                              const char *name, const char *xmlname,
                              int base_reg);

/**
 * gdb_feature_builder_append_tag() - Append a tag.
 * @builder: The builder.
 * @format: The format of the tag.
 * @...: The values to be formatted.
 */
void G_GNUC_PRINTF(2, 3)
gdb_feature_builder_append_tag(const GDBFeatureBuilder *builder,
                               const char *format, ...);

/**
 * gdb_feature_builder_append_reg() - Append a register.
 * @builder: The builder.
 * @name: The register's name; it must be unique within a CPU.
 * @bitsize: The register's size, in bits.
 * @regnum: The offset of the register's number in the feature.
 * @type: The type of the register.
 * @group: The register group to which this register belongs; it can be NULL.
 */
void gdb_feature_builder_append_reg(const GDBFeatureBuilder *builder,
                                    const char *name,
                                    int bitsize,
                                    int regnum,
                                    const char *type,
                                    const char *group);

/**
 * gdb_feature_builder_end() - End building GDBFeature.
 * @builder: The builder.
 */
void gdb_feature_builder_end(const GDBFeatureBuilder *builder);

/**
 * gdb_find_static_feature() - Find a static feature.
 * @xmlname: The name of the XML.
 *
 * Return: The static feature.
 */
const GDBFeature *gdb_find_static_feature(const char *xmlname);

/**
 * gdb_read_register() - Read a register associated with a CPU.
 * @cpu: The CPU associated with the register.
 * @buf: The buffer that the read register will be appended to.
 * @reg: The register's number returned by gdb_find_feature_register().
 *
 * Return: The number of read bytes.
 */
int gdb_read_register(CPUState *cpu, GByteArray *buf, int reg);

/**
 * typedef GDBRegDesc - a register description from gdbstub
 */
typedef struct {
    int gdb_reg;
    const char *name;
    const char *feature_name;
} GDBRegDesc;

/**
 * gdb_get_register_list() - Return list of all registers for CPU
 * @cpu: The CPU being searched
 *
 * Returns a GArray of GDBRegDesc, caller frees array but not the
 * const strings.
 */
GArray *gdb_get_register_list(CPUState *cpu);

void gdb_set_stop_cpu(CPUState *cpu);

/* in gdbstub-xml.c, generated by scripts/feature_to_c.py */
extern const GDBFeature gdb_static_features[];

typedef void (*GdbCmdHandler)(GArray *params, void *user_ctx);

typedef enum GDBThreadIdKind {
    GDB_ONE_THREAD = 0,
    GDB_ALL_THREADS,     /* One process, all threads */
    GDB_ALL_PROCESSES,
    GDB_READ_THREAD_ERR
} GDBThreadIdKind;

typedef union GdbCmdVariant {
    const char *data;
    uint8_t opcode;
    unsigned long val_ul;
    unsigned long long val_ull;
    struct {
        GDBThreadIdKind kind;
        uint32_t pid;
        uint32_t tid;
    } thread_id;
} GdbCmdVariant;

#define get_param(p, i)    (&g_array_index(p, GdbCmdVariant, i))

/*
 * cmd_startswith -> cmd is compared using startswith
 *
 * allow_stop_reply -> true iff the gdbstub can respond to this command with a
 *   "stop reply" packet. The list of commands that accept such response is
 *   defined at the GDB Remote Serial Protocol documentation. see:
 *   https://sourceware.org/gdb/onlinedocs/gdb/Stop-Reply-Packets.html#Stop-Reply-Packets.
 *
 * schema definitions:
 * Each schema parameter entry consists of 2 chars,
 * the first char represents the parameter type handling
 * the second char represents the delimiter for the next parameter
 *
 * Currently supported schema types:
 * 'l' -> unsigned long (stored in .val_ul)
 * 'L' -> unsigned long long (stored in .val_ull)
 * 's' -> string (stored in .data)
 * 'o' -> single char (stored in .opcode)
 * 't' -> thread id (stored in .thread_id)
 * '?' -> skip according to delimiter
 *
 * Currently supported delimiters:
 * '?' -> Stop at any delimiter (",;:=\0")
 * '0' -> Stop at "\0"
 * '.' -> Skip 1 char unless reached "\0"
 * Any other value is treated as the delimiter value itself
 */
typedef struct GdbCmdParseEntry {
    GdbCmdHandler handler;
    const char *cmd;
    bool cmd_startswith;
    const char *schema;
    bool allow_stop_reply;
} GdbCmdParseEntry;

#define get_cmd_parsers(p) (&g_array_index(p, GdbCmdParseEntry, 0))

/**
 * set_gdb_gen_query_table_arch() - set a table to handle arch-specific query
 * packets
 */
void set_gdb_gen_query_table_arch(GdbCmdParseEntry *table, int size);

/**
 * set_gdb_gen_set_table_arch() - set a table to handle arch-specific set
 * packets
 */
void set_gdb_gen_set_table_arch(GdbCmdParseEntry *, int size);

/**
 * set_query_supported_arch() - set arch-specific features in qSupported
 * features
 */
void set_query_supported_arch(char *);

/**
 * gdb_put_packet() - put string into gdb server's buffer so it is sent
 * to the client
 */
int gdb_put_packet(const char *buf);

#endif /* GDBSTUB_H */
