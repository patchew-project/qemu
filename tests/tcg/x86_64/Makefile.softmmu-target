#
# x86 system tests
#
# This currently builds only for i386. The common C code is built
# with standard compiler flags however so we can support both by
# adding additional boot files for x86_64.
#

I386_SYSTEM_SRC=$(SRC_PATH)/tests/tcg/i386/system
X86_64_SYSTEM_SRC=$(SRC_PATH)/tests/tcg/x86_64/system

# These objects provide the basic boot code and helper functions for all tests
CRT_OBJS=boot.o

X86_64_TEST_C_SRCS=$(wildcard $(X86_64_SYSTEM_SRC)/*.c)
X86_64_TEST_S_SRCS=

X86_64_C_TESTS = $(patsubst $(X86_64_SYSTEM_SRC)/%.c, %, $(X86_64_TEST_C_SRCS))
X86_64_S_TESTS = $(patsubst $(X86_64_SYSTEM_SRC)/%.S, %, $(X86_64_TEST_S_SRCS))

X86_64_TESTS = $(X86_64_C_TESTS)
X86_64_TESTS += $(X86_64_S_TESTS)

CRT_PATH=$(X86_64_SYSTEM_SRC)
LINK_SCRIPT=$(X86_64_SYSTEM_SRC)/kernel.ld
LDFLAGS=-Wl,-T$(LINK_SCRIPT) -Wl,-melf_x86_64
CFLAGS+=-nostdlib -ggdb -O0 $(MINILIB_INC)
LDFLAGS+=-static -nostdlib $(CRT_OBJS) $(MINILIB_OBJS) -lgcc

TESTS+=$(X86_64_TESTS) $(MULTIARCH_TESTS)
EXTRA_RUNS+=$(MULTIARCH_RUNS)

# building head blobs
.PRECIOUS: $(CRT_OBJS)

%.o: $(CRT_PATH)/%.S
	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) -Wa,--noexecstack -c $< -o $@

# Build and link the multiarch tests
%: %.c $(LINK_SCRIPT) $(CRT_OBJS) $(MINILIB_OBJS)
	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) $< -o $@ $(LDFLAGS)

# Build and link the arch tests
%: $(X86_64_SYSTEM_SRC)/%.c $(LINK_SCRIPT) $(CRT_OBJS) $(MINILIB_OBJS)
	$(CC) $(CFLAGS) $(EXTRA_CFLAGS) $< -o $@ $(LDFLAGS)

memory: CFLAGS+=-DCHECK_UNALIGNED=1
patch-target: CFLAGS+=-O0

# Running
QEMU_OPTS+=-device isa-debugcon,chardev=output -device isa-debug-exit,iobase=0xf4,iosize=0x4 -kernel

# Add patch-target to ADDITIONAL_PLUGINS_TESTS
ADDITIONAL_PLUGINS_TESTS += patch-target

run-plugin-patch-target-with-libpatch.so:		\
	PLUGIN_ARGS=$(COMMA)target=ffc0$(COMMA)patch=9090$(COMMA)use_hwaddr=true$(COMMA)debug_insns=false
run-plugin-patch-target-with-libpatch.so:		\
	CHECK_PLUGIN_OUTPUT_COMMAND=$(X86_64_SYSTEM_SRC)/validate-patch.py $@.out