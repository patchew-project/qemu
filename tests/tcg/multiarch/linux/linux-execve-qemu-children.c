#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <malloc.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define MAX_COMM_SIZE (4096)

int
main(int argc, char ** argv, char ** envp) {
    int          fd;
    char         next_arg[2];
    char *       buf;
    ssize_t      off;
    const char * expec_comm;
    assert(argc == 3 || argc == 4);
    fd = open("/proc/self/comm", O_RDONLY);
    assert(fd > 0);

    buf = calloc(MAX_COMM_SIZE + 1, 1);
    assert(buf != NULL);

    off = 0;
    for (;;) {
        ssize_t res = read(fd, buf + off, 1);
        if (res < 0 && errno != EAGAIN) {
            perror("Failed to read comm");
            return -1;
        }
        if (res == 0) {
            break;
        }

        off += res;

        if (off >= MAX_COMM_SIZE) {
            fprintf(stderr, "/proc/self/comm too large for test\n");
            return -1;
        }
    }
    assert(off && buf[off] == '\0' && buf[off - 1] == '\n');
    buf[off - 1] = '\0';
    expec_comm   = basename(argv[1]);
    if (argc == 3 && strncmp(buf, expec_comm, strlen(expec_comm))) {
        fprintf(stderr,
                "Didn't propagate qemu settings\nComm:  '%s'\nExpec: '%s'\n",
                buf, expec_comm);
        return -1;
    }
    free(buf);
    next_arg[0] = argv[2][0];
    next_arg[1] = '\0';
    if (next_arg[0] == '9') {
        return 0;
    }
    next_arg[0] += 1;
    char * next_args[] = { argv[0], argv[1], next_arg, NULL };
    int    eres        = execve(argv[0], &next_args[0], envp);
    if (eres != 0) {
        fprintf(stderr, "Unable to execve: %d/%d -> %s\n", eres, errno,
                strerror(errno));
        return -1;
    }
    return 0;
}
