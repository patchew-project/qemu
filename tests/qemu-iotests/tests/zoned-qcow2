#!/usr/bin/env bash
#
# Test zone management operations for qcow2 file.
#

seq="$(basename $0)"
echo "QA output created by $seq"
status=1 # failure is the default!

file_name="zbc.qcow2"
_cleanup()
{
  _cleanup_test_img
  _rm_test_img "$file_name"
}
trap "_cleanup; exit \$status" 0 1 2 3 15

# get standard environment, filters and checks
. ../common.rc
. ../common.filter
. ../common.qemu

# This test only runs on Linux hosts with qcow2 image files.
_supported_fmt qcow2
_supported_proto file
_supported_os Linux

echo
echo "=== Initial image setup ==="
echo

$QEMU_IMG create -f qcow2 $file_name -o size=768M -o zone_size=64M \
-o zone_capacity=64M -o nr_conv_zones=0 -o max_append_sectors=131072 \
-o max_open_zones=0 -o max_active_zones=0 -o zone_model=1

IMG="--image-opts -n driver=qcow2,file.driver=file,file.filename=$file_name"
QEMU_IO_OPTIONS=$QEMU_IO_OPTIONS_NO_FMT

echo
echo "=== Testing a qcow2 img with zoned format ==="
echo
echo "case 1: test if one zone operation works"

echo "(1) report zones[0]:"
$QEMU_IO $IMG -c "zrp 0 1"
echo
echo "report zones[0~9]:"
$QEMU_IO $IMG -c "zrp 0 10"
echo
echo "report the last zone:"
$QEMU_IO $IMG -c "zrp 0x2C000000 2" # 0x2C000000 / 512 = 0x160000
echo
echo
echo "open zones[0]:"
$QEMU_IO $IMG -c "zo 0 0x4000000" # 0x4000000 / 512 = 0x20000
$QEMU_IO $IMG -c "zrp 0 1"
echo
echo "open zones[1]"
$QEMU_IO $IMG -c "zo 0x4000000 0x4000000"
$QEMU_IO $IMG -c "zrp 0x4000000 1"
echo
echo "open the last zone"
$QEMU_IO $IMG -c "zo 0x2C000000 0x4000000"
$QEMU_IO $IMG -c "zrp 0x2C000000 2"
echo
echo
echo "close zones[0]"
$QEMU_IO $IMG -c "zc 0 0x4000000"
$QEMU_IO $IMG -c "zrp 0 1"
echo
echo "close the last zone"
$QEMU_IO $IMG -c "zc 0x3e70000000 0x4000000"
$QEMU_IO $IMG -c "zrp 0x3e70000000 2"
echo
echo
echo "(4) finish zones[1]"
$QEMU_IO $IMG -c "zf 0x4000000 0x4000000"
$QEMU_IO $IMG -c "zrp 0x4000000 1"
echo
echo
echo "(5) reset zones[1]"
$QEMU_IO $IMG -c "zrs 0x4000000 0x4000000"
$QEMU_IO $IMG -c "zrp 0x4000000 1"
echo
echo
echo "(6) append write with (4k, 8k) data" # the physical block size of the device is 4096
$QEMU_IO $IMG -c "zrp 0 12"
echo "Append write zones[0] one time:"
$QEMU_IO $IMG -c "zap -p 0 0x1000 0x2000"
$QEMU_IO $IMG -c "zrp 0 1"
echo
echo "Append write zones[0] twice:"
$QEMU_IO $IMG -c "zap -p 0 0x1000 0x2000"
$QEMU_IO $IMG -c "zrp 0 1"
echo
echo "Append write zones[1] one time:"
$QEMU_IO $IMG -c "zap -p 0x4000000 0x1000 0x2000"
$QEMU_IO $IMG -c "zrp 0x4000000 1"
echo
echo "Append write zones[1] twice:"
$QEMU_IO $IMG -c "zap -p 0x4000000 0x1000 0x2000"
$QEMU_IO $IMG -c "zrp 0x4000000 1"
echo
echo "Reset all:"
$QEMU_IO $IMG -c "zrs 0 768M"
$QEMU_IO $IMG -c "zrp 0 12"
echo
echo
echo "case 2: test a sets of ops that works or not"

echo "(1) append write (4k, 4k) and then write to full"
$QEMU_IO $IMG -c "zap -p 0 0x1000 0x1000"
echo "wrote (4k, 4k):"
$QEMU_IO $IMG -c "zrp 0 1"
$QEMU_IO $IMG -c "zap -p 0 0x1000 0x3ffd000"
echo "wrote to full:"
$QEMU_IO $IMG -c "zrp 0 1"
echo "Reset zones[0]:"
$QEMU_IO $IMG -c "zrs 0 64M"
$QEMU_IO $IMG -c "zrp 0 1"

echo "(2) write in zones[0], zones[3], zones[8], and then reset all"
$QEMU_IO $IMG -c "zap -p 0 0x1000 0x1000"
$QEMU_IO $IMG -c "zap -p 0xc000000 0x1000 0x1000"
$QEMU_IO $IMG -c "zap -p 0x20000000 0x1000 0x1000"
echo "wrote three zones:"
$QEMU_IO $IMG -c "zrp 0 12"
echo "Reset all:"
$QEMU_IO $IMG -c "zrs 0 768M"
$QEMU_IO $IMG -c "zrp 0 12"

# success, all done
echo "*** done"
rm -f $seq.full
status=0
